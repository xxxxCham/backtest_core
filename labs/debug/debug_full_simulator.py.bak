"""Debug COMPLET du simulateur - pourquoi le SL n'est jamais déclenché ?"""
import pandas as pd
import numpy as np
from data.loader import load_ohlcv
from indicators.bollinger import bollinger_bands

# Charger les données exactes du backtest
df = load_ohlcv('BTCUSDC', '30m', start='2019-06-01', end='2019-10-31')

# Calculer Bollinger
upper, middle, lower = bollinger_bands(df['close'].values, period=20, std_dev=2.0)
upper = pd.Series(upper, index=df.index)
middle = pd.Series(middle, index=df.index)
lower = pd.Series(lower, index=df.index)

# Calculer bb_pos
width = upper - lower
bb_pos_low = (df['low'] - lower) / width
bb_pos_high = (df['high'] - lower) / width

# Ajouter au DataFrame comme le fait la stratégie
df['bb_upper'] = upper
df['bb_middle'] = middle
df['bb_lower'] = lower
df['bb_width'] = width
df['bb_pos_low'] = bb_pos_low
df['bb_pos_high'] = bb_pos_high
df['sl_level'] = -0.32  # Constante
df['tp_level'] = 0.9    # Constante
df['entry_level'] = 0.0

# Vérifier les colonnes
print("=== VERIFICATION COLONNES ===")
required_cols = ["bb_pos_low", "bb_pos_high", "sl_level", "tp_level"]
has_bbpos = all(col in df.columns for col in required_cols)
print(f"has_bbpos = {has_bbpos}")
for col in required_cols:
    print(f"  {col}: present={col in df.columns}, dtype={df[col].dtype if col in df.columns else 'N/A'}")

# Vérifier les NaN
print("\n=== VERIFICATION NaN ===")
invalid_mask = np.isnan(df['bb_pos_low'].values) | np.isnan(df['bb_pos_high'].values)
print(f"Barres avec bb_pos invalide (NaN): {invalid_mask.sum()} / {len(df)}")

# Localiser le trade #6
entry_time = pd.Timestamp('2019-06-06 18:00:00+00:00')
exit_time = pd.Timestamp('2019-10-23 16:00:00+00:00')

# Trouver les indices
entry_idx = df.index.get_indexer([entry_time], method='nearest')[0]
exit_idx = df.index.get_indexer([exit_time], method='nearest')[0]

print(f"\n=== TRADE #6 ===")
print(f"Entry: index {entry_idx}, time {df.index[entry_idx]}")
print(f"Exit: index {exit_idx}, time {df.index[exit_idx]}")
print(f"Durée: {exit_idx - entry_idx} barres")

# Vérifier les valeurs pendant le trade
trade_df = df.iloc[entry_idx:exit_idx+1]
sl_level = -0.32
tp_level = 0.9

print(f"\n=== PENDANT LE TRADE ({len(trade_df)} barres) ===")

# Compter les conditions
sl_triggered = trade_df['bb_pos_low'] <= sl_level
tp_triggered = trade_df['bb_pos_high'] >= tp_level
invalid_during = np.isnan(trade_df['bb_pos_low'].values) | np.isnan(trade_df['bb_pos_high'].values)

print(f"Barres où bb_pos_low <= {sl_level} (SL): {sl_triggered.sum()}")
print(f"Barres où bb_pos_high >= {tp_level} (TP): {tp_triggered.sum()}")
print(f"Barres avec bb_pos invalide: {invalid_during.sum()}")

# Vérifier sl_level_array et tp_level_array
print(f"\n=== VERIFICATION sl_level / tp_level ARRAYS ===")
sl_level_array = df['sl_level'].values
tp_level_array = df['tp_level'].values
print(f"sl_level_array unique values: {np.unique(sl_level_array)}")
print(f"tp_level_array unique values: {np.unique(tp_level_array)}")
print(f"sl_level_array has NaN: {np.isnan(sl_level_array).any()}")
print(f"tp_level_array has NaN: {np.isnan(tp_level_array).any()}")

# SIMULATION MANUELLE du check SL/TP
print(f"\n=== SIMULATION MANUELLE DU CHECK SL/TP ===")
bb_pos_low_arr = df['bb_pos_low'].values
bb_pos_high_arr = df['bb_pos_high'].values

# Simuler exactement le code du simulateur
position = 1  # On est en position long
stop_count = 0
tp_count = 0
invalid_count = 0

for i in range(entry_idx, exit_idx + 1):
    # Code exact du simulateur ligne 224-226
    invalid = np.isnan(bb_pos_low_arr[i]) or np.isnan(bb_pos_high_arr[i])

    if invalid:
        invalid_count += 1
        continue

    stop_hit = bb_pos_low_arr[i] <= sl_level_array[i]
    tp_hit = bb_pos_high_arr[i] >= tp_level_array[i]

    if stop_hit:
        stop_count += 1
    if tp_hit:
        tp_count += 1

print(f"Barres où stop_hit serait True: {stop_count}")
print(f"Barres où tp_hit serait True: {tp_count}")
print(f"Barres invalides (skipped): {invalid_count}")

# Première barre où SL devrait trigger
print(f"\n=== PREMIERE BARRE OU SL DEVRAIT TRIGGER ===")
for i in range(entry_idx, min(entry_idx + 10, exit_idx + 1)):
    invalid = np.isnan(bb_pos_low_arr[i]) or np.isnan(bb_pos_high_arr[i])
    stop_hit = bb_pos_low_arr[i] <= sl_level_array[i] if not invalid else False
    tp_hit = bb_pos_high_arr[i] >= tp_level_array[i] if not invalid else False

    print(f"Barre {i} ({df.index[i]}): "
          f"bb_pos_low={bb_pos_low_arr[i]:.4f}, "
          f"sl_level={sl_level_array[i]:.4f}, "
          f"stop_hit={stop_hit}, "
          f"tp_hit={tp_hit}, "
          f"invalid={invalid}")

# VERIFIER LE FLUX COMPLET DU SIMULATEUR
print(f"\n=== LIRE LE CODE DU SIMULATEUR ===")
print("Vérifions si le bloc SL/TP est bien exécuté...")

# Charger et analyser le code du simulateur
with open('backtest/simulator.py', 'r', encoding='utf-8') as f:
    code = f.read()

# Chercher la structure if/elif
import re

# Trouver le bloc d'entrée et de sortie
entry_match = re.search(r'if position == 0 and signal != 0:', code)
exit_match = re.search(r'elif position != 0:', code)

if entry_match and exit_match:
    print(f"Bloc entrée trouvé à position {entry_match.start()}")
    print(f"Bloc sortie trouvé à position {exit_match.start()}")

    # Le elif signifie que si on entre, on NE vérifie PAS la sortie sur la même barre
    # MAIS ce n'est pas le problème car le trade dure 4.5 mois

# Chercher le bloc SL/TP bb_pos
bbpos_check = re.search(r'if position == 1 and has_bbpos', code)
if bbpos_check:
    print(f"Bloc check bb_pos trouvé à position {bbpos_check.start()}")
    # Extraire les lignes autour
    start = code.rfind('\n', 0, bbpos_check.start()) + 1
    end = code.find('\n', bbpos_check.end() + 200)
    print("\nCode du bloc:")
    print(code[start:end])