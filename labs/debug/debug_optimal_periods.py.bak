#!/usr/bin/env python3
"""
Debug: Pourquoi aucune p√©riode optimale n'est trouv√©e ?
"""

import sys
from pathlib import Path

# Ajouter le r√©pertoire parent au path
sys.path.append(str(Path(__file__).parent.parent.parent))

from data.config import (
    scan_data_availability,
    find_optimal_periods,
    analyze_data_gaps
)

def debug_optimal_periods():
    """Debug d√©taill√© pour comprendre pourquoi aucune p√©riode n'est trouv√©e"""
    print("üîç Debug: Recherche de p√©riodes optimales")

    symbols = ["BTCUSDC"]
    timeframes = ["15m"]  # Test avec un seul timeframe simple

    print(f"Test avec: {symbols} sur {timeframes}")

    # 1. V√©rifier la disponibilit√© des donn√©es
    print("\n1. Scan de disponibilit√©:")
    availability = scan_data_availability(symbols, timeframes)
    print(f"   Plage commune: {availability.has_common_range}")
    if availability.has_common_range:
        print(f"   D√©but: {availability.common_start}")
        print(f"   Fin: {availability.common_end}")
        duration = (availability.common_end - availability.common_start).days
        print(f"   Dur√©e: {duration} jours")

    # 2. Analyser les gaps
    print("\n2. Analyse des gaps:")
    gaps = analyze_data_gaps(symbols[0], timeframes[0])
    print(f"   Nombre de gaps trouv√©s: {len(gaps)}")

    if gaps:
        print("   Premiers gaps:")
        for i, gap in enumerate(gaps[:5]):
            gap_duration = (gap.end - gap.start).total_seconds() / 3600
            print(f"     Gap #{i+1}: {gap.start} ‚Üí {gap.end} ({gap_duration:.1f}h)")

    # 3. Tenter de trouver des p√©riodes optimales avec diff√©rents param√®tres
    print("\n3. Recherche de p√©riodes optimales:")

    test_params = [
        {"min_period_days": 7, "max_periods": 5},
        {"min_period_days": 30, "max_periods": 5},
        {"min_period_days": 90, "max_periods": 5},
        {"min_period_days": 1, "max_periods": 10}  # Tr√®s permissif
    ]

    for i, params in enumerate(test_params):
        print(f"\n   Test #{i+1}: min_period_days={params['min_period_days']}")
        try:
            periods = find_optimal_periods(
                symbols=symbols,
                timeframes=timeframes,
                **params
            )
            print(f"     R√©sultat: {len(periods)} p√©riodes trouv√©es")

            if periods:
                best = periods[0]
                duration = (best.end_date - best.start_date).days
                print(f"     Meilleure: {best.start_date.strftime('%Y-%m-%d')} ‚Üí {best.end_date.strftime('%Y-%m-%d')} ({duration}j)")
                print(f"     Score: {best.completeness_score:.1f}%, Densit√©: {best.avg_data_density:.3f}")
                print(f"     Description: {best.description}")
        except Exception as e:
            print(f"     Erreur: {e}")

    # 4. Test direct avec plage manuelle
    print("\n4. Test avec plage manuelle:")
    if availability.has_common_range:
        try:
            # Test avec une plage tr√®s courte mais r√©cente
            from datetime import datetime, timedelta
            import pandas as pd

            recent_end = availability.common_end
            recent_start = recent_end - timedelta(days=30)  # Derniers 30 jours

            print(f"   Plage test: {recent_start} ‚Üí {recent_end}")

            # Simulation de find_optimal_periods avec debug
            from data.loader import get_data_date_range
            date_range = get_data_date_range(symbols[0], timeframes[0])
            print(f"   Range des donn√©es: {date_range}")

        except Exception as e:
            print(f"   Erreur: {e}")

if __name__ == "__main__":
    debug_optimal_periods()