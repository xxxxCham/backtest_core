
   
                              

                                           ^
[1m.\performance\monitor.py[m[36m:[m8[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
"""
Module-ID: performance.monitor

Purpose: Monitoring temps r√©el syst√®me (CPU, m√©moire, I/O, GPU) pendant ex√©cution.

Role in pipeline: observability

Key components: PerformanceMonitor, ResourceTracker, psutil wrapper, Rich display

Inputs: None (reads system metrics)

Outputs: Stats {cpu_pct, mem_mb, io_r_mb, gpu_mem_mb}, timeline

Dependencies: psutil, threading, time, rich (optionnel)

Conventions: Background thread safe; thread-safe stats dict; 1s interval.

Read-if: Modification metrics collection ou refresh interval.

Skip-if: Vous appelez monitor.get_stats().
"""
   
                              

                                           ^
[1m.\performance\parallel.py[m[36m:[m4[36m:[m80[36m:[m [1m[31mE501[m line too long (85 > 79 characters)
"""
Module-ID: performance.parallel

Purpose: Parall√©lisation backtests - ProcessPoolExecutor/ThreadPoolExecutor + joblib.

Role in pipeline: performance optimization

Key components: ParallelRunner, parallel_sweep(), job chunking, progress tracking

Inputs: Function callable, param_grid, n_jobs (CPU count)

Outputs: List[results], timing stats, failure tracking

Dependencies: concurrent.futures, joblib (optionnel), numpy, pandas

Conventions: n_jobs=-1 (all CPUs); timeout protection; error aggregation.

Read-if: Modification parallelization strategy ou max_workers.

Skip-if: Vous appelez parallel_sweep(func, param_grid).
"""
   
                               

                                          ^
[1m.\performance\parallel.py[m[36m:[m8[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
"""
Module-ID: performance.parallel

Purpose: Parall√©lisation backtests - ProcessPoolExecutor/ThreadPoolExecutor + joblib.

Role in pipeline: performance optimization

Key components: ParallelRunner, parallel_sweep(), job chunking, progress tracking

Inputs: Function callable, param_grid, n_jobs (CPU count)

Outputs: List[results], timing stats, failure tracking

Dependencies: concurrent.futures, joblib (optionnel), numpy, pandas

Conventions: n_jobs=-1 (all CPUs); timeout protection; error aggregation.

Read-if: Modification parallelization strategy ou max_workers.

Skip-if: Vous appelez parallel_sweep(func, param_grid).
"""
   
                               

                                          ^
[1m.\performance\parallel.py[m[36m:[m176[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
        logger.info("joblib non disponible, utilisation de ProcessPoolExecutor")
                                                                               ^
[1m.\performance\parallel.py[m[36m:[m289[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
        """
        Ex√©cute un sweep parall√®le complet (OPTIMIS√â - sans chunking s√©quentiel).

        Args:
            run_func: Fonction de backtest, signature: run_func(params, **kwargs)
            param_grid: Liste des combinaisons de param√®tres
            progress_callback: Callback optionnel (completed, total)
            **fixed_kwargs: Arguments fixes (data, etc.)

        Returns:
            SweepResult avec tous les r√©sultats et m√©triques
        """
           
                                                                   ^
[1m.\performance\parallel.py[m[36m:[m292[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
        """
        Ex√©cute un sweep parall√®le complet (OPTIMIS√â - sans chunking s√©quentiel).

        Args:
            run_func: Fonction de backtest, signature: run_func(params, **kwargs)
            param_grid: Liste des combinaisons de param√®tres
            progress_callback: Callback optionnel (completed, total)
            **fixed_kwargs: Arguments fixes (data, etc.)

        Returns:
            SweepResult avec tous les r√©sultats et m√©triques
        """
           
                                                                   ^
[1m.\performance\parallel.py[m[36m:[m313[36m:[m80[36m:[m [1m[31mE501[m line too long (89 > 79 characters)
        ExecutorClass = ProcessPoolExecutor if self.use_processes else ThreadPoolExecutor
                                                                               ^
[1m.\performance\parallel.py[m[36m:[m322[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
            # ‚úÖ Soumettre TOUTES les t√¢ches d'un coup (pas de chunking s√©quentiel)
                                                                               ^
[1m.\performance\parallel.py[m[36m:[m354[36m:[m80[36m:[m [1m[31mE501[m line too long (86 > 79 characters)
                    self._progress_callback(self._current_progress, self._total_tasks)
                                                                               ^
[1m.\performance\parallel.py[m[36m:[m356[36m:[m80[36m:[m [1m[31mE501[m line too long (90 > 79 characters)
                # Tracking m√©moire p√©riodique (tous les 10 r√©sultats pour √©viter overhead)
                                                                               ^
[1m.\performance\parallel.py[m[36m:[m362[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
                    if self.memory_limit_gb and current_mem > self.memory_limit_gb:
                                                                               ^
[1m.\performance\parallel.py[m[36m:[m363[36m:[m80[36m:[m [1m[31mE501[m line too long (88 > 79 characters)
                        logger.warning(f"Limite m√©moire atteinte: {current_mem:.1f} GB")
                                                                               ^
[1m.\performance\parallel.py[m[36m:[m371[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
            f"‚úÖ Sweep termin√©: {n_completed}/{self._total_tasks} en {elapsed:.1f}s "
                                                                               ^
[1m.\performance\parallel.py[m[36m:[m450[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
            ParallelConfig(max_workers=cpu_count, use_processes=False),  # threading
                                                                               ^
[1m.\performance\parallel.py[m[36m:[m463[36m:[m80[36m:[m [1m[31mE501[m line too long (85 > 79 characters)
        runner.run_sweep(func, sample_params[:min(20, len(sample_params))], **kwargs)
                                                                               ^
[1m.\performance\profiler.py[m[36m:[m4[36m:[m80[36m:[m [1m[31mE501[m line too long (90 > 79 characters)
"""
Module-ID: performance.profiler

Purpose: Profiling cProfile/line_profiler - identifie goulots d'√©tranglement (CPU, ligne).

Role in pipeline: performance optimization

Key components: Profiler, ProfileStats, @profile_function decorator, save_report()

Inputs: Function/code block √† profiler

Outputs: Stats {duration_ms, top_functions[], line_stats}, text report

Dependencies: cProfile, pstats, functools, time, pathlib

Conventions: Context manager support; CSV export; @profile decorator.

Read-if: Modification profiling strategy ou report format.

Skip-if: Vous appelez Profiler.start() ‚Üí stop() ‚Üí print_stats().
"""
   
                               

                                          ^
[1m.\performance\profiler.py[m[36m:[m8[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
"""
Module-ID: performance.profiler

Purpose: Profiling cProfile/line_profiler - identifie goulots d'√©tranglement (CPU, ligne).

Role in pipeline: performance optimization

Key components: Profiler, ProfileStats, @profile_function decorator, save_report()

Inputs: Function/code block √† profiler

Outputs: Stats {duration_ms, top_functions[], line_stats}, text report

Dependencies: cProfile, pstats, functools, time, pathlib

Conventions: Context manager support; CSV export; @profile decorator.

Read-if: Modification profiling strategy ou report format.

Skip-if: Vous appelez Profiler.start() ‚Üí stop() ‚Üí print_stats().
"""
   
                               

                                          ^
[1m.\performance\profiler.py[m[36m:[m80[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
    def __init__(self, name: str = "profile", output_dir: Optional[str] = None):
                                                                               ^
[1m.\performance\profiler.py[m[36m:[m138[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
        for func, (cc, nc, tt, ct, callers) in list(self._stats.stats.items())[:20]:
                                                                               ^
[1m.\performance\profiler.py[m[36m:[m152[36m:[m80[36m:[m [1m[31mE501[m line too long (91 > 79 characters)
        logger.debug(f"Profiler '{self.name}' arr√™t√©: {total_time:.2f}s, {n_calls} appels")
                                                                               ^
[1m.\performance\profiler.py[m[36m:[m180[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
            logger.warning("Pas de stats disponibles - avez-vous appel√© stop()?")
                                                                               ^
[1m.\performance\profiler.py[m[36m:[m244[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
        for func, (cc, nc, tt, ct, callers) in list(self._stats.stats.items())[:n]:
                                                                               ^
[1m.\run_grid_backtest.py[m[36m:[m6[36m:[m80[36m:[m [1m[31mE501[m line too long (87 > 79 characters)
"""
Script CLI pour lancer un backtest en mode grille.

Usage:
    python run_grid_backtest.py --strategy atr_channel --symbol BTCUSDC --timeframe 30m
"""
   
                                                  

      
                ^
[1m.\run_grid_backtest.py[m[36m:[m18[36m:[m1[36m:[m [1m[31mE402[m module level import not at top of file
from itertools import product
^
[1m.\run_grid_backtest.py[m[36m:[m20[36m:[m1[36m:[m [1m[31mE402[m module level import not at top of file
from backtest.engine import BacktestEngine
^
[1m.\run_grid_backtest.py[m[36m:[m21[36m:[m1[36m:[m [1m[31mE402[m module level import not at top of file
from data.loader import load_ohlcv
^
[1m.\run_grid_backtest.py[m[36m:[m25[36m:[m80[36m:[m [1m[31mE501[m line too long (85 > 79 characters)
    parser = argparse.ArgumentParser(description="Lancer un backtest en mode grille")
                                                                               ^
[1m.\run_grid_backtest.py[m[36m:[m26[36m:[m80[36m:[m [1m[31mE501[m line too long (88 > 79 characters)
    parser.add_argument("--strategy", default="atr_channel", help="Nom de la strat√©gie")
                                                                               ^
[1m.\run_grid_backtest.py[m[36m:[m27[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
    parser.add_argument("--symbol", default="BTCUSDC", help="Symbole (ex: BTCUSDC)")
                                                                               ^
[1m.\run_grid_backtest.py[m[36m:[m28[36m:[m80[36m:[m [1m[31mE501[m line too long (89 > 79 characters)
    parser.add_argument("--timeframe", default="30m", help="Timeframe (ex: 1h, 30m, 1d)")
                                                                               ^
[1m.\run_grid_backtest.py[m[36m:[m29[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
    parser.add_argument("--start-date", default="2024-12-01", help="Date de d√©but")
                                                                               ^
[1m.\run_grid_backtest.py[m[36m:[m31[36m:[m80[36m:[m [1m[31mE501[m line too long (97 > 79 characters)
    parser.add_argument("--initial-capital", type=float, default=10000.0, help="Capital initial")
                                                                               ^
[1m.\run_grid_backtest.py[m[36m:[m32[36m:[m80[36m:[m [1m[31mE501[m line too long (97 > 79 characters)
    parser.add_argument("--max-combos", type=int, default=100, help="Nombre max de combinaisons")
                                                                               ^
[1m.\run_grid_backtest.py[m[36m:[m50[36m:[m80[36m:[m [1m[31mE501[m line too long (116 > 79 characters)
        sample_file = Path(__file__).parent / "data" / "sample_data" / f"{args.symbol}_{args.timeframe}_6months.csv"
                                                                               ^
[1m.\run_grid_backtest.py[m[36m:[m52[36m:[m80[36m:[m [1m[31mE501[m line too long (119 > 79 characters)
            sample_file = Path(__file__).parent / "data" / "sample_data" / f"{args.symbol}_{args.timeframe}_sample.csv"
                                                                               ^
[1m.\run_llm_optimization.py[m[36m:[m6[36m:[m80[36m:[m [1m[31mE501[m line too long (138 > 79 characters)
"""
Script CLI pour lancer une optimisation LLM directement depuis le terminal.

Usage:
    python run_llm_optimization.py --strategy bollinger_atr --symbol BTCUSDC --timeframe 30m --start-date 2024-01-01 --end-date 2024-12-31
"""
   
                                                                           ^
[1m.\run_llm_optimization.py[m[36m:[m16[36m:[m1[36m:[m [1m[31mE402[m module level import not at top of file
from agents.integration import create_orchestrator_with_backtest
^
[1m.\run_llm_optimization.py[m[36m:[m17[36m:[m1[36m:[m [1m[31mE402[m module level import not at top of file
from agents.llm_client import LLMConfig
^
[1m.\run_llm_optimization.py[m[36m:[m18[36m:[m1[36m:[m [1m[31mE402[m module level import not at top of file
from data.loader import load_ohlcv
^
[1m.\run_llm_optimization.py[m[36m:[m19[36m:[m1[36m:[m [1m[31mE402[m module level import not at top of file
from strategies.base import get_strategy
^
[1m.\run_llm_optimization.py[m[36m:[m24[36m:[m80[36m:[m [1m[31mE501[m line too long (90 > 79 characters)
    parser.add_argument("--strategy", default="bollinger_atr", help="Nom de la strat√©gie")
                                                                               ^
[1m.\run_llm_optimization.py[m[36m:[m25[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
    parser.add_argument("--symbol", default="BTCUSDC", help="Symbole (ex: BTCUSDC)")
                                                                               ^
[1m.\run_llm_optimization.py[m[36m:[m26[36m:[m80[36m:[m [1m[31mE501[m line too long (89 > 79 characters)
    parser.add_argument("--timeframe", default="30m", help="Timeframe (ex: 1h, 30m, 1d)")
                                                                               ^
[1m.\run_llm_optimization.py[m[36m:[m27[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
    parser.add_argument("--start-date", default="2024-01-01", help="Date de d√©but")
                                                                               ^
[1m.\run_llm_optimization.py[m[36m:[m29[36m:[m80[36m:[m [1m[31mE501[m line too long (97 > 79 characters)
    parser.add_argument("--initial-capital", type=float, default=10000.0, help="Capital initial")
                                                                               ^
[1m.\run_llm_optimization.py[m[36m:[m30[36m:[m80[36m:[m [1m[31mE501[m line too long (101 > 79 characters)
    parser.add_argument("--max-iterations", type=int, default=10, help="Nombre max d'it√©rations LLM")
                                                                               ^
[1m.\run_llm_optimization.py[m[36m:[m31[36m:[m80[36m:[m [1m[31mE501[m line too long (99 > 79 characters)
    parser.add_argument("--model", default="deepseek-r1-distill:14b", help="Mod√®le LLM √† utiliser")
                                                                               ^
[1m.\run_llm_optimization.py[m[36m:[m123[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
                print(f"   PnL: ${result.final_metrics.get('total_pnl', 0):,.2f}")
                                                                               ^
[1m.\run_llm_optimization.py[m[36m:[m124[36m:[m80[36m:[m [1m[31mE501[m line too long (86 > 79 characters)
                print(f"   Sharpe: {result.final_metrics.get('sharpe_ratio', 0):.3f}")
                                                                               ^
[1m.\run_llm_optimization.py[m[36m:[m125[36m:[m80[36m:[m [1m[31mE501[m line too long (91 > 79 characters)
                print(f"   Max DD: {result.final_metrics.get('max_drawdown_pct', 0):.2f}%")
                                                                               ^
[1m.\run_llm_optimization.py[m[36m:[m126[36m:[m80[36m:[m [1m[31mE501[m line too long (89 > 79 characters)
                print(f"   Win Rate: {result.final_metrics.get('win_rate_pct', 0):.1f}%")
                                                                               ^
[1m.\run_llm_optimization.py[m[36m:[m127[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
                print(f"   Trades: {result.final_metrics.get('total_trades', 0)}")
                                                                               ^
[1m.\run_llm_optimization.py[m[36m:[m130[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
            print(f"   It√©rations: {getattr(result, 'iteration_count', 'N/A')}")
                                                                               ^
[1m.\run_llm_optimization.py[m[36m:[m135[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
                print(f"   Message: {getattr(result, 'message', 'Aucun message')}")
                                                                               ^
[1m.\strategies\base.py[m[36m:[m8[36m:[m80[36m:[m [1m[31mE501[m line too long (98 > 79 characters)
"""
Module-ID: strategies.base

Purpose: Classe abstraite et contrat pour toutes les strat√©gies de trading.

Role in pipeline: core

Key components: StrategyBase (abstract), StrategyResult (dataclass), register_strategy (decorator)

Inputs: DataFrame OHLCV, param√®tres utilisateur, indicateurs pr√©-calcul√©s

Outputs: StrategyResult (signaux, prix, stop/target, metadata)

Dependencies: pandas, numpy, utils.parameters, dataclasses

Conventions: Signaux standardis√©s (1=long, -1=short, 0=flat); param√®tres clamp√©s aux bornes; indicateurs calcul√©s ou fournis; preset/granularit√© support.

Read-if: Cr√©ation nouvelle strat√©gie, modification interface ou patterns standards.

Skip-if: Vous ne changez qu'une strat√©gie sp√©cifique.
"""
   
                          

                                               ^
[1m.\strategies\base.py[m[36m:[m16[36m:[m80[36m:[m [1m[31mE501[m line too long (153 > 79 characters)
"""
Module-ID: strategies.base

Purpose: Classe abstraite et contrat pour toutes les strat√©gies de trading.

Role in pipeline: core

Key components: StrategyBase (abstract), StrategyResult (dataclass), register_strategy (decorator)

Inputs: DataFrame OHLCV, param√®tres utilisateur, indicateurs pr√©-calcul√©s

Outputs: StrategyResult (signaux, prix, stop/target, metadata)

Dependencies: pandas, numpy, utils.parameters, dataclasses

Conventions: Signaux standardis√©s (1=long, -1=short, 0=flat); param√®tres clamp√©s aux bornes; indicateurs calcul√©s ou fournis; preset/granularit√© support.

Read-if: Cr√©ation nouvelle strat√©gie, modification interface ou patterns standards.

Skip-if: Vous ne changez qu'une strat√©gie sp√©cifique.
"""
   
                          

                                               ^
[1m.\strategies\base.py[m[36m:[m18[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
"""
Module-ID: strategies.base

Purpose: Classe abstraite et contrat pour toutes les strat√©gies de trading.

Role in pipeline: core

Key components: StrategyBase (abstract), StrategyResult (dataclass), register_strategy (decorator)

Inputs: DataFrame OHLCV, param√®tres utilisateur, indicateurs pr√©-calcul√©s

Outputs: StrategyResult (signaux, prix, stop/target, metadata)

Dependencies: pandas, numpy, utils.parameters, dataclasses

Conventions: Signaux standardis√©s (1=long, -1=short, 0=flat); param√®tres clamp√©s aux bornes; indicateurs calcul√©s ou fournis; preset/granularit√© support.

Read-if: Cr√©ation nouvelle strat√©gie, modification interface ou patterns standards.

Skip-if: Vous ne changez qu'une strat√©gie sp√©cifique.
"""
   
                          

                                               ^
[1m.\strategies\base.py[m[36m:[m131[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
        """D√©termine si les param√®tres optionnels (ex: leverage) sont inclus."""
                                                                               ^
[1m.\strategies\base.py[m[36m:[m138[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
        env_flag = os.getenv("BACKTEST_INCLUDE_OPTIONAL_PARAMS", "").strip().lower()
                                                                               ^
[1m.\strategies\base.py[m[36m:[m141[36m:[m80[36m:[m [1m[31mE501[m line too long (92 > 79 characters)
    def get_param_ranges(self, include_optional: Optional[bool] = None) -> Dict[str, tuple]:
                                                                               ^
[1m.\strategies\base.py[m[36m:[m142[36m:[m80[36m:[m [1m[31mE501[m line too long (89 > 79 characters)
        """Retourne les plages en excluant les param√®tres non optimisables par d√©faut."""
                                                                               ^
[1m.\strategies\base.py[m[36m:[m143[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
        include = self._should_include_optional_params(override=include_optional)
                                                                               ^
[1m.\strategies\base.py[m[36m:[m218[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
        """
        G√©n√®re les signaux de trading.

        Args:
            df: DataFrame OHLCV avec colonnes (open, high, low, close, volume)
            indicators: Dict des indicateurs pr√©calcul√©s
                       Ex: {"bollinger": (upper, middle, lower), "atr": atr_array}
            params: Param√®tres de la strat√©gie
                   Ex: {"entry_z": 2.0, "k_sl": 1.5}

        Returns:
            pd.Series de signaux index√©e par le temps:
            - 1: Signal d'achat (entrer long)
            - -1: Signal de vente (entrer short)
            - 0: Aucun signal (rester flat ou maintenir position)

        Notes:
            - La s√©rie retourn√©e doit avoir le m√™me index que df
            - Les signaux repr√©sentent des intentions d'entr√©e/sortie
            - La gestion des positions est faite par le moteur de backtest
        """
           
                                      

             
             ^
[1m.\strategies\base.py[m[36m:[m277[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
    def validate_params(self, params: Dict[str, Any]) -> Tuple[bool, List[str]]:
                                                                               ^
[1m.\strategies\base.py[m[36m:[m436[36m:[m80[36m:[m [1m[31mE501[m line too long (85 > 79 characters)
        raise ValueError(f"Strat√©gie '{name}' non trouv√©e. Disponibles: {available}")
                                                                               ^
[1m.\strategies\bollinger_atr.py[m[36m:[m4[36m:[m80[36m:[m [1m[31mE501[m line too long (85 > 79 characters)
"""
Module-ID: strategies.bollinger_atr

Purpose: Strat√©gie de breakout bas√©e sur les Bandes de Bollinger et ATR (volatilit√©).

Role in pipeline: core

Key components: BollingerATRStrategy, bb_window, bb_std, atr_period, atr_multiplier

Inputs: DataFrame OHLCV avec colonnes high, low, close

Outputs: StrategyResult (signaux 1/-1/0 sur breakouts bandes/ATR)

Dependencies: strategies.base, indicators.bollinger, indicators.atr, utils.parameters

Conventions: bb_window > atr_period recommand√©; bandes sup√©rieures/inf√©rieures + filtrage ATR; volume optionnel.

Read-if: Modification breakout logic, seuils volatilit√©, ou constraints.

Skip-if: Vous ne changez que d'autres strat√©gies.
"""
   
                                   

                                      ^
[1m.\strategies\bollinger_atr.py[m[36m:[m8[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
"""
Module-ID: strategies.bollinger_atr

Purpose: Strat√©gie de breakout bas√©e sur les Bandes de Bollinger et ATR (volatilit√©).

Role in pipeline: core

Key components: BollingerATRStrategy, bb_window, bb_std, atr_period, atr_multiplier

Inputs: DataFrame OHLCV avec colonnes high, low, close

Outputs: StrategyResult (signaux 1/-1/0 sur breakouts bandes/ATR)

Dependencies: strategies.base, indicators.bollinger, indicators.atr, utils.parameters

Conventions: bb_window > atr_period recommand√©; bandes sup√©rieures/inf√©rieures + filtrage ATR; volume optionnel.

Read-if: Modification breakout logic, seuils volatilit√©, ou constraints.

Skip-if: Vous ne changez que d'autres strat√©gies.
"""
   
                                   

                                      ^
[1m.\strategies\bollinger_atr.py[m[36m:[m14[36m:[m80[36m:[m [1m[31mE501[m line too long (85 > 79 characters)
"""
Module-ID: strategies.bollinger_atr

Purpose: Strat√©gie de breakout bas√©e sur les Bandes de Bollinger et ATR (volatilit√©).

Role in pipeline: core

Key components: BollingerATRStrategy, bb_window, bb_std, atr_period, atr_multiplier

Inputs: DataFrame OHLCV avec colonnes high, low, close

Outputs: StrategyResult (signaux 1/-1/0 sur breakouts bandes/ATR)

Dependencies: strategies.base, indicators.bollinger, indicators.atr, utils.parameters

Conventions: bb_window > atr_period recommand√©; bandes sup√©rieures/inf√©rieures + filtrage ATR; volume optionnel.

Read-if: Modification breakout logic, seuils volatilit√©, ou constraints.

Skip-if: Vous ne changez que d'autres strat√©gies.
"""
   
                                   

                                      ^
[1m.\strategies\bollinger_atr.py[m[36m:[m16[36m:[m80[36m:[m [1m[31mE501[m line too long (112 > 79 characters)
"""
Module-ID: strategies.bollinger_atr

Purpose: Strat√©gie de breakout bas√©e sur les Bandes de Bollinger et ATR (volatilit√©).

Role in pipeline: core

Key components: BollingerATRStrategy, bb_window, bb_std, atr_period, atr_multiplier

Inputs: DataFrame OHLCV avec colonnes high, low, close

Outputs: StrategyResult (signaux 1/-1/0 sur breakouts bandes/ATR)

Dependencies: strategies.base, indicators.bollinger, indicators.atr, utils.parameters

Conventions: bb_window > atr_period recommand√©; bandes sup√©rieures/inf√©rieures + filtrage ATR; volume optionnel.

Read-if: Modification breakout logic, seuils volatilit√©, ou constraints.

Skip-if: Vous ne changez que d'autres strat√©gies.
"""
   
                                   

                                      ^
[1m.\strategies\bollinger_atr.py[m[36m:[m166[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
        signals = pd.Series(0.0, index=df.index, dtype=np.float64, name="signals")
                                                                               ^
[1m.\strategies\bollinger_atr.py[m[36m:[m224[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
        # Ces stop-loss sont stock√©s dans le DataFrame pour utilisation ult√©rieure
                                                                               ^
[1m.\strategies\bollinger_atr.py[m[36m:[m229[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
        stop_long = lower - 0.5 * bb_distance_lower   # En dessous de lower_band
                                                                               ^
[1m.\strategies\bollinger_atr.py[m[36m:[m305[36m:[m80[36m:[m [1m[31mE501[m line too long (87 > 79 characters)
        """
        Calcule le niveau de stop-loss bas√© sur les bandes de Bollinger.

        Logique:
        - LONG: stop = lower_band - 0.5 √ó (middle_band - lower_band)
                (moiti√© de la distance entre middle et lower, EN DESSOUS de lower_band)
        - SHORT: stop = upper_band + 0.5 √ó (upper_band - middle_band)
                (moiti√© de la distance entre upper et middle, AU DESSUS de upper_band)

        Cette valeur est FIXE au moment de l'entr√©e (ne change pas avec les nouvelles bandes).

        Args:
            entry_price: Prix d'entr√©e
            atr_value: Valeur ATR (non utilis√© avec stop Bollinger)
            side: "long" ou "short"
            params: Param√®tres
            bb_middle: Bande de Bollinger m√©diane (au moment de l'entr√©e)
            bb_upper: Bande de Bollinger sup√©rieure (au moment de l'entr√©e)
            bb_lower: Bande de Bollinger inf√©rieure (au moment de l'entr√©e)

        Returns:
            Prix du stop-loss
        """
           
                                                                   ^
[1m.\strategies\bollinger_atr.py[m[36m:[m307[36m:[m80[36m:[m [1m[31mE501[m line too long (86 > 79 characters)
        """
        Calcule le niveau de stop-loss bas√© sur les bandes de Bollinger.

        Logique:
        - LONG: stop = lower_band - 0.5 √ó (middle_band - lower_band)
                (moiti√© de la distance entre middle et lower, EN DESSOUS de lower_band)
        - SHORT: stop = upper_band + 0.5 √ó (upper_band - middle_band)
                (moiti√© de la distance entre upper et middle, AU DESSUS de upper_band)

        Cette valeur est FIXE au moment de l'entr√©e (ne change pas avec les nouvelles bandes).

        Args:
            entry_price: Prix d'entr√©e
            atr_value: Valeur ATR (non utilis√© avec stop Bollinger)
            side: "long" ou "short"
            params: Param√®tres
            bb_middle: Bande de Bollinger m√©diane (au moment de l'entr√©e)
            bb_upper: Bande de Bollinger sup√©rieure (au moment de l'entr√©e)
            bb_lower: Bande de Bollinger inf√©rieure (au moment de l'entr√©e)

        Returns:
            Prix du stop-loss
        """
           
                                                                   ^
[1m.\strategies\bollinger_atr.py[m[36m:[m309[36m:[m80[36m:[m [1m[31mE501[m line too long (94 > 79 characters)
        """
        Calcule le niveau de stop-loss bas√© sur les bandes de Bollinger.

        Logique:
        - LONG: stop = lower_band - 0.5 √ó (middle_band - lower_band)
                (moiti√© de la distance entre middle et lower, EN DESSOUS de lower_band)
        - SHORT: stop = upper_band + 0.5 √ó (upper_band - middle_band)
                (moiti√© de la distance entre upper et middle, AU DESSUS de upper_band)

        Cette valeur est FIXE au moment de l'entr√©e (ne change pas avec les nouvelles bandes).

        Args:
            entry_price: Prix d'entr√©e
            atr_value: Valeur ATR (non utilis√© avec stop Bollinger)
            side: "long" ou "short"
            params: Param√®tres
            bb_middle: Bande de Bollinger m√©diane (au moment de l'entr√©e)
            bb_upper: Bande de Bollinger sup√©rieure (au moment de l'entr√©e)
            bb_lower: Bande de Bollinger inf√©rieure (au moment de l'entr√©e)

        Returns:
            Prix du stop-loss
        """
           
                                                                   ^
[1m.\strategies\bollinger_atr.py[m[36m:[m323[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
        # Si les bandes de Bollinger sont fournies, utiliser la logique Bollinger
                                                                               ^
[1m.\strategies\bollinger_atr.py[m[36m:[m324[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
        if bb_middle is not None and bb_upper is not None and bb_lower is not None:
                                                                               ^
[1m.\strategies\bollinger_atr.py[m[36m:[m334[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
            # Fallback: logique ATR legacy (si les bandes ne sont pas disponibles)
                                                                               ^
[1m.\strategies\bollinger_atr_v2.py[m[36m:[m4[36m:[m80[36m:[m [1m[31mE501[m line too long (99 > 79 characters)
"""
Module-ID: strategies.bollinger_atr_v2

Purpose: Strat√©gie mean-reversion Bollinger Bands + ATR avec stop-loss Bollinger param√©trable (V2).

Role in pipeline: trading strategy

Key components: BollingerATRStrategyV2, register_strategy("bollinger_atr_v2")

Inputs: DataFrame OHLCV, param√®tres (bb_period, bb_std, entry_z, atr_period, atr_percentile, bb_stop_factor, leverage)

Outputs: StrategyResult (signaux LONG/SHORT, prix, stop-loss Bollinger, m√©tadata)

Dependencies: pandas, numpy, utils.parameters, strategies.base

Conventions: LONG sur bande inf√©rieure (oversold), SHORT sur bande sup√©rieure (overbought); stop-loss fixe bas√© sur Bollinger distance √ó bb_stop_factor (0.2-2.0); filtre ATR exclut march√©s plats; signaux 1/-1/0.

Am√©liorations V2 vs V1: Stop-loss bas√© Bollinger au lieu ATR; facteur stop param√©trable; stop fixe √† l'entr√©e (ne bouge pas).

Read-if: Configuration V2 sp√©cifique, param√®tres stop-loss Bollinger, ou logique mean-reversion Bollinger+ATR.

Skip-if: Vous utilisez V1 ou V3, ou autres strat√©gies.
"""
   
                                      

                                   ^
[1m.\strategies\bollinger_atr_v2.py[m[36m:[m10[36m:[m80[36m:[m [1m[31mE501[m line too long (118 > 79 characters)
"""
Module-ID: strategies.bollinger_atr_v2

Purpose: Strat√©gie mean-reversion Bollinger Bands + ATR avec stop-loss Bollinger param√©trable (V2).

Role in pipeline: trading strategy

Key components: BollingerATRStrategyV2, register_strategy("bollinger_atr_v2")

Inputs: DataFrame OHLCV, param√®tres (bb_period, bb_std, entry_z, atr_period, atr_percentile, bb_stop_factor, leverage)

Outputs: StrategyResult (signaux LONG/SHORT, prix, stop-loss Bollinger, m√©tadata)

Dependencies: pandas, numpy, utils.parameters, strategies.base

Conventions: LONG sur bande inf√©rieure (oversold), SHORT sur bande sup√©rieure (overbought); stop-loss fixe bas√© sur Bollinger distance √ó bb_stop_factor (0.2-2.0); filtre ATR exclut march√©s plats; signaux 1/-1/0.

Am√©liorations V2 vs V1: Stop-loss bas√© Bollinger au lieu ATR; facteur stop param√©trable; stop fixe √† l'entr√©e (ne bouge pas).

Read-if: Configuration V2 sp√©cifique, param√®tres stop-loss Bollinger, ou logique mean-reversion Bollinger+ATR.

Skip-if: Vous utilisez V1 ou V3, ou autres strat√©gies.
"""
   
                                      

                                   ^
[1m.\strategies\bollinger_atr_v2.py[m[36m:[m12[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
"""
Module-ID: strategies.bollinger_atr_v2

Purpose: Strat√©gie mean-reversion Bollinger Bands + ATR avec stop-loss Bollinger param√©trable (V2).

Role in pipeline: trading strategy

Key components: BollingerATRStrategyV2, register_strategy("bollinger_atr_v2")

Inputs: DataFrame OHLCV, param√®tres (bb_period, bb_std, entry_z, atr_period, atr_percentile, bb_stop_factor, leverage)

Outputs: StrategyResult (signaux LONG/SHORT, prix, stop-loss Bollinger, m√©tadata)

Dependencies: pandas, numpy, utils.parameters, strategies.base

Conventions: LONG sur bande inf√©rieure (oversold), SHORT sur bande sup√©rieure (overbought); stop-loss fixe bas√© sur Bollinger distance √ó bb_stop_factor (0.2-2.0); filtre ATR exclut march√©s plats; signaux 1/-1/0.

Am√©liorations V2 vs V1: Stop-loss bas√© Bollinger au lieu ATR; facteur stop param√©trable; stop fixe √† l'entr√©e (ne bouge pas).

Read-if: Configuration V2 sp√©cifique, param√®tres stop-loss Bollinger, ou logique mean-reversion Bollinger+ATR.

Skip-if: Vous utilisez V1 ou V3, ou autres strat√©gies.
"""
   
                                      

                                   ^
[1m.\strategies\bollinger_atr_v2.py[m[36m:[m16[36m:[m80[36m:[m [1m[31mE501[m line too long (211 > 79 characters)
"""
Module-ID: strategies.bollinger_atr_v2

Purpose: Strat√©gie mean-reversion Bollinger Bands + ATR avec stop-loss Bollinger param√©trable (V2).

Role in pipeline: trading strategy

Key components: BollingerATRStrategyV2, register_strategy("bollinger_atr_v2")

Inputs: DataFrame OHLCV, param√®tres (bb_period, bb_std, entry_z, atr_period, atr_percentile, bb_stop_factor, leverage)

Outputs: StrategyResult (signaux LONG/SHORT, prix, stop-loss Bollinger, m√©tadata)

Dependencies: pandas, numpy, utils.parameters, strategies.base

Conventions: LONG sur bande inf√©rieure (oversold), SHORT sur bande sup√©rieure (overbought); stop-loss fixe bas√© sur Bollinger distance √ó bb_stop_factor (0.2-2.0); filtre ATR exclut march√©s plats; signaux 1/-1/0.

Am√©liorations V2 vs V1: Stop-loss bas√© Bollinger au lieu ATR; facteur stop param√©trable; stop fixe √† l'entr√©e (ne bouge pas).

Read-if: Configuration V2 sp√©cifique, param√®tres stop-loss Bollinger, ou logique mean-reversion Bollinger+ATR.

Skip-if: Vous utilisez V1 ou V3, ou autres strat√©gies.
"""
   
                                      

                                   ^
[1m.\strategies\bollinger_atr_v2.py[m[36m:[m18[36m:[m80[36m:[m [1m[31mE501[m line too long (125 > 79 characters)
"""
Module-ID: strategies.bollinger_atr_v2

Purpose: Strat√©gie mean-reversion Bollinger Bands + ATR avec stop-loss Bollinger param√©trable (V2).

Role in pipeline: trading strategy

Key components: BollingerATRStrategyV2, register_strategy("bollinger_atr_v2")

Inputs: DataFrame OHLCV, param√®tres (bb_period, bb_std, entry_z, atr_period, atr_percentile, bb_stop_factor, leverage)

Outputs: StrategyResult (signaux LONG/SHORT, prix, stop-loss Bollinger, m√©tadata)

Dependencies: pandas, numpy, utils.parameters, strategies.base

Conventions: LONG sur bande inf√©rieure (oversold), SHORT sur bande sup√©rieure (overbought); stop-loss fixe bas√© sur Bollinger distance √ó bb_stop_factor (0.2-2.0); filtre ATR exclut march√©s plats; signaux 1/-1/0.

Am√©liorations V2 vs V1: Stop-loss bas√© Bollinger au lieu ATR; facteur stop param√©trable; stop fixe √† l'entr√©e (ne bouge pas).

Read-if: Configuration V2 sp√©cifique, param√®tres stop-loss Bollinger, ou logique mean-reversion Bollinger+ATR.

Skip-if: Vous utilisez V1 ou V3, ou autres strat√©gies.
"""
   
                                      

                                   ^
[1m.\strategies\bollinger_atr_v2.py[m[36m:[m20[36m:[m80[36m:[m [1m[31mE501[m line too long (110 > 79 characters)
"""
Module-ID: strategies.bollinger_atr_v2

Purpose: Strat√©gie mean-reversion Bollinger Bands + ATR avec stop-loss Bollinger param√©trable (V2).

Role in pipeline: trading strategy

Key components: BollingerATRStrategyV2, register_strategy("bollinger_atr_v2")

Inputs: DataFrame OHLCV, param√®tres (bb_period, bb_std, entry_z, atr_period, atr_percentile, bb_stop_factor, leverage)

Outputs: StrategyResult (signaux LONG/SHORT, prix, stop-loss Bollinger, m√©tadata)

Dependencies: pandas, numpy, utils.parameters, strategies.base

Conventions: LONG sur bande inf√©rieure (oversold), SHORT sur bande sup√©rieure (overbought); stop-loss fixe bas√© sur Bollinger distance √ó bb_stop_factor (0.2-2.0); filtre ATR exclut march√©s plats; signaux 1/-1/0.

Am√©liorations V2 vs V1: Stop-loss bas√© Bollinger au lieu ATR; facteur stop param√©trable; stop fixe √† l'entr√©e (ne bouge pas).

Read-if: Configuration V2 sp√©cifique, param√®tres stop-loss Bollinger, ou logique mean-reversion Bollinger+ATR.

Skip-if: Vous utilisez V1 ou V3, ou autres strat√©gies.
"""
   
                                      

                                   ^
[1m.\strategies\bollinger_atr_v2.py[m[36m:[m54[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
    """
    Strat√©gie Bollinger Bands + ATR V2 (Mean Reversion + Stop Bollinger).

    Param√®tres:
        bb_period: P√©riode des Bandes de Bollinger (d√©faut: 20)
        bb_std: √âcarts-types pour les bandes (d√©faut: 2.0)
        entry_z: Seuil d'entr√©e en Z-score (d√©faut: 2.0)
        atr_period: P√©riode de l'ATR (d√©faut: 14)
        atr_percentile: Percentile ATR pour filtre volatilit√© (d√©faut: 30)
        bb_stop_factor: Facteur de stop-loss Bollinger (d√©faut: 0.5)
            - 0.2 = stop tr√®s proche des bandes (conservateur)
            - 0.5 = stop √† mi-distance (√©quilibr√©)
            - 2.0 = stop tr√®s √©loign√© (agressif)
        leverage: Levier de trading (d√©faut: 3)

    Stop-Loss:
        - LONG: stop = lower_band - bb_stop_factor √ó (middle_band - lower_band)
        - SHORT: stop = upper_band + bb_stop_factor √ó (upper_band - middle_band)

    Signaux:
        +1 (Long): close <= entry_lower ET ATR > seuil
        -1 (Short): close >= entry_upper ET ATR > seuil
        0: Sinon
    """
       
                                                                       ^
[1m.\strategies\bollinger_atr_v2.py[m[36m:[m127[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
                description="Facteur stop-loss Bollinger (0.2=proche, 2.0=loin)"
                                                                               ^
[1m.\strategies\bollinger_atr_v2.py[m[36m:[m175[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
        signals = pd.Series(0.0, index=df.index, dtype=np.float64, name="signals")
                                                                               ^
[1m.\strategies\bollinger_atr_v2.py[m[36m:[m289[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
        # Note: Dans un backtest r√©el, cela serait calcul√© via bb_stop_long/short
                                                                               ^
[1m.\strategies\bollinger_atr_v2.py[m[36m:[m319[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
        """
        Calcule le niveau de stop-loss bas√© sur les bandes de Bollinger.

        Logique V2 (param√©trable):
        - LONG: stop = lower_band - bb_stop_factor √ó (middle_band - lower_band)
                (facteur √ó distance entre middle et lower, EN DESSOUS de lower_band)
        - SHORT: stop = upper_band + bb_stop_factor √ó (upper_band - middle_band)
                (facteur √ó distance entre upper et middle, AU DESSUS de upper_band)

        Cette valeur est FIXE au moment de l'entr√©e (ne change pas avec les nouvelles bandes).

        Args:
            entry_price: Prix d'entr√©e
            atr_value: Valeur ATR (fallback uniquement)
            side: "long" ou "short"
            params: Param√®tres (contient bb_stop_factor)
            bb_middle: Bande de Bollinger m√©diane (au moment de l'entr√©e)
            bb_upper: Bande de Bollinger sup√©rieure (au moment de l'entr√©e)
            bb_lower: Bande de Bollinger inf√©rieure (au moment de l'entr√©e)

        Returns:
            Prix du stop-loss
        """
           
                                                                   ^
[1m.\strategies\bollinger_atr_v2.py[m[36m:[m320[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
        """
        Calcule le niveau de stop-loss bas√© sur les bandes de Bollinger.

        Logique V2 (param√©trable):
        - LONG: stop = lower_band - bb_stop_factor √ó (middle_band - lower_band)
                (facteur √ó distance entre middle et lower, EN DESSOUS de lower_band)
        - SHORT: stop = upper_band + bb_stop_factor √ó (upper_band - middle_band)
                (facteur √ó distance entre upper et middle, AU DESSUS de upper_band)

        Cette valeur est FIXE au moment de l'entr√©e (ne change pas avec les nouvelles bandes).

        Args:
            entry_price: Prix d'entr√©e
            atr_value: Valeur ATR (fallback uniquement)
            side: "long" ou "short"
            params: Param√®tres (contient bb_stop_factor)
            bb_middle: Bande de Bollinger m√©diane (au moment de l'entr√©e)
            bb_upper: Bande de Bollinger sup√©rieure (au moment de l'entr√©e)
            bb_lower: Bande de Bollinger inf√©rieure (au moment de l'entr√©e)

        Returns:
            Prix du stop-loss
        """
           
                                                                   ^
[1m.\strategies\bollinger_atr_v2.py[m[36m:[m321[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
        """
        Calcule le niveau de stop-loss bas√© sur les bandes de Bollinger.

        Logique V2 (param√©trable):
        - LONG: stop = lower_band - bb_stop_factor √ó (middle_band - lower_band)
                (facteur √ó distance entre middle et lower, EN DESSOUS de lower_band)
        - SHORT: stop = upper_band + bb_stop_factor √ó (upper_band - middle_band)
                (facteur √ó distance entre upper et middle, AU DESSUS de upper_band)

        Cette valeur est FIXE au moment de l'entr√©e (ne change pas avec les nouvelles bandes).

        Args:
            entry_price: Prix d'entr√©e
            atr_value: Valeur ATR (fallback uniquement)
            side: "long" ou "short"
            params: Param√®tres (contient bb_stop_factor)
            bb_middle: Bande de Bollinger m√©diane (au moment de l'entr√©e)
            bb_upper: Bande de Bollinger sup√©rieure (au moment de l'entr√©e)
            bb_lower: Bande de Bollinger inf√©rieure (au moment de l'entr√©e)

        Returns:
            Prix du stop-loss
        """
           
                                                                   ^
[1m.\strategies\bollinger_atr_v2.py[m[36m:[m323[36m:[m80[36m:[m [1m[31mE501[m line too long (94 > 79 characters)
        """
        Calcule le niveau de stop-loss bas√© sur les bandes de Bollinger.

        Logique V2 (param√©trable):
        - LONG: stop = lower_band - bb_stop_factor √ó (middle_band - lower_band)
                (facteur √ó distance entre middle et lower, EN DESSOUS de lower_band)
        - SHORT: stop = upper_band + bb_stop_factor √ó (upper_band - middle_band)
                (facteur √ó distance entre upper et middle, AU DESSUS de upper_band)

        Cette valeur est FIXE au moment de l'entr√©e (ne change pas avec les nouvelles bandes).

        Args:
            entry_price: Prix d'entr√©e
            atr_value: Valeur ATR (fallback uniquement)
            side: "long" ou "short"
            params: Param√®tres (contient bb_stop_factor)
            bb_middle: Bande de Bollinger m√©diane (au moment de l'entr√©e)
            bb_upper: Bande de Bollinger sup√©rieure (au moment de l'entr√©e)
            bb_lower: Bande de Bollinger inf√©rieure (au moment de l'entr√©e)

        Returns:
            Prix du stop-loss
        """
           
                                                                   ^
[1m.\strategies\bollinger_atr_v2.py[m[36m:[m340[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
        # Si les bandes de Bollinger sont fournies, utiliser la logique Bollinger
                                                                               ^
[1m.\strategies\bollinger_atr_v2.py[m[36m:[m341[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
        if bb_middle is not None and bb_upper is not None and bb_lower is not None:
                                                                               ^
[1m.\strategies\bollinger_atr_v2.py[m[36m:[m351[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
            # Fallback: logique ATR legacy (si les bandes ne sont pas disponibles)
                                                                               ^
[1m.\strategies\bollinger_atr_v3.py[m[36m:[m4[36m:[m80[36m:[m [1m[31mE501[m line too long (122 > 79 characters)
"""
Module-ID: strategies.bollinger_atr_v3

Purpose: Strat√©gie mean-reversion Bollinger+ATR avec entr√©es ET stop-loss VARIABLES sur √©chelle unifi√©e (V3 - Pure Logic).

Role in pipeline: trading strategy / analysis base

Key components: BollingerATRStrategyV3, register_strategy("bollinger_atr_v3")

Inputs: DataFrame OHLCV, param√®tres (bb_period, bb_std, entry_level_long, entry_level_short, atr_period, atr_percentile, stop_distance, leverage)

Outputs: StrategyResult (signaux LONG/SHORT variables, prix, stop-loss calcul√©s, metadata)

Dependencies: pandas, numpy, utils.parameters, strategies.base

Conventions: √âchelle unifi√©e 0%=lower, 50%=middle, 100%=upper; LONG variables -50% √† +20% (sous lower ‚Üí middle); SHORT variables +80% √† +150% (vers/au-dessus upper); stop-loss 0.1-1.0 √ó distance depuis entry_price; filtre ATR volatilit√©; BASE D'ANALYSE pour patterns pre-filtre.

V3 Innovations: Entr√©es/stop variables vs fixes V2; √©chelle unifi√©e exploratoire; base patterns avant filtrage.

Read-if: Analyse patterns Bollinger exploratoires, √©chelle unifi√©e, ou logique V3 entr√©es/stop variables.

Skip-if: Vous pr√©f√©rez V1/V2 fixes ou autres strat√©gies.
"""
   
                                      

                                   ^
[1m.\strategies\bollinger_atr_v3.py[m[36m:[m10[36m:[m80[36m:[m [1m[31mE501[m line too long (145 > 79 characters)
"""
Module-ID: strategies.bollinger_atr_v3

Purpose: Strat√©gie mean-reversion Bollinger+ATR avec entr√©es ET stop-loss VARIABLES sur √©chelle unifi√©e (V3 - Pure Logic).

Role in pipeline: trading strategy / analysis base

Key components: BollingerATRStrategyV3, register_strategy("bollinger_atr_v3")

Inputs: DataFrame OHLCV, param√®tres (bb_period, bb_std, entry_level_long, entry_level_short, atr_period, atr_percentile, stop_distance, leverage)

Outputs: StrategyResult (signaux LONG/SHORT variables, prix, stop-loss calcul√©s, metadata)

Dependencies: pandas, numpy, utils.parameters, strategies.base

Conventions: √âchelle unifi√©e 0%=lower, 50%=middle, 100%=upper; LONG variables -50% √† +20% (sous lower ‚Üí middle); SHORT variables +80% √† +150% (vers/au-dessus upper); stop-loss 0.1-1.0 √ó distance depuis entry_price; filtre ATR volatilit√©; BASE D'ANALYSE pour patterns pre-filtre.

V3 Innovations: Entr√©es/stop variables vs fixes V2; √©chelle unifi√©e exploratoire; base patterns avant filtrage.

Read-if: Analyse patterns Bollinger exploratoires, √©chelle unifi√©e, ou logique V3 entr√©es/stop variables.

Skip-if: Vous pr√©f√©rez V1/V2 fixes ou autres strat√©gies.
"""
   
                                      

                                   ^
[1m.\strategies\bollinger_atr_v3.py[m[36m:[m12[36m:[m80[36m:[m [1m[31mE501[m line too long (90 > 79 characters)
"""
Module-ID: strategies.bollinger_atr_v3

Purpose: Strat√©gie mean-reversion Bollinger+ATR avec entr√©es ET stop-loss VARIABLES sur √©chelle unifi√©e (V3 - Pure Logic).

Role in pipeline: trading strategy / analysis base

Key components: BollingerATRStrategyV3, register_strategy("bollinger_atr_v3")

Inputs: DataFrame OHLCV, param√®tres (bb_period, bb_std, entry_level_long, entry_level_short, atr_period, atr_percentile, stop_distance, leverage)

Outputs: StrategyResult (signaux LONG/SHORT variables, prix, stop-loss calcul√©s, metadata)

Dependencies: pandas, numpy, utils.parameters, strategies.base

Conventions: √âchelle unifi√©e 0%=lower, 50%=middle, 100%=upper; LONG variables -50% √† +20% (sous lower ‚Üí middle); SHORT variables +80% √† +150% (vers/au-dessus upper); stop-loss 0.1-1.0 √ó distance depuis entry_price; filtre ATR volatilit√©; BASE D'ANALYSE pour patterns pre-filtre.

V3 Innovations: Entr√©es/stop variables vs fixes V2; √©chelle unifi√©e exploratoire; base patterns avant filtrage.

Read-if: Analyse patterns Bollinger exploratoires, √©chelle unifi√©e, ou logique V3 entr√©es/stop variables.

Skip-if: Vous pr√©f√©rez V1/V2 fixes ou autres strat√©gies.
"""
   
                                      

                                   ^
[1m.\strategies\bollinger_atr_v3.py[m[36m:[m16[36m:[m80[36m:[m [1m[31mE501[m line too long (278 > 79 characters)
"""
Module-ID: strategies.bollinger_atr_v3

Purpose: Strat√©gie mean-reversion Bollinger+ATR avec entr√©es ET stop-loss VARIABLES sur √©chelle unifi√©e (V3 - Pure Logic).

Role in pipeline: trading strategy / analysis base

Key components: BollingerATRStrategyV3, register_strategy("bollinger_atr_v3")

Inputs: DataFrame OHLCV, param√®tres (bb_period, bb_std, entry_level_long, entry_level_short, atr_period, atr_percentile, stop_distance, leverage)

Outputs: StrategyResult (signaux LONG/SHORT variables, prix, stop-loss calcul√©s, metadata)

Dependencies: pandas, numpy, utils.parameters, strategies.base

Conventions: √âchelle unifi√©e 0%=lower, 50%=middle, 100%=upper; LONG variables -50% √† +20% (sous lower ‚Üí middle); SHORT variables +80% √† +150% (vers/au-dessus upper); stop-loss 0.1-1.0 √ó distance depuis entry_price; filtre ATR volatilit√©; BASE D'ANALYSE pour patterns pre-filtre.

V3 Innovations: Entr√©es/stop variables vs fixes V2; √©chelle unifi√©e exploratoire; base patterns avant filtrage.

Read-if: Analyse patterns Bollinger exploratoires, √©chelle unifi√©e, ou logique V3 entr√©es/stop variables.

Skip-if: Vous pr√©f√©rez V1/V2 fixes ou autres strat√©gies.
"""
   
                                      

                                   ^
[1m.\strategies\bollinger_atr_v3.py[m[36m:[m18[36m:[m80[36m:[m [1m[31mE501[m line too long (111 > 79 characters)
"""
Module-ID: strategies.bollinger_atr_v3

Purpose: Strat√©gie mean-reversion Bollinger+ATR avec entr√©es ET stop-loss VARIABLES sur √©chelle unifi√©e (V3 - Pure Logic).

Role in pipeline: trading strategy / analysis base

Key components: BollingerATRStrategyV3, register_strategy("bollinger_atr_v3")

Inputs: DataFrame OHLCV, param√®tres (bb_period, bb_std, entry_level_long, entry_level_short, atr_period, atr_percentile, stop_distance, leverage)

Outputs: StrategyResult (signaux LONG/SHORT variables, prix, stop-loss calcul√©s, metadata)

Dependencies: pandas, numpy, utils.parameters, strategies.base

Conventions: √âchelle unifi√©e 0%=lower, 50%=middle, 100%=upper; LONG variables -50% √† +20% (sous lower ‚Üí middle); SHORT variables +80% √† +150% (vers/au-dessus upper); stop-loss 0.1-1.0 √ó distance depuis entry_price; filtre ATR volatilit√©; BASE D'ANALYSE pour patterns pre-filtre.

V3 Innovations: Entr√©es/stop variables vs fixes V2; √©chelle unifi√©e exploratoire; base patterns avant filtrage.

Read-if: Analyse patterns Bollinger exploratoires, √©chelle unifi√©e, ou logique V3 entr√©es/stop variables.

Skip-if: Vous pr√©f√©rez V1/V2 fixes ou autres strat√©gies.
"""
   
                                      

                                   ^
[1m.\strategies\bollinger_atr_v3.py[m[36m:[m20[36m:[m80[36m:[m [1m[31mE501[m line too long (105 > 79 characters)
"""
Module-ID: strategies.bollinger_atr_v3

Purpose: Strat√©gie mean-reversion Bollinger+ATR avec entr√©es ET stop-loss VARIABLES sur √©chelle unifi√©e (V3 - Pure Logic).

Role in pipeline: trading strategy / analysis base

Key components: BollingerATRStrategyV3, register_strategy("bollinger_atr_v3")

Inputs: DataFrame OHLCV, param√®tres (bb_period, bb_std, entry_level_long, entry_level_short, atr_period, atr_percentile, stop_distance, leverage)

Outputs: StrategyResult (signaux LONG/SHORT variables, prix, stop-loss calcul√©s, metadata)

Dependencies: pandas, numpy, utils.parameters, strategies.base

Conventions: √âchelle unifi√©e 0%=lower, 50%=middle, 100%=upper; LONG variables -50% √† +20% (sous lower ‚Üí middle); SHORT variables +80% √† +150% (vers/au-dessus upper); stop-loss 0.1-1.0 √ó distance depuis entry_price; filtre ATR volatilit√©; BASE D'ANALYSE pour patterns pre-filtre.

V3 Innovations: Entr√©es/stop variables vs fixes V2; √©chelle unifi√©e exploratoire; base patterns avant filtrage.

Read-if: Analyse patterns Bollinger exploratoires, √©chelle unifi√©e, ou logique V3 entr√©es/stop variables.

Skip-if: Vous pr√©f√©rez V1/V2 fixes ou autres strat√©gies.
"""
   
                                      

                                   ^
[1m.\strategies\bollinger_atr_v3.py[m[36m:[m220[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
        signals = pd.Series(0.0, index=df.index, dtype=np.float64, name="signals")
                                                                               ^
[1m.\strategies\bollinger_atr_v3.py[m[36m:[m394[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
        if bb_middle is not None and bb_upper is not None and bb_lower is not None:
                                                                               ^
[1m.\strategies\ema_cross.py[m[36m:[m4[36m:[m80[36m:[m [1m[31mE501[m line too long (89 > 79 characters)
"""
Module-ID: strategies.ema_cross

Purpose: Strat√©gie de suivi de tendance par croisement de deux EMAs (Golden/Death Cross).

Role in pipeline: core

Key components: EMACrossStrategy, fast_period, slow_period, leverage

Inputs: DataFrame OHLCV avec colonnes close, optionnel volume

Outputs: StrategyResult (signaux 1/-1/0 sur croisements EMA)

Dependencies: strategies.base, utils.parameters, pandas, numpy

Conventions: fast_period < slow_period obligatoire; EMA calcul√©es internement; leverage appliqu√© apr√®s signaux.

Read-if: Modification logique croisement, seuils entr√©e, ou preset.

Skip-if: Vous ne changez que d'autres strat√©gies.
"""
   
                               

                                          ^
[1m.\strategies\ema_cross.py[m[36m:[m16[36m:[m80[36m:[m [1m[31mE501[m line too long (111 > 79 characters)
"""
Module-ID: strategies.ema_cross

Purpose: Strat√©gie de suivi de tendance par croisement de deux EMAs (Golden/Death Cross).

Role in pipeline: core

Key components: EMACrossStrategy, fast_period, slow_period, leverage

Inputs: DataFrame OHLCV avec colonnes close, optionnel volume

Outputs: StrategyResult (signaux 1/-1/0 sur croisements EMA)

Dependencies: strategies.base, utils.parameters, pandas, numpy

Conventions: fast_period < slow_period obligatoire; EMA calcul√©es internement; leverage appliqu√© apr√®s signaux.

Read-if: Modification logique croisement, seuils entr√©e, ou preset.

Skip-if: Vous ne changez que d'autres strat√©gies.
"""
   
                               

                                          ^
[1m.\strategies\ema_cross.py[m[36m:[m121[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
        signals = pd.Series(0.0, index=df.index, dtype=np.float64, name="signals")
                                                                               ^
[1m.\strategies\ema_cross.py[m[36m:[m128[36m:[m80[36m:[m [1m[31mE501[m line too long (91 > 79 characters)
        ema_fast = close.ewm(span=fast_period, adjust=True, min_periods=fast_period).mean()
                                                                               ^
[1m.\strategies\ema_cross.py[m[36m:[m129[36m:[m80[36m:[m [1m[31mE501[m line too long (91 > 79 characters)
        ema_slow = close.ewm(span=slow_period, adjust=True, min_periods=slow_period).mean()
                                                                               ^
[1m.\strategies\fvg_strategy.py[m[36m:[m4[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
"""
Module-ID: strategies.fvg_strategy

Purpose: Strategie FairValOseille - Trading base sur FVG, FVA, swings et smart legs.

Role in pipeline: trading strategy

Key components: FVGStrategy, register_strategy("fvg_strategy")

Inputs: DataFrame OHLCV, parametres (leverage, scoring)

Outputs: StrategyResult (signaux LONG/SHORT, prix, stop-loss, metadata)

Dependencies: pandas, numpy, utils.parameters, strategies.base

Conventions: Signaux bases sur consensus patterns; stop-loss dynamiques; scoring multi-indicateurs.
"""
   
                                  

                                       ^
[1m.\strategies\fvg_strategy.py[m[36m:[m16[36m:[m80[36m:[m [1m[31mE501[m line too long (99 > 79 characters)
"""
Module-ID: strategies.fvg_strategy

Purpose: Strategie FairValOseille - Trading base sur FVG, FVA, swings et smart legs.

Role in pipeline: trading strategy

Key components: FVGStrategy, register_strategy("fvg_strategy")

Inputs: DataFrame OHLCV, parametres (leverage, scoring)

Outputs: StrategyResult (signaux LONG/SHORT, prix, stop-loss, metadata)

Dependencies: pandas, numpy, utils.parameters, strategies.base

Conventions: Signaux bases sur consensus patterns; stop-loss dynamiques; scoring multi-indicateurs.
"""
   
                                  

                                       ^
[1m.\strategies\fvg_strategy.py[m[36m:[m139[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
        signals = pd.Series(0.0, index=df.index, dtype=np.float64, name="signals")
                                                                               ^
[1m.\strategies\fvg_strategy.py[m[36m:[m173[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
        # Score bull suffisant ET presence d'un pattern (swing_low OU fvg_bullish)
                                                                               ^
[1m.\strategies\fvg_strategy.py[m[36m:[m180[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
        # Score bear suffisant ET presence d'un pattern (swing_high OU fvg_bearish)
                                                                               ^
[1m.\strategies\indicators_mapping.py[m[36m:[m4[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
"""
Module-ID: strategies.indicators_mapping

Purpose: Mapping centralis√© strat√©gies ‚Üí indicateurs pour chargement automatique UI.

Role in pipeline: core / data

Key components: StrategyIndicatorsMapping, get_strategy_indicators, IndicatorRequirement

Inputs: Strategy name, configuration

Outputs: Dict[str, List[IndicatorRequirement]] (required + internal + all)

Dependencies: strategies.base, indicators.registry, dataclasses

Conventions: required_indicators charg√©s par moteur; internal_indicators calcul√©s par strat; all_indicators = union compl√®te.

Read-if: Ajout nouvelle strat√©gie/indicateur, modification deps.

Skip-if: Vous ne changez qu'une strat√©gie.
"""
   
                                        

                                 ^
[1m.\strategies\indicators_mapping.py[m[36m:[m8[36m:[m80[36m:[m [1m[31mE501[m line too long (88 > 79 characters)
"""
Module-ID: strategies.indicators_mapping

Purpose: Mapping centralis√© strat√©gies ‚Üí indicateurs pour chargement automatique UI.

Role in pipeline: core / data

Key components: StrategyIndicatorsMapping, get_strategy_indicators, IndicatorRequirement

Inputs: Strategy name, configuration

Outputs: Dict[str, List[IndicatorRequirement]] (required + internal + all)

Dependencies: strategies.base, indicators.registry, dataclasses

Conventions: required_indicators charg√©s par moteur; internal_indicators calcul√©s par strat; all_indicators = union compl√®te.

Read-if: Ajout nouvelle strat√©gie/indicateur, modification deps.

Skip-if: Vous ne changez qu'une strat√©gie.
"""
   
                                        

                                 ^
[1m.\strategies\indicators_mapping.py[m[36m:[m16[36m:[m80[36m:[m [1m[31mE501[m line too long (125 > 79 characters)
"""
Module-ID: strategies.indicators_mapping

Purpose: Mapping centralis√© strat√©gies ‚Üí indicateurs pour chargement automatique UI.

Role in pipeline: core / data

Key components: StrategyIndicatorsMapping, get_strategy_indicators, IndicatorRequirement

Inputs: Strategy name, configuration

Outputs: Dict[str, List[IndicatorRequirement]] (required + internal + all)

Dependencies: strategies.base, indicators.registry, dataclasses

Conventions: required_indicators charg√©s par moteur; internal_indicators calcul√©s par strat; all_indicators = union compl√®te.

Read-if: Ajout nouvelle strat√©gie/indicateur, modification deps.

Skip-if: Vous ne changez qu'une strat√©gie.
"""
   
                                        

                                 ^
[1m.\strategies\indicators_mapping.py[m[36m:[m98[36m:[m80[36m:[m [1m[31mE501[m line too long (111 > 79 characters)
        description="Mean-reversion Bollinger avec stop-loss Bollinger param√©trable (bb_stop_factor: 0.2-2.0)",
                                                                               ^
[1m.\strategies\indicators_mapping.py[m[36m:[m108[36m:[m80[36m:[m [1m[31mE501[m line too long (144 > 79 characters)
        description="Mean-reversion Bollinger avec entr√©es variables (-50% √† +150%), stop/TP depuis entry_price, amplitude BB testable (1œÉ-4œÉ)",
                                                                               ^
[1m.\strategies\macd_cross.py[m[36m:[m16[36m:[m80[36m:[m [1m[31mE501[m line too long (98 > 79 characters)
"""
Module-ID: strategies.macd_cross

Purpose: Strat√©gie momentum bas√©e sur croisement de MACD et signal line.

Role in pipeline: core

Key components: MACDCrossStrategy, fast_period, slow_period, signal_period

Inputs: DataFrame OHLCV avec colonne close

Outputs: StrategyResult (signaux 1/-1/0 sur croisements MACD/signal)

Dependencies: strategies.base, indicators.macd, utils.parameters, pandas, numpy

Conventions: fast < slow < signal obligatoires; histogram comme filtre optionnel; momentum valid√©.

Read-if: Modification logique croisement MACD, seuils, ou signal.

Skip-if: Vous ne changez que d'autres strat√©gies.
"""
   
                                

                                         ^
[1m.\strategies\macd_cross.py[m[36m:[m100[36m:[m18[36m:[m [1m[31mE131[m continuation line unaligned for hanging indent
                 description="Levier de trading",
                 ^
[1m.\strategies\macd_cross.py[m[36m:[m101[36m:[m18[36m:[m [1m[31mE131[m continuation line unaligned for hanging indent
                 optimize=False,
                 ^
[1m.\strategies\rsi_reversal.py[m[36m:[m8[36m:[m80[36m:[m [1m[31mE501[m line too long (89 > 79 characters)
"""
Module-ID: strategies.rsi_reversal

Purpose: Strat√©gie mean-reversion bas√©e sur seuils sur√©dapte/survente RSI.

Role in pipeline: core

Key components: RSIReversalStrategy, rsi_period, overbought_threshold, oversold_threshold

Inputs: DataFrame OHLCV avec colonne close

Outputs: StrategyResult (signaux 1/-1/0 sur seuils RSI)

Dependencies: strategies.base, indicators.rsi, utils.parameters, pandas, numpy

Conventions: oversold < 50 < overbought; RSI p√©riode standard 14; signaux confirm√©s.

Read-if: Modification seuils RSI, p√©riode, ou logique renversement.

Skip-if: Vous ne changez que d'autres strat√©gies.
"""
   
                                  

                                       ^
[1m.\strategies\rsi_reversal.py[m[36m:[m16[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
"""
Module-ID: strategies.rsi_reversal

Purpose: Strat√©gie mean-reversion bas√©e sur seuils sur√©dapte/survente RSI.

Role in pipeline: core

Key components: RSIReversalStrategy, rsi_period, overbought_threshold, oversold_threshold

Inputs: DataFrame OHLCV avec colonne close

Outputs: StrategyResult (signaux 1/-1/0 sur seuils RSI)

Dependencies: strategies.base, indicators.rsi, utils.parameters, pandas, numpy

Conventions: oversold < 50 < overbought; RSI p√©riode standard 14; signaux confirm√©s.

Read-if: Modification seuils RSI, p√©riode, ou logique renversement.

Skip-if: Vous ne changez que d'autres strat√©gies.
"""
   
                                  

                                       ^
[1m.\test_all_strategies.py[m[36m:[m12[36m:[m1[36m:[m [1m[31mE402[m module level import not at top of file
import pandas as pd
^
[1m.\test_all_strategies.py[m[36m:[m14[36m:[m1[36m:[m [1m[31mE402[m module level import not at top of file
from backtest.engine import BacktestEngine
^
[1m.\test_all_strategies.py[m[36m:[m15[36m:[m1[36m:[m [1m[31mE402[m module level import not at top of file
from strategies import list_strategies
^
[1m.\test_all_strategies.py[m[36m:[m20[36m:[m80[36m:[m [1m[31mE501[m line too long (91 > 79 characters)
    sample_file = Path(__file__).parent / "data" / "sample_data" / "BTCUSDT_1h_6months.csv"
                                                                               ^
[1m.\test_all_strategies.py[m[36m:[m28[36m:[m1[36m:[m [1m[31mE303[m too many blank lines (3)
def run_simple_backtest(strategy_name, df, params=None):
^
[1m.\test_all_strategies.py[m[36m:[m76[36m:[m1[36m:[m [1m[31mE303[m too many blank lines (3)
def main():
^
[1m.\test_all_strategies.py[m[36m:[m123[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
                pnl = result.metrics.get('total_pnl', result.metrics.get('pnl', 0))
                                                                               ^
[1m.\test_all_strategies.py[m[36m:[m150[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
        sorted_results = sorted(all_results, key=lambda x: x["pnl"], reverse=True)
                                                                               ^
[1m.\test_all_strategies.py[m[36m:[m152[36m:[m80[36m:[m [1m[31mE501[m line too long (106 > 79 characters)
        print(f"{'Strat√©gie':<20} {'Params':<30} {'PnL':>12} {'Return%':>10} {'Sharpe':>8} {'Trades':>8}")
                                                                               ^
[1m.\test_all_strategies.py[m[36m:[m156[36m:[m80[36m:[m [1m[31mE501[m line too long (105 > 79 characters)
            params_str = str(r["params"])[:28] + ".." if len(str(r["params"])) > 30 else str(r["params"])
                                                                               ^
[1m.\test_all_strategies.py[m[36m:[m157[36m:[m80[36m:[m [1m[31mE501[m line too long (140 > 79 characters)
            print(f"{r['strategy']:<20} {params_str:<30} ${r['pnl']:>10,.2f} {r['return_pct']:>9.2f}% {r['sharpe']:>7.2f} {r['trades']:>8}")
                                                                               ^
[1m.\test_all_strategies.py[m[36m:[m162[36m:[m80[36m:[m [1m[31mE501[m line too long (123 > 79 characters)
        print(f"‚úÖ Configs profitables: {len(profitable)}/{len(all_results)} ({len(profitable)/len(all_results)*100:.1f}%)")
                                                                               ^
[1m.\test_all_strategies.py[m[36m:[m185[36m:[m1[36m:[m [1m[31mE303[m too many blank lines (3)
if __name__ == "__main__":
^
[1m.\tests\__init__.py[m[36m:[m4[36m:[m80[36m:[m [1m[31mE501[m line too long (114 > 79 characters)
"""
Module-ID: backtest_core

Purpose: Package racine - orchestration globale du moteur de backtest (engine, strategies, indicators, utils, ui).

Role in pipeline: package initialization

Key components: Version, imports, package structure

Inputs: Modules enfants (agents, backtest, cli, data, indicators, strategies, ui, utils)

Outputs: Namespace unifi√© backtest_core

Dependencies: Python 3.9+, librairies externes (numpy, pandas, streamlit, etc.)

Conventions: Package structure; version s√©mantique

Read-if: Modification structure package ou version.

Skip-if: Vous modifiez juste les strat√©gies ou indicateurs.
"""
   
                        

                                                 ^
[1m.\tests\__init__.py[m[36m:[m10[36m:[m80[36m:[m [1m[31mE501[m line too long (88 > 79 characters)
"""
Module-ID: backtest_core

Purpose: Package racine - orchestration globale du moteur de backtest (engine, strategies, indicators, utils, ui).

Role in pipeline: package initialization

Key components: Version, imports, package structure

Inputs: Modules enfants (agents, backtest, cli, data, indicators, strategies, ui, utils)

Outputs: Namespace unifi√© backtest_core

Dependencies: Python 3.9+, librairies externes (numpy, pandas, streamlit, etc.)

Conventions: Package structure; version s√©mantique

Read-if: Modification structure package ou version.

Skip-if: Vous modifiez juste les strat√©gies ou indicateurs.
"""
   
                        

                                                 ^
[1m.\tests\__main__.py[m[36m:[m4[36m:[m80[36m:[m [1m[31mE501[m line too long (124 > 79 characters)
"""
Module-ID: __main__

Purpose: Point d'entr√©e CLI du moteur de backtest - dispatcher de commandes (list, info, backtest, sweep, validate, export).

Role in pipeline: entry point

Key components: _run(), dispatch, CLI parser

Inputs: Arguments sys.argv (--strategy, --data, --params, etc.)

Outputs: Ex√©cution commandes, messages stdout

Dependencies: sys, pathlib, cli.commands

Conventions: Commandes via `python -m backtest_core [CMD]`

Read-if: Modification entry point ou ajout nouvelles commandes CLI.

Skip-if: D√©veloppement strat√©gies ou indicateurs (pas besoin CLI).
"""
   
                   

                                                      ^
[1m.\tests\analyze_all_data.py[m[36m:[m5[36m:[m80[36m:[m [1m[31mE501[m line too long (105 > 79 characters)
"""
Module-ID: analyze_all_data

Purpose: Analyser tous fichiers OHLCV parquet d'un dossier - d√©terminer p√©riode backtest commune globale.

Role in pipeline: data quality assurance

Key components: analyze_all_parquet_files(), r√©sum√© global par timeframe

Inputs: Dossier avec fichiers SYMBOL_TIMEFRAME.parquet

Outputs: Coverage par token/timeframe, p√©riode globale min/max, rapport erreurs

Dependencies: pandas, pathlib, collections

Conventions: Fichiers nomm√©s SYMBOL_TIMEFRAME.parquet; r√©sum√© par timeframe

Read-if: Planifier backtest multi-token, v√©rifier couverture commune.

Skip-if: Token unique ou donn√©es pr√©-analys√©es.
"""
   
                           

                                              ^
[1m.\tests\analyze_all_data.py[m[36m:[m42[36m:[m80[36m:[m [1m[31mE501[m line too long (100 > 79 characters)
    tokens_data = defaultdict(lambda: defaultdict(dict))  # token -> timeframe -> {start, end, bars}
                                                                               ^
[1m.\tests\analyze_all_data.py[m[36m:[m67[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
                    df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms')
                                                                               ^
[1m.\tests\analyze_all_data.py[m[36m:[m129[36m:[m80[36m:[m [1m[31mE501[m line too long (85 > 79 characters)
        print(f"   Dur√©e: {duration.days} jours ({duration.days/365.25:.1f} ann√©es)")
                                                                               ^
[1m.\tests\analyze_all_data.py[m[36m:[m141[36m:[m80[36m:[m [1m[31mE501[m line too long (103 > 79 characters)
                print(f"   {tf:4s}: {common_start.date()} ‚Üí {common_end.date()} ({common_days} jours)")
                                                                               ^
[1m.\tests\analyze_all_data.py[m[36m:[m148[36m:[m80[36m:[m [1m[31mE501[m line too long (90 > 79 characters)
    token_counts = [(token, len(timeframes)) for token, timeframes in tokens_data.items()]
                                                                               ^
[1m.\tests\analyze_all_data.py[m[36m:[m153[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
        print(f"{i:2d}. {token:20s} ({count} timeframes): {', '.join(timeframes)}")
                                                                               ^
[1m.\tests\analyze_all_data.py[m[36m:[m159[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
    print(f"   Timeframes          : {', '.join(sorted(timeframe_ranges.keys()))}")
                                                                               ^
[1m.\tests\analyze_cprofile_stats.py[m[36m:[m9[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
def _load_entries(stats: pstats.Stats, filter_text: str) -> List[Dict[str, object]]:
                                                                               ^
[1m.\tests\analyze_cprofile_stats.py[m[36m:[m11[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
    for (filename, lineno, func), (cc, nc, tt, ct, callers) in stats.stats.items():
                                                                               ^
[1m.\tests\analyze_cprofile_stats.py[m[36m:[m45[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
def _format_rows(rows: List[Dict[str, object]], top_n: int, sort_by: str) -> str:
                                                                               ^
[1m.\tests\analyze_cprofile_stats.py[m[36m:[m54[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
        location = f"{row['func']} ({Path(str(row['file'])).name}:{row['line']})"
                                                                               ^
[1m.\tests\analyze_cprofile_stats.py[m[36m:[m90[36m:[m80[36m:[m [1m[31mE501[m line too long (87 > 79 characters)
    parser.add_argument("--sort", choices=["cumulative", "time"], default="cumulative")
                                                                               ^
[1m.\tests\analyze_data.py[m[36m:[m5[36m:[m80[36m:[m [1m[31mE501[m line too long (94 > 79 characters)
"""
Module-ID: analyze_data

Purpose: Analyser d√©tail fichier OHLCV unique - dates, continuit√©, gaps, compl√©tude de barres.

Role in pipeline: data quality assurance

Key components: analyze_parquet_file(), affichage stats

Inputs: Chemin fichier parquet OHLCV

Outputs: Statistiques: nombre barres, plage dates, gaps, continuit√©, colonnes

Dependencies: pandas, pathlib, collections

Conventions: Index pandas.DatetimeIndex; colonnes [open, high, low, close, volume]

Read-if: V√©rifier qualit√©/couverture fichier avant backtest.

Skip-if: Donn√©es pr√©-valid√©es.
"""
   
                       

                                                  ^
[1m.\tests\analyze_data.py[m[36m:[m17[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
"""
Module-ID: analyze_data

Purpose: Analyser d√©tail fichier OHLCV unique - dates, continuit√©, gaps, compl√©tude de barres.

Role in pipeline: data quality assurance

Key components: analyze_parquet_file(), affichage stats

Inputs: Chemin fichier parquet OHLCV

Outputs: Statistiques: nombre barres, plage dates, gaps, continuit√©, colonnes

Dependencies: pandas, pathlib, collections

Conventions: Index pandas.DatetimeIndex; colonnes [open, high, low, close, volume]

Read-if: V√©rifier qualit√©/couverture fichier avant backtest.

Skip-if: Donn√©es pr√©-valid√©es.
"""
   
                       

                                                  ^
[1m.\tests\analyze_data.py[m[36m:[m44[36m:[m80[36m:[m [1m[31mE501[m line too long (94 > 79 characters)
        print(f"   Taille m√©moire         : {df.memory_usage(deep=True).sum() / 1024:.1f} KB")
                                                                               ^
[1m.\tests\analyze_data.py[m[36m:[m52[36m:[m80[36m:[m [1m[31mE501[m line too long (103 > 79 characters)
            sample_ts = float(df['timestamp'].iloc[0])  # Convertir en float pour √©viter probl√®me numpy
                                                                               ^
[1m.\tests\analyze_data.py[m[36m:[m76[36m:[m80[36m:[m [1m[31mE501[m line too long (89 > 79 characters)
        print(f"   Dur√©e  : {duration.days} jours ({duration.days / 365.25:.1f} ann√©es)")
                                                                               ^
[1m.\tests\analyze_data.py[m[36m:[m92[36m:[m80[36m:[m [1m[31mE501[m line too long (110 > 79 characters)
        gaps = time_diffs[(time_diffs > expected_diff + tolerance) | (time_diffs < expected_diff - tolerance)]
                                                                               ^
[1m.\tests\analyze_data.py[m[36m:[m112[36m:[m80[36m:[m [1m[31mE501[m line too long (92 > 79 characters)
                    f"   {col.upper():8s}: min={values.min():.2f}  max={values.max():.2f}  "
                                                                               ^
[1m.\tests\analyze_data.py[m[36m:[m143[36m:[m80[36m:[m [1m[31mE501[m line too long (104 > 79 characters)
                print(f"   ‚ö†Ô∏è  Barres incoh√©rentes: high={invalid_high.sum()}, low={invalid_low.sum()}")
                                                                               ^
[1m.\tests\analyze_data.py[m[36m:[m150[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
        print(f"‚úÖ P√©riode couverte    : {start_date.date()} ‚Üí {end_date.date()}")
                                                                               ^
[1m.\tests\analyze_data.py[m[36m:[m151[36m:[m80[36m:[m [1m[31mE501[m line too long (123 > 79 characters)
        print(f"{'‚úÖ' if len(gaps) == 0 else '‚ö†Ô∏è '} Continuit√©         : {'OK' if len(gaps) == 0 else f'{len(gaps)} gaps'}")
                                                                               ^
[1m.\tests\analyze_data.py[m[36m:[m152[36m:[m80[36m:[m [1m[31mE501[m line too long (135 > 79 characters)
        print(f"{'‚úÖ' if null_counts.sum() == 0 else '‚ö†Ô∏è '} Valeurs manquantes : {'Aucune' if null_counts.sum() == 0 else 'Pr√©sentes'}")
                                                                               ^
[1m.\tests\benchmark_perf.py[m[36m:[m4[36m:[m80[36m:[m [1m[31mE501[m line too long (94 > 79 characters)
"""
Module-ID: benchmark_perf

Purpose: Benchmark BacktestEngine - mesurer runs/sec avec indicateurs et signaux synth√©tiques.

Role in pipeline: performance testing

Key components: engine.run(), g√©n√©ration donn√©es synth√©tiques, timing

Inputs: 1000 barres synth√©tiques, grille de 3 param√®tres

Outputs: Temps d'ex√©cution, runs/sec

Dependencies: numpy, pandas, time, backtest.engine

Conventions: Donn√©es synth√©tiques np.random; seed=42

Read-if: Mesurer baseline perf engine ou impact modifications.

Skip-if: Perf d√©j√† mesur√©e.
"""
   
                         

                                                ^
[1m.\tests\benchmark_sharpe.py[m[36m:[m4[36m:[m80[36m:[m [1m[31mE501[m line too long (109 > 79 characters)
"""
Module-ID: benchmark_sharpe

Purpose: Benchmark fonction sharpe_ratio() - mesurer performance apr√®s d√©sactivation logging (N=1000 appels).

Role in pipeline: performance testing

Key components: generate_returns(), generate_equity(), timing

Inputs: N_CALLS iterations (sharpe_ratio sur s√©ries synth√©tiques)

Outputs: Temps d'ex√©cution total, calls/sec

Dependencies: numpy, pandas, time, backtest.performance

Conventions: Returns synth√©tiques np.random.randn(); seed=42

Read-if: V√©rifier perf sharpe_ratio() ou impact logging.

Skip-if: Perf d√©j√† mesur√©e.
"""
   
                           

                                              ^
[1m.\tests\benchmark_sharpe.py[m[36m:[m97[36m:[m80[36m:[m [1m[31mE501[m line too long (93 > 79 characters)
    print(f"\n‚úÖ Excellent: {calls_per_sec2:.0f} appels/sec - Logging d√©sactiv√© efficacement")
                                                                               ^
[1m.\tests\benchmark_sharpe.py[m[36m:[m101[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
    print(f"\n‚ö†Ô∏è Moyen: {calls_per_sec2:.0f} appels/sec - Encore de l'overhead")
                                                                               ^
[1m.\tests\check_gpu.py[m[36m:[m68[36m:[m80[36m:[m [1m[31mE501[m line too long (89 > 79 characters)
            if 'cupy' in source.lower() or 'cp.' in source or 'device_backend' in source:
                                                                               ^
[1m.\tests\check_gpu.py[m[36m:[m93[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
        has_cupy = 'cupy' in source.lower() or 'device_backend' in source.lower()
                                                                               ^
[1m.\tests\check_gpu.py[m[36m:[m132[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
        issues.append("‚ùå CuPy non fonctionnel (installer via requirements-gpu.txt)")
                                                                               ^
[1m.\tests\check_gpu.py[m[36m:[m160[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
            print("   2. Modifier les indicateurs pour utiliser device_backend")
                                                                               ^
[1m.\tests\check_saved_runs.py[m[36m:[m9[36m:[m1[36m:[m [1m[31mE402[m module level import not at top of file
from backtest.storage import ResultStorage
^
[1m.\tests\check_saved_runs.py[m[36m:[m11[36m:[m1[36m:[m [1m[31mE302[m expected 2 blank lines, found 1
def main():
^
[1m.\tests\check_saved_runs.py[m[36m:[m51[36m:[m1[36m:[m [1m[31mE305[m expected 2 blank lines after class or function definition, found 1
if __name__ == "__main__":
^
[1m.\tests\configure_ollama_multigpu.py[m[36m:[m32[36m:[m80[36m:[m [1m[31mE501[m line too long (106 > 79 characters)
            ["nvidia-smi", "--query-gpu=index,name,memory.total,memory.used,memory.free", "--format=csv"],
                                                                               ^
[1m.\tests\configure_ollama_multigpu.py[m[36m:[m60[36m:[m80[36m:[m [1m[31mE501[m line too long (98 > 79 characters)
def create_modelfile_multigpu(model_base: str = "llama3.3:70b-instruct-q4_K_M", num_gpu: int = 2):
                                                                               ^
[1m.\tests\configure_ollama_multigpu.py[m[36m:[m86[36m:[m80[36m:[m [1m[31mE501[m line too long (122 > 79 characters)
    modelfile_content = f'''FROM {model_base}

# Configuration multi-GPU
PARAMETER num_gpu {num_gpu}

# Optimisations m√©moire
PARAMETER num_thread 8
PARAMETER num_ctx 8192

# Temp√©rature et sampling
PARAMETER temperature 0.7
PARAMETER top_p 0.9
PARAMETER top_k 40

# R√©p√©tition
PARAMETER repeat_penalty 1.1

# System prompt optimis√© pour analyse financi√®re
SYSTEM You are an expert financial analyst and trading strategist. Analyze data precisely and provide actionable insights.
'''
                                             

                         
      ^
[1m.\tests\configure_ollama_multigpu.py[m[36m:[m99[36m:[m80[36m:[m [1m[31mE501[m line too long (96 > 79 characters)
def build_model_from_modelfile(modelfile_path: Path, model_name: str = "llama3.3-70b-multigpu"):
                                                                               ^
[1m.\tests\configure_ollama_multigpu.py[m[36m:[m111[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
        result = subprocess.run(cmd, capture_output=True, text=True, check=True)
                                                                               ^
[1m.\tests\configure_ollama_multigpu.py[m[36m:[m125[36m:[m80[36m:[m [1m[31mE501[m line too long (113 > 79 characters)
def monitor_gpu_during_inference(model_name: str, prompt: str = "Explain what is a moving average in 50 words."):
                                                                               ^
[1m.\tests\configure_ollama_multigpu.py[m[36m:[m149[36m:[m80[36m:[m [1m[31mE501[m line too long (130 > 79 characters)
                    ["nvidia-smi", "--query-gpu=index,utilization.gpu,memory.used,memory.total", "--format=csv,noheader,nounits"],
                                                                               ^
[1m.\tests\configure_ollama_multigpu.py[m[36m:[m162[36m:[m80[36m:[m [1m[31mE501[m line too long (97 > 79 characters)
                        print(f"  GPU {gpu_id}: {util}% usage | VRAM: {mem_used}/{mem_total} MB")
                                                                               ^
[1m.\tests\configure_ollama_multigpu.py[m[36m:[m180[36m:[m80[36m:[m [1m[31mE501[m line too long (92 > 79 characters)
        result = subprocess.run(cmd, capture_output=True, text=True, check=True, timeout=60)
                                                                               ^
[1m.\tests\configure_ollama_multigpu.py[m[36m:[m229[36m:[m80[36m:[m [1m[31mE501[m line too long (96 > 79 characters)
    print("\nüí° Pour rendre permanent, ajoutez ces lignes √† ~/.bashrc ou au script de lancement")
                                                                               ^
[1m.\tests\configure_ollama_multigpu.py[m[36m:[m237[36m:[m80[36m:[m [1m[31mE501[m line too long (101 > 79 characters)
    parser.add_argument("--test", action="store_true", help="Tester l'inf√©rence apr√®s configuration")
                                                                               ^
[1m.\tests\configure_ollama_multigpu.py[m[36m:[m238[36m:[m80[36m:[m [1m[31mE501[m line too long (103 > 79 characters)
    parser.add_argument("--num-gpu", type=int, default=2, help="Nombre de GPUs √† utiliser (d√©faut: 2)")
                                                                               ^
[1m.\tests\configure_ollama_multigpu.py[m[36m:[m239[36m:[m80[36m:[m [1m[31mE501[m line too long (119 > 79 characters)
    parser.add_argument("--model-base", type=str, default="llama3.3:70b-instruct-q4_K_M", help="Mod√®le de base Ollama")
                                                                               ^
[1m.\tests\configure_ollama_multigpu.py[m[36m:[m292[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
    print("\nüí° Utilisez ce mod√®le dans vos backtests en modifiant model_config.py:")
                                                                               ^
[1m.\tests\debug_sharpe_calculation.py[m[36m:[m3[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
"""
Debug d√©taill√© du calcul du Sharpe Ratio.
Affiche chaque √©tape du calcul pour comprendre pourquoi on obtient toujours 1.18.
"""
   
                                         
                                 ^
[1m.\tests\debug_sharpe_calculation.py[m[36m:[m17[36m:[m80[36m:[m [1m[31mE501[m line too long (90 > 79 characters)
df = pd.read_csv('data/sample_data/BTCUSDT_1h_6months.csv', index_col=0, parse_dates=True)
                                                                               ^
[1m.\tests\debug_sharpe_calculation.py[m[36m:[m18[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
print(f"üìä Donn√©es: {len(df)} barres, {(df.index[-1] - df.index[0]).days} jours")
                                                                               ^
[1m.\tests\debug_sharpe_calculation.py[m[36m:[m23[36m:[m80[36m:[m [1m[31mE501[m line too long (87 > 79 characters)
    {'atr_period': 10, 'atr_mult': 1.5, 'leverage': 1},  # Agressif, beaucoup de trades
                                                                               ^
[1m.\tests\debug_sharpe_calculation.py[m[36m:[m24[36m:[m80[36m:[m [1m[31mE501[m line too long (86 > 79 characters)
    {'atr_period': 30, 'atr_mult': 4.0, 'leverage': 1},  # Conservateur, peu de trades
                                                                               ^
[1m.\tests\debug_sharpe_calculation.py[m[36m:[m34[36m:[m80[36m:[m [1m[31mE501[m line too long (85 > 79 characters)
    result = engine.run(df=df, strategy='atr_channel', params=params, timeframe='1h')
                                                                               ^
[1m.\tests\debug_sharpe_calculation.py[m[36m:[m55[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
    # Resample en quotidien (comme le fait le calcul Sharpe avec daily_resample)
                                                                               ^
[1m.\tests\debug_sharpe_calculation.py[m[36m:[m82[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
            sharpe_manual = (mean_excess * np.sqrt(periods_per_year)) / std_returns
                                                                               ^
[1m.\tests\debug_sharpe_calculation.py[m[36m:[m92[36m:[m80[36m:[m [1m[31mE501[m line too long (114 > 79 characters)
                print(f"\n   ‚ö†Ô∏è  Sharpe serait clamp√©: {sharpe_manual:.4f} ‚Üí {np.sign(sharpe_manual) * 20.0:.4f}")
                                                                               ^
[1m.\tests\diagnose.py[m[36m:[m5[36m:[m80[36m:[m [1m[31mE501[m line too long (89 > 79 characters)
"""
Module-ID: diagnose

Purpose: Script diagnostic complet - v√©rifier packages, versions, config, perf, GPU, etc.

Role in pipeline: system validation

Key components: check_packages(), check_gpu(), check_performance(), affichage coul√©

Inputs: Aucun (v√©rifie sys, modules, GPU)

Outputs: Rapport diagnostic complet avec ‚úì/‚úó/‚ö†Ô∏è pour chaque v√©rification

Dependencies: sys, warnings, colorama, psutil, numpy, cupy (optionnel)

Conventions: Couleurs conso via colorama; cles [PASS, FAIL, WARN]

Read-if: Diagnostic installation, GPU, ou d√©pannage perf.

Skip-if: Environnement d√©j√† op√©rationnel.
"""
   
                   

                                                      ^
[1m.\tests\diagnose.py[m[36m:[m9[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
"""
Module-ID: diagnose

Purpose: Script diagnostic complet - v√©rifier packages, versions, config, perf, GPU, etc.

Role in pipeline: system validation

Key components: check_packages(), check_gpu(), check_performance(), affichage coul√©

Inputs: Aucun (v√©rifie sys, modules, GPU)

Outputs: Rapport diagnostic complet avec ‚úì/‚úó/‚ö†Ô∏è pour chaque v√©rification

Dependencies: sys, warnings, colorama, psutil, numpy, cupy (optionnel)

Conventions: Couleurs conso via colorama; cles [PASS, FAIL, WARN]

Read-if: Diagnostic installation, GPU, ou d√©pannage perf.

Skip-if: Environnement d√©j√† op√©rationnel.
"""
   
                   

                                                      ^
[1m.\tests\diagnose.py[m[36m:[m119[36m:[m80[36m:[m [1m[31mE501[m line too long (89 > 79 characters)
        has_bottleneck = 'bottleneck' in sys.modules or pd.options.compute.use_bottleneck
                                                                               ^
[1m.\tests\diagnose.py[m[36m:[m186[36m:[m80[36m:[m [1m[31mE501[m line too long (92 > 79 characters)
        print(f"  {YELLOW}   Installation: pip install {' '.join(missing_critical)}{RESET}")
                                                                               ^
[1m.\tests\diagnose.py[m[36m:[m191[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
        print(f"  {YELLOW}‚ö†Ô∏è  PACKAGES PERFORMANCE MANQUANTS (recommand√©s):{RESET}")
                                                                               ^
[1m.\tests\diagnose.py[m[36m:[m194[36m:[m80[36m:[m [1m[31mE501[m line too long (95 > 79 characters)
        print(f"  {YELLOW}   Installation: pip install -r requirements-performance.txt{RESET}")
                                                                               ^
[1m.\tests\diagnose.py[m[36m:[m225[36m:[m80[36m:[m [1m[31mE501[m line too long (86 > 79 characters)
        print(f"  {YELLOW}   Recommandation: set NUMBA_CACHE_DIR=.numba_cache{RESET}")
                                                                               ^
[1m.\tests\diagnose.py[m[36m:[m232[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
        print(f"  {YELLOW}‚ö†Ô∏è  {len(warnings_list)} warning(s) d√©tect√©(s){RESET}")
                                                                               ^
[1m.\tests\diagnose.py[m[36m:[m248[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
        issues.append(f"{len(missing_critical)} package(s) critique(s) manquant(s)")
                                                                               ^
[1m.\tests\diagnose.py[m[36m:[m250[36m:[m80[36m:[m [1m[31mE501[m line too long (87 > 79 characters)
        issues.append(f"{len(missing_performance)} package(s) performance manquant(s)")
                                                                               ^
[1m.\tests\diagnose.py[m[36m:[m259[36m:[m80[36m:[m [1m[31mE501[m line too long (91 > 79 characters)
        print(f"{YELLOW}Consultez PACKAGES_OPTIONNELS.md pour solutions d√©taill√©es{RESET}")
                                                                               ^
[1m.\tests\diagnose_bollinger.py[m[36m:[m63[36m:[m80[36m:[m [1m[31mE501[m line too long (121 > 79 characters)
    print(f"  ‚Ä¢ Distance Upper-Close: {(last_upper - last_close):.2f} ({(last_upper - last_close)/last_close*100:.1f}%)")
                                                                               ^
[1m.\tests\diagnose_bollinger.py[m[36m:[m64[36m:[m80[36m:[m [1m[31mE501[m line too long (121 > 79 characters)
    print(f"  ‚Ä¢ Distance Close-Lower: {(last_close - last_lower):.2f} ({(last_close - last_lower)/last_close*100:.1f}%)")
                                                                               ^
[1m.\tests\diagnose_bollinger.py[m[36m:[m65[36m:[m80[36m:[m [1m[31mE501[m line too long (116 > 79 characters)
    print(f"  ‚Ä¢ Largeur totale: {(last_upper - last_lower):.2f} ({(last_upper - last_lower)/last_middle*100:.1f}%)")
                                                                               ^
[1m.\tests\diagnose_bollinger.py[m[36m:[m71[36m:[m80[36m:[m [1m[31mE501[m line too long (85 > 79 characters)
    upper_check = np.isclose(last_upper, last_middle + std_dev * last_std, rtol=1e-5)
                                                                               ^
[1m.\tests\diagnose_bollinger.py[m[36m:[m72[36m:[m80[36m:[m [1m[31mE501[m line too long (85 > 79 characters)
    lower_check = np.isclose(last_lower, last_middle - std_dev * last_std, rtol=1e-5)
                                                                               ^
[1m.\tests\diagnose_bollinger.py[m[36m:[m73[36m:[m80[36m:[m [1m[31mE501[m line too long (95 > 79 characters)
    symmetric_check = np.isclose(last_upper - last_middle, last_middle - last_lower, rtol=1e-5)
                                                                               ^
[1m.\tests\diagnose_bollinger.py[m[36m:[m90[36m:[m80[36m:[m [1m[31mE501[m line too long (89 > 79 characters)
    upper_std, middle_std, lower_std = bollinger_bands(close_series, period_std, std_dev)
                                                                               ^
[1m.\tests\diagnose_bollinger.py[m[36m:[m97[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
    print(f"  ‚Ä¢ Largeur bandes (p√©riode=20): {(upper_std[-1] - lower_std[-1]):.2f}")
                                                                               ^
[1m.\tests\diagnose_bollinger.py[m[36m:[m98[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
    print(f"  ‚Ä¢ Largeur bandes (p√©riode={period}): {(last_upper - last_lower):.2f}")
                                                                               ^
[1m.\tests\diagnose_bollinger.py[m[36m:[m106[36m:[m80[36m:[m [1m[31mE501[m line too long (101 > 79 characters)
        print(f"   Avec bb_period={period}, l'√©cart-type est {last_std/last_std_20:.1f}x plus √©lev√©")
                                                                               ^
[1m.\tests\diagnose_bollinger.py[m[36m:[m108[36m:[m80[36m:[m [1m[31mE501[m line too long (85 > 79 characters)
        print("   \n   üëâ Sur le graphique, les bandes DEVRAIENT √™tre PLUS √âLOIGN√âES")
                                                                               ^
[1m.\tests\diagnose_bollinger.py[m[36m:[m114[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
    print("   1. V√©rifier que les param√®tres bb_period et bb_std sont bien pass√©s")
                                                                               ^
[1m.\tests\diagnose_sharpe_anomaly.py[m[36m:[m27[36m:[m80[36m:[m [1m[31mE501[m line too long (89 > 79 characters)
df = pd.read_csv('data/sample_data/BTCUSDT_1h_sample.csv', index_col=0, parse_dates=True)
                                                                               ^
[1m.\tests\diagnose_sharpe_anomaly.py[m[36m:[m98[36m:[m80[36m:[m [1m[31mE501[m line too long (87 > 79 characters)
                sharpe_manual = (mean_excess * np.sqrt(periods_per_year)) / std_returns
                                                                               ^
[1m.\tests\diagnose_sharpe_anomaly.py[m[36m:[m104[36m:[m80[36m:[m [1m[31mE501[m line too long (96 > 79 characters)
                    print(f"   ‚ö†Ô∏è  Sharpe clamp√© de {sharpe_manual:.4f} ‚Üí {sharpe_clamped:.4f}")
                                                                               ^
[1m.\tests\diagnose_sharpe_anomaly.py[m[36m:[m106[36m:[m80[36m:[m [1m[31mE501[m line too long (104 > 79 characters)
                print(f"   ‚ö†Ô∏è  Pas assez de jours ({len(returns_daily)} < 60), Sharpe devrait √™tre 0.0")
                                                                               ^
[1m.\tests\diagnose_sharpe_anomaly.py[m[36m:[m117[36m:[m80[36m:[m [1m[31mE501[m line too long (87 > 79 characters)
    print(f"   ‚ö†Ô∏è  ANOMALIE CONFIRM√âE: Toutes les valeurs sont {sharpe_values[0]:.4f}")
                                                                               ^
[1m.\tests\diagnose_sharpe_anomaly.py[m[36m:[m119[36m:[m80[36m:[m [1m[31mE501[m line too long (90 > 79 characters)
    print(f"   ‚úÖ Sharpe varie entre {min(sharpe_values):.4f} et {max(sharpe_values):.4f}")
                                                                               ^
[1m.\tests\diagnose_sharpe_anomaly.py[m[36m:[m136[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
print(f"   R√©sultats positifs: {positive_count}/5 ({positive_count/5*100:.0f}%)")
                                                                               ^
[1m.\tests\diagnose_sharpe_anomaly.py[m[36m:[m137[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
print(f"   R√©sultats n√©gatifs: {negative_count}/5 ({negative_count/5*100:.0f}%)")
                                                                               ^
[1m.\tests\diagnose_sharpe_anomaly.py[m[36m:[m141[36m:[m80[36m:[m [1m[31mE501[m line too long (89 > 79 characters)
    print(f"   ‚ö†Ô∏è  ANOMALIE POSSIBLE: {positive_count/5*100:.0f}% de r√©sultats positifs")
                                                                               ^
[1m.\tests\diagnose_sharpe_anomaly.py[m[36m:[m160[36m:[m80[36m:[m [1m[31mE501[m line too long (102 > 79 characters)
    print(f"   ‚úÖ P√©riode haussi√®re (+{market_return:.1f}%), biais positif normal pour strat√©gie long")
                                                                               ^
[1m.\tests\diagnose_sharpe_anomaly.py[m[36m:[m162[36m:[m80[36m:[m [1m[31mE501[m line too long (88 > 79 characters)
    print(f"   üìâ P√©riode baissi√®re ({market_return:.1f}%), r√©sultats positifs suspects")
                                                                               ^
[1m.\tests\inspect_counters.py[m[36m:[m4[36m:[m80[36m:[m [1m[31mE501[m line too long (95 > 79 characters)
"""
Module-ID: inspect_counters

Purpose: Inspecter la structure des PerfCounters du BacktestEngine - v√©rifier clefs et formats.

Role in pipeline: performance inspection

Key components: engine.counters, affichage JSON

Inputs: Engine instance avec backtest ex√©cut√©

Outputs: Compteurs JSON (time_indicators, time_signals, time_trading, etc.)

Dependencies: json, numpy, pandas, backtest.engine

Conventions: Compteurs structures en dict Python

Read-if: V√©rifier quels compteurs sont captur√©s.

Skip-if: Vous n'avez pas besoin d'inspecter compteurs.
"""
   
                           

                                              ^
[1m.\tests\profile_analyzer.py[m[36m:[m8[36m:[m80[36m:[m [1m[31mE501[m line too long (98 > 79 characters)
"""
Analyseur Visuel de Profiling - Backtest Core

G√©n√®re des rapports HTML avec graphiques interactifs pour analyser
les r√©sultats de profiling.

Usage:
    python tools/profile_analyzer.py --report profiling_results/report.prof --output analysis.html
"""
   
                                             

                            ^
[1m.\tests\profile_analyzer.py[m[36m:[m202[36m:[m80[36m:[m [1m[31mE501[m line too long (103 > 79 characters)
    html = f"""<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Analyse Profiling - Backtest Core</title>
    <style>
        body {{
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #0e1117;
            color: #fafafa;
            margin: 0;
            padding: 20px;
        }}
        .container {{
            max-width: 1400px;
            margin: 0 auto;
        }}
        h1 {{
            color: #26a69a;
            border-bottom: 2px solid #26a69a;
            padding-bottom: 10px;
        }}
        h2 {{
            color: #42a5f5;
            margin-top: 40px;
        }}
        .summary {{
            background: #1e272e;
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
        }}
        .summary-item {{
            display: inline-block;
            margin-right: 30px;
        }}
        .summary-label {{
            color: #a8b2d1;
            font-size: 0.9em;
        }}
        .summary-value {{
            font-size: 1.5em;
            font-weight: bold;
            color: #26a69a;
        }}
        table {{
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            background: #1e272e;
            border-radius: 8px;
            overflow: hidden;
        }}
        th {{
            background: #26a69a;
            color: white;
            padding: 12px;
            text-align: left;
            font-weight: 600;
        }}
        td {{
            padding: 10px 12px;
            border-bottom: 1px solid #2c3e50;
        }}
        tr:hover {{
            background: #262d35;
        }}
        .function-name {{
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 0.9em;
            color: #ffd700;
        }}
        .metric {{
            text-align: right;
            font-family: 'Consolas', 'Monaco', monospace;
        }}
        .metric-high {{
            color: #ef5350;
            font-weight: bold;
        }}
        .metric-medium {{
            color: #ffa726;
        }}
        .metric-low {{
            color: #66bb6a;
        }}
        .section {{
            margin-bottom: 60px;
        }}
        .warning {{
            background: #ffeb3b;
            color: #000;
            padding: 15px;
            border-radius: 4px;
            margin: 20px 0;
            font-weight: bold;
        }}
        .tip {{
            background: #1e3a5f;
            border-left: 4px solid #42a5f5;
            padding: 15px;
            margin: 20px 0;
        }}
    </style>
</head>
<body>
    <div class="container">
        <h1>üìä Analyse de Performance - Backtest Core</h1>

        <div class="summary">
            <div class="summary-item">
                <div class="summary-label">Rapport</div>
                <div class="summary-value">{Path(report_path).name}</div>
            </div>
            <div class="summary-item">
                <div class="summary-label">Fonctions analys√©es</div>
                <div class="summary-value">{len(cumulative)}</div>
            </div>
        </div>

        <div class="warning">
            ‚ö†Ô∏è ZONES D'OPTIMISATION : Les fonctions en rouge sont les principaux goulots d'√©tranglement
        </div>

        <div class="section">
            <h2>üî• Top {min(30, len(cumulative))} - Temps Cumul√© (avec appels internes)</h2>
            <div class="tip">
                üìå <strong>Temps cumul√©</strong> = temps total pass√© dans la fonction + tout ce qu'elle appelle.
                Ces fonctions sont les <strong>points d'entr√©e</strong> des zones lentes.
            </div>
            <table>
                <thead>
                    <tr>
                        <th>#</th>
                        <th>Fonction</th>
                        <th>Appels</th>
                        <th>Temps Cumul√© (s)</th>
                        <th>Par Appel (ms)</th>
                        <th>% Impact</th>
                    </tr>
                </thead>
                <tbody>
"""
                              
                
      
                        ^
[1m.\tests\profile_analyzer.py[m[36m:[m206[36m:[m80[36m:[m [1m[31mE501[m line too long (91 > 79 characters)
    html = f"""<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Analyse Profiling - Backtest Core</title>
    <style>
        body {{
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #0e1117;
            color: #fafafa;
            margin: 0;
            padding: 20px;
        }}
        .container {{
            max-width: 1400px;
            margin: 0 auto;
        }}
        h1 {{
            color: #26a69a;
            border-bottom: 2px solid #26a69a;
            padding-bottom: 10px;
        }}
        h2 {{
            color: #42a5f5;
            margin-top: 40px;
        }}
        .summary {{
            background: #1e272e;
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
        }}
        .summary-item {{
            display: inline-block;
            margin-right: 30px;
        }}
        .summary-label {{
            color: #a8b2d1;
            font-size: 0.9em;
        }}
        .summary-value {{
            font-size: 1.5em;
            font-weight: bold;
            color: #26a69a;
        }}
        table {{
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            background: #1e272e;
            border-radius: 8px;
            overflow: hidden;
        }}
        th {{
            background: #26a69a;
            color: white;
            padding: 12px;
            text-align: left;
            font-weight: 600;
        }}
        td {{
            padding: 10px 12px;
            border-bottom: 1px solid #2c3e50;
        }}
        tr:hover {{
            background: #262d35;
        }}
        .function-name {{
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 0.9em;
            color: #ffd700;
        }}
        .metric {{
            text-align: right;
            font-family: 'Consolas', 'Monaco', monospace;
        }}
        .metric-high {{
            color: #ef5350;
            font-weight: bold;
        }}
        .metric-medium {{
            color: #ffa726;
        }}
        .metric-low {{
            color: #66bb6a;
        }}
        .section {{
            margin-bottom: 60px;
        }}
        .warning {{
            background: #ffeb3b;
            color: #000;
            padding: 15px;
            border-radius: 4px;
            margin: 20px 0;
            font-weight: bold;
        }}
        .tip {{
            background: #1e3a5f;
            border-left: 4px solid #42a5f5;
            padding: 15px;
            margin: 20px 0;
        }}
    </style>
</head>
<body>
    <div class="container">
        <h1>üìä Analyse de Performance - Backtest Core</h1>

        <div class="summary">
            <div class="summary-item">
                <div class="summary-label">Rapport</div>
                <div class="summary-value">{Path(report_path).name}</div>
            </div>
            <div class="summary-item">
                <div class="summary-label">Fonctions analys√©es</div>
                <div class="summary-value">{len(cumulative)}</div>
            </div>
        </div>

        <div class="warning">
            ‚ö†Ô∏è ZONES D'OPTIMISATION : Les fonctions en rouge sont les principaux goulots d'√©tranglement
        </div>

        <div class="section">
            <h2>üî• Top {min(30, len(cumulative))} - Temps Cumul√© (avec appels internes)</h2>
            <div class="tip">
                üìå <strong>Temps cumul√©</strong> = temps total pass√© dans la fonction + tout ce qu'elle appelle.
                Ces fonctions sont les <strong>points d'entr√©e</strong> des zones lentes.
            </div>
            <table>
                <thead>
                    <tr>
                        <th>#</th>
                        <th>Fonction</th>
                        <th>Appels</th>
                        <th>Temps Cumul√© (s)</th>
                        <th>Par Appel (ms)</th>
                        <th>% Impact</th>
                    </tr>
                </thead>
                <tbody>
"""
                              
                
      
                        ^
[1m.\tests\profile_analyzer.py[m[36m:[m208[36m:[m80[36m:[m [1m[31mE501[m line too long (111 > 79 characters)
    html = f"""<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Analyse Profiling - Backtest Core</title>
    <style>
        body {{
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #0e1117;
            color: #fafafa;
            margin: 0;
            padding: 20px;
        }}
        .container {{
            max-width: 1400px;
            margin: 0 auto;
        }}
        h1 {{
            color: #26a69a;
            border-bottom: 2px solid #26a69a;
            padding-bottom: 10px;
        }}
        h2 {{
            color: #42a5f5;
            margin-top: 40px;
        }}
        .summary {{
            background: #1e272e;
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
        }}
        .summary-item {{
            display: inline-block;
            margin-right: 30px;
        }}
        .summary-label {{
            color: #a8b2d1;
            font-size: 0.9em;
        }}
        .summary-value {{
            font-size: 1.5em;
            font-weight: bold;
            color: #26a69a;
        }}
        table {{
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            background: #1e272e;
            border-radius: 8px;
            overflow: hidden;
        }}
        th {{
            background: #26a69a;
            color: white;
            padding: 12px;
            text-align: left;
            font-weight: 600;
        }}
        td {{
            padding: 10px 12px;
            border-bottom: 1px solid #2c3e50;
        }}
        tr:hover {{
            background: #262d35;
        }}
        .function-name {{
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 0.9em;
            color: #ffd700;
        }}
        .metric {{
            text-align: right;
            font-family: 'Consolas', 'Monaco', monospace;
        }}
        .metric-high {{
            color: #ef5350;
            font-weight: bold;
        }}
        .metric-medium {{
            color: #ffa726;
        }}
        .metric-low {{
            color: #66bb6a;
        }}
        .section {{
            margin-bottom: 60px;
        }}
        .warning {{
            background: #ffeb3b;
            color: #000;
            padding: 15px;
            border-radius: 4px;
            margin: 20px 0;
            font-weight: bold;
        }}
        .tip {{
            background: #1e3a5f;
            border-left: 4px solid #42a5f5;
            padding: 15px;
            margin: 20px 0;
        }}
    </style>
</head>
<body>
    <div class="container">
        <h1>üìä Analyse de Performance - Backtest Core</h1>

        <div class="summary">
            <div class="summary-item">
                <div class="summary-label">Rapport</div>
                <div class="summary-value">{Path(report_path).name}</div>
            </div>
            <div class="summary-item">
                <div class="summary-label">Fonctions analys√©es</div>
                <div class="summary-value">{len(cumulative)}</div>
            </div>
        </div>

        <div class="warning">
            ‚ö†Ô∏è ZONES D'OPTIMISATION : Les fonctions en rouge sont les principaux goulots d'√©tranglement
        </div>

        <div class="section">
            <h2>üî• Top {min(30, len(cumulative))} - Temps Cumul√© (avec appels internes)</h2>
            <div class="tip">
                üìå <strong>Temps cumul√©</strong> = temps total pass√© dans la fonction + tout ce qu'elle appelle.
                Ces fonctions sont les <strong>points d'entr√©e</strong> des zones lentes.
            </div>
            <table>
                <thead>
                    <tr>
                        <th>#</th>
                        <th>Fonction</th>
                        <th>Appels</th>
                        <th>Temps Cumul√© (s)</th>
                        <th>Par Appel (ms)</th>
                        <th>% Impact</th>
                    </tr>
                </thead>
                <tbody>
"""
                              
                
      
                        ^
[1m.\tests\profile_analyzer.py[m[36m:[m209[36m:[m80[36m:[m [1m[31mE501[m line too long (89 > 79 characters)
    html = f"""<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Analyse Profiling - Backtest Core</title>
    <style>
        body {{
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #0e1117;
            color: #fafafa;
            margin: 0;
            padding: 20px;
        }}
        .container {{
            max-width: 1400px;
            margin: 0 auto;
        }}
        h1 {{
            color: #26a69a;
            border-bottom: 2px solid #26a69a;
            padding-bottom: 10px;
        }}
        h2 {{
            color: #42a5f5;
            margin-top: 40px;
        }}
        .summary {{
            background: #1e272e;
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
        }}
        .summary-item {{
            display: inline-block;
            margin-right: 30px;
        }}
        .summary-label {{
            color: #a8b2d1;
            font-size: 0.9em;
        }}
        .summary-value {{
            font-size: 1.5em;
            font-weight: bold;
            color: #26a69a;
        }}
        table {{
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            background: #1e272e;
            border-radius: 8px;
            overflow: hidden;
        }}
        th {{
            background: #26a69a;
            color: white;
            padding: 12px;
            text-align: left;
            font-weight: 600;
        }}
        td {{
            padding: 10px 12px;
            border-bottom: 1px solid #2c3e50;
        }}
        tr:hover {{
            background: #262d35;
        }}
        .function-name {{
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 0.9em;
            color: #ffd700;
        }}
        .metric {{
            text-align: right;
            font-family: 'Consolas', 'Monaco', monospace;
        }}
        .metric-high {{
            color: #ef5350;
            font-weight: bold;
        }}
        .metric-medium {{
            color: #ffa726;
        }}
        .metric-low {{
            color: #66bb6a;
        }}
        .section {{
            margin-bottom: 60px;
        }}
        .warning {{
            background: #ffeb3b;
            color: #000;
            padding: 15px;
            border-radius: 4px;
            margin: 20px 0;
            font-weight: bold;
        }}
        .tip {{
            background: #1e3a5f;
            border-left: 4px solid #42a5f5;
            padding: 15px;
            margin: 20px 0;
        }}
    </style>
</head>
<body>
    <div class="container">
        <h1>üìä Analyse de Performance - Backtest Core</h1>

        <div class="summary">
            <div class="summary-item">
                <div class="summary-label">Rapport</div>
                <div class="summary-value">{Path(report_path).name}</div>
            </div>
            <div class="summary-item">
                <div class="summary-label">Fonctions analys√©es</div>
                <div class="summary-value">{len(cumulative)}</div>
            </div>
        </div>

        <div class="warning">
            ‚ö†Ô∏è ZONES D'OPTIMISATION : Les fonctions en rouge sont les principaux goulots d'√©tranglement
        </div>

        <div class="section">
            <h2>üî• Top {min(30, len(cumulative))} - Temps Cumul√© (avec appels internes)</h2>
            <div class="tip">
                üìå <strong>Temps cumul√©</strong> = temps total pass√© dans la fonction + tout ce qu'elle appelle.
                Ces fonctions sont les <strong>points d'entr√©e</strong> des zones lentes.
            </div>
            <table>
                <thead>
                    <tr>
                        <th>#</th>
                        <th>Fonction</th>
                        <th>Appels</th>
                        <th>Temps Cumul√© (s)</th>
                        <th>Par Appel (ms)</th>
                        <th>% Impact</th>
                    </tr>
                </thead>
                <tbody>
"""
                              
                
      
                        ^
[1m.\tests\profile_analyzer.py[m[36m:[m227[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
        pct = (stat["cumtime"] / total_cumtime * 100) if total_cumtime > 0 else 0
                                                                               ^
[1m.\tests\profile_analyzer.py[m[36m:[m228[36m:[m80[36m:[m [1m[31mE501[m line too long (98 > 79 characters)
        metric_class = "metric-high" if pct > 10 else "metric-medium" if pct > 5 else "metric-low"
                                                                               ^
[1m.\tests\profile_analyzer.py[m[36m:[m235[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
        html += f"""
                    <tr>
                        <td>{i}</td>
                        <td class="function-name">{stat['function']}</td>
                        <td class="metric">{stat['calls']:,}</td>
                        <td class="metric {metric_class}">{stat['cumtime']:.3f}</td>
                        <td class="metric">{stat['percall_cum']*1000:.2f}</td>
                        <td class="metric {metric_class}">{pct:.1f}%</td>
                    </tr>
"""
                    
                        
                                 ^
[1m.\tests\profile_analyzer.py[m[36m:[m247[36m:[m80[36m:[m [1m[31mE501[m line too long (88 > 79 characters)
    html += f"""
                </tbody>
            </table>
        </div>

        <div class="section">
            <h2>‚ö° Top {min(30, len(by_time))} - Temps Propre (sans appels internes)</h2>
            <div class="tip">
                üìå <strong>Temps propre</strong> = temps pass√© UNIQUEMENT dans cette fonction (hors appels).
                Ces fonctions sont les <strong>v√©ritables consommateurs</strong> de temps CPU.
            </div>
            <table>
                <thead>
                    <tr>
                        <th>#</th>
                        <th>Fonction</th>
                        <th>Appels</th>
                        <th>Temps Propre (s)</th>
                        <th>Par Appel (ms)</th>
                        <th>% Impact</th>
                    </tr>
                </thead>
                <tbody>
"""
                
                        
                    
              

^
[1m.\tests\profile_analyzer.py[m[36m:[m249[36m:[m80[36m:[m [1m[31mE501[m line too long (107 > 79 characters)
    html += f"""
                </tbody>
            </table>
        </div>

        <div class="section">
            <h2>‚ö° Top {min(30, len(by_time))} - Temps Propre (sans appels internes)</h2>
            <div class="tip">
                üìå <strong>Temps propre</strong> = temps pass√© UNIQUEMENT dans cette fonction (hors appels).
                Ces fonctions sont les <strong>v√©ritables consommateurs</strong> de temps CPU.
            </div>
            <table>
                <thead>
                    <tr>
                        <th>#</th>
                        <th>Fonction</th>
                        <th>Appels</th>
                        <th>Temps Propre (s)</th>
                        <th>Par Appel (ms)</th>
                        <th>% Impact</th>
                    </tr>
                </thead>
                <tbody>
"""
                
                        
                    
              

^
[1m.\tests\profile_analyzer.py[m[36m:[m250[36m:[m80[36m:[m [1m[31mE501[m line too long (94 > 79 characters)
    html += f"""
                </tbody>
            </table>
        </div>

        <div class="section">
            <h2>‚ö° Top {min(30, len(by_time))} - Temps Propre (sans appels internes)</h2>
            <div class="tip">
                üìå <strong>Temps propre</strong> = temps pass√© UNIQUEMENT dans cette fonction (hors appels).
                Ces fonctions sont les <strong>v√©ritables consommateurs</strong> de temps CPU.
            </div>
            <table>
                <thead>
                    <tr>
                        <th>#</th>
                        <th>Fonction</th>
                        <th>Appels</th>
                        <th>Temps Propre (s)</th>
                        <th>Par Appel (ms)</th>
                        <th>% Impact</th>
                    </tr>
                </thead>
                <tbody>
"""
                
                        
                    
              

^
[1m.\tests\profile_analyzer.py[m[36m:[m268[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
        pct = (stat["tottime"] / total_tottime * 100) if total_tottime > 0 else 0
                                                                               ^
[1m.\tests\profile_analyzer.py[m[36m:[m269[36m:[m80[36m:[m [1m[31mE501[m line too long (98 > 79 characters)
        metric_class = "metric-high" if pct > 10 else "metric-medium" if pct > 5 else "metric-low"
                                                                               ^
[1m.\tests\profile_analyzer.py[m[36m:[m276[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
        html += f"""
                    <tr>
                        <td>{i}</td>
                        <td class="function-name">{stat['function']}</td>
                        <td class="metric">{stat['calls']:,}</td>
                        <td class="metric {metric_class}">{stat['tottime']:.3f}</td>
                        <td class="metric">{stat['percall_tot']*1000:.2f}</td>
                        <td class="metric {metric_class}">{pct:.1f}%</td>
                    </tr>
"""
                    
                        
                                 ^
[1m.\tests\profile_analyzer.py[m[36m:[m290[36m:[m80[36m:[m [1m[31mE501[m line too long (115 > 79 characters)
    html += f"""
                </tbody>
            </table>
        </div>

        <div class="section">
            <h2>üîÑ Top {min(20, len(by_calls))} - Nombre d'Appels</h2>
            <div class="tip">
                üìå Fonctions appel√©es tr√®s fr√©quemment. M√™me une petite optimisation ici peut avoir un grand impact.
            </div>
            <table>
                <thead>
                    <tr>
                        <th>#</th>
                        <th>Fonction</th>
                        <th>Appels</th>
                        <th>Temps Total (s)</th>
                        <th>Par Appel (Œºs)</th>
                    </tr>
                </thead>
                <tbody>
"""
                
                        
                    
              

^
[1m.\tests\profile_analyzer.py[m[36m:[m306[36m:[m80[36m:[m [1m[31mE501[m line too long (126 > 79 characters)
        metric_class = "metric-high" if stat['calls'] > 100000 else "metric-medium" if stat['calls'] > 10000 else "metric-low"
                                                                               ^
[1m.\tests\profile_analyzer.py[m[36m:[m312[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
        html += f"""
                    <tr>
                        <td>{i}</td>
                        <td class="function-name">{stat['function']}</td>
                        <td class="metric {metric_class}">{stat['calls']:,}</td>
                        <td class="metric">{stat['tottime']:.3f}</td>
                        <td class="metric">{stat['percall_tot']*1_000_000:.1f}</td>
                    </tr>
"""
                    
                        
                                 ^
[1m.\tests\profile_analyzer.py[m[36m:[m314[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
        html += f"""
                    <tr>
                        <td>{i}</td>
                        <td class="function-name">{stat['function']}</td>
                        <td class="metric {metric_class}">{stat['calls']:,}</td>
                        <td class="metric">{stat['tottime']:.3f}</td>
                        <td class="metric">{stat['percall_tot']*1_000_000:.1f}</td>
                    </tr>
"""
                    
                        
                                 ^
[1m.\tests\profile_analyzer.py[m[36m:[m326[36m:[m80[36m:[m [1m[31mE501[m line too long (145 > 79 characters)
    html += """
                </tbody>
            </table>
        </div>

        <div class="tip">
            <h3>üí° Guide d'Optimisation</h3>
            <ol>
                <li><strong>Temps Cumul√© √©lev√©</strong> ‚Üí Identifier les fonctions appel√©es √† l'int√©rieur (regarder la table "Temps Propre")</li>
                <li><strong>Temps Propre √©lev√©</strong> ‚Üí Optimiser directement cette fonction (vectorisation, cache, algorithme plus efficace)</li>
                <li><strong>Nombre d'appels √©lev√©</strong> ‚Üí Peut-on r√©duire les appels ? (cache, batch processing, lazy evaluation)</li>
            </ol>
            <h3>üéØ Priorit√©s d'Optimisation</h3>
            <ul>
                <li>üî¥ <strong>ROUGE</strong> (>10%) : Goulots critiques - optimisation prioritaire</li>
                <li>üü† <strong>ORANGE</strong> (5-10%) : Impact significatif - optimisation recommand√©e</li>
                <li>üü¢ <strong>VERT</strong> (<5%) : Impact faible - optimisation optionnelle</li>
            </ul>
        </div>
    </div>
</body>
</html>
"""
               
                        
                    
              

 ^
[1m.\tests\profile_analyzer.py[m[36m:[m327[36m:[m80[36m:[m [1m[31mE501[m line too long (148 > 79 characters)
    html += """
                </tbody>
            </table>
        </div>

        <div class="tip">
            <h3>üí° Guide d'Optimisation</h3>
            <ol>
                <li><strong>Temps Cumul√© √©lev√©</strong> ‚Üí Identifier les fonctions appel√©es √† l'int√©rieur (regarder la table "Temps Propre")</li>
                <li><strong>Temps Propre √©lev√©</strong> ‚Üí Optimiser directement cette fonction (vectorisation, cache, algorithme plus efficace)</li>
                <li><strong>Nombre d'appels √©lev√©</strong> ‚Üí Peut-on r√©duire les appels ? (cache, batch processing, lazy evaluation)</li>
            </ol>
            <h3>üéØ Priorit√©s d'Optimisation</h3>
            <ul>
                <li>üî¥ <strong>ROUGE</strong> (>10%) : Goulots critiques - optimisation prioritaire</li>
                <li>üü† <strong>ORANGE</strong> (5-10%) : Impact significatif - optimisation recommand√©e</li>
                <li>üü¢ <strong>VERT</strong> (<5%) : Impact faible - optimisation optionnelle</li>
            </ul>
        </div>
    </div>
</body>
</html>
"""
               
                        
                    
              

 ^
[1m.\tests\profile_analyzer.py[m[36m:[m328[36m:[m80[36m:[m [1m[31mE501[m line too long (137 > 79 characters)
    html += """
                </tbody>
            </table>
        </div>

        <div class="tip">
            <h3>üí° Guide d'Optimisation</h3>
            <ol>
                <li><strong>Temps Cumul√© √©lev√©</strong> ‚Üí Identifier les fonctions appel√©es √† l'int√©rieur (regarder la table "Temps Propre")</li>
                <li><strong>Temps Propre √©lev√©</strong> ‚Üí Optimiser directement cette fonction (vectorisation, cache, algorithme plus efficace)</li>
                <li><strong>Nombre d'appels √©lev√©</strong> ‚Üí Peut-on r√©duire les appels ? (cache, batch processing, lazy evaluation)</li>
            </ol>
            <h3>üéØ Priorit√©s d'Optimisation</h3>
            <ul>
                <li>üî¥ <strong>ROUGE</strong> (>10%) : Goulots critiques - optimisation prioritaire</li>
                <li>üü† <strong>ORANGE</strong> (5-10%) : Impact significatif - optimisation recommand√©e</li>
                <li>üü¢ <strong>VERT</strong> (<5%) : Impact faible - optimisation optionnelle</li>
            </ul>
        </div>
    </div>
</body>
</html>
"""
               
                        
                    
              

 ^
[1m.\tests\profile_analyzer.py[m[36m:[m332[36m:[m80[36m:[m [1m[31mE501[m line too long (103 > 79 characters)
    html += """
                </tbody>
            </table>
        </div>

        <div class="tip">
            <h3>üí° Guide d'Optimisation</h3>
            <ol>
                <li><strong>Temps Cumul√© √©lev√©</strong> ‚Üí Identifier les fonctions appel√©es √† l'int√©rieur (regarder la table "Temps Propre")</li>
                <li><strong>Temps Propre √©lev√©</strong> ‚Üí Optimiser directement cette fonction (vectorisation, cache, algorithme plus efficace)</li>
                <li><strong>Nombre d'appels √©lev√©</strong> ‚Üí Peut-on r√©duire les appels ? (cache, batch processing, lazy evaluation)</li>
            </ol>
            <h3>üéØ Priorit√©s d'Optimisation</h3>
            <ul>
                <li>üî¥ <strong>ROUGE</strong> (>10%) : Goulots critiques - optimisation prioritaire</li>
                <li>üü† <strong>ORANGE</strong> (5-10%) : Impact significatif - optimisation recommand√©e</li>
                <li>üü¢ <strong>VERT</strong> (<5%) : Impact faible - optimisation optionnelle</li>
            </ul>
        </div>
    </div>
</body>
</html>
"""
               
                        
                    
              

 ^
[1m.\tests\profile_analyzer.py[m[36m:[m333[36m:[m80[36m:[m [1m[31mE501[m line too long (107 > 79 characters)
    html += """
                </tbody>
            </table>
        </div>

        <div class="tip">
            <h3>üí° Guide d'Optimisation</h3>
            <ol>
                <li><strong>Temps Cumul√© √©lev√©</strong> ‚Üí Identifier les fonctions appel√©es √† l'int√©rieur (regarder la table "Temps Propre")</li>
                <li><strong>Temps Propre √©lev√©</strong> ‚Üí Optimiser directement cette fonction (vectorisation, cache, algorithme plus efficace)</li>
                <li><strong>Nombre d'appels √©lev√©</strong> ‚Üí Peut-on r√©duire les appels ? (cache, batch processing, lazy evaluation)</li>
            </ol>
            <h3>üéØ Priorit√©s d'Optimisation</h3>
            <ul>
                <li>üî¥ <strong>ROUGE</strong> (>10%) : Goulots critiques - optimisation prioritaire</li>
                <li>üü† <strong>ORANGE</strong> (5-10%) : Impact significatif - optimisation recommand√©e</li>
                <li>üü¢ <strong>VERT</strong> (<5%) : Impact faible - optimisation optionnelle</li>
            </ul>
        </div>
    </div>
</body>
</html>
"""
               
                        
                    
              

 ^
[1m.\tests\profile_analyzer.py[m[36m:[m334[36m:[m80[36m:[m [1m[31mE501[m line too long (97 > 79 characters)
    html += """
                </tbody>
            </table>
        </div>

        <div class="tip">
            <h3>üí° Guide d'Optimisation</h3>
            <ol>
                <li><strong>Temps Cumul√© √©lev√©</strong> ‚Üí Identifier les fonctions appel√©es √† l'int√©rieur (regarder la table "Temps Propre")</li>
                <li><strong>Temps Propre √©lev√©</strong> ‚Üí Optimiser directement cette fonction (vectorisation, cache, algorithme plus efficace)</li>
                <li><strong>Nombre d'appels √©lev√©</strong> ‚Üí Peut-on r√©duire les appels ? (cache, batch processing, lazy evaluation)</li>
            </ol>
            <h3>üéØ Priorit√©s d'Optimisation</h3>
            <ul>
                <li>üî¥ <strong>ROUGE</strong> (>10%) : Goulots critiques - optimisation prioritaire</li>
                <li>üü† <strong>ORANGE</strong> (5-10%) : Impact significatif - optimisation recommand√©e</li>
                <li>üü¢ <strong>VERT</strong> (<5%) : Impact faible - optimisation optionnelle</li>
            </ul>
        </div>
    </div>
</body>
</html>
"""
               
                        
                    
              

 ^
[1m.\tests\profile_analyzer.py[m[36m:[m350[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
    parser = argparse.ArgumentParser(description="Analyseur visuel de profiling")
                                                                               ^
[1m.\tests\profile_analyzer.py[m[36m:[m351[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
    parser.add_argument("--report", required=True, help="Fichier .prof √† analyser")
                                                                               ^
[1m.\tests\profile_analyzer.py[m[36m:[m352[36m:[m80[36m:[m [1m[31mE501[m line too long (101 > 79 characters)
    parser.add_argument("--output", default="profiling_analysis.html", help="Fichier HTML de sortie")
                                                                               ^
[1m.\tests\profile_analyzer.py[m[36m:[m353[36m:[m80[36m:[m [1m[31mE501[m line too long (95 > 79 characters)
    parser.add_argument("--top-n", type=int, default=50, help="Nombre de fonctions √† analyser")
                                                                               ^
[1m.\tests\profile_backtest_cprofile.py[m[36m:[m61[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
def _generate_synthetic_ohlcv(bars: int, seed: int, timeframe: str) -> pd.DataFrame:
                                                                               ^
[1m.\tests\profile_backtest_cprofile.py[m[36m:[m176[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
            stats.strip_dirs().sort_stats(config.sort_by).print_stats(config.top_n)
                                                                               ^
[1m.\tests\profile_demo.py[m[36m:[m76[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
    high_prices = prices * (1 + np.abs(np.random.normal(0, volatility / 2, n_bars)))
                                                                               ^
[1m.\tests\profile_demo.py[m[36m:[m77[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
    low_prices = prices * (1 - np.abs(np.random.normal(0, volatility / 2, n_bars)))
                                                                               ^
[1m.\tests\profile_demo.py[m[36m:[m97[36m:[m80[36m:[m [1m[31mE501[m line too long (93 > 79 characters)
    performance_profiler_cls, backtest_engine_cls, config_cls, get_strategy_fn = _bootstrap()
                                                                               ^
[1m.\tests\profile_demo.py[m[36m:[m200[36m:[m80[36m:[m [1m[31mE501[m line too long (92 > 79 characters)
        print(f"   Progression: {i+1}/{len(param_grid)} ({(i+1)/len(param_grid)*100:.0f}%)")
                                                                               ^
[1m.\tests\profile_demo.py[m[36m:[m242[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
    print("\n1. Les rapports .prof ont √©t√© sauvegard√©s dans profiling_results/")
                                                                               ^
[1m.\tests\profile_demo.py[m[36m:[m244[36m:[m80[36m:[m [1m[31mE501[m line too long (122 > 79 characters)
    print("   python tools/profile_analyzer.py --report profiling_results/demo_simple_*.prof --output demo_analysis.html")
                                                                               ^
[1m.\tests\profile_demo.py[m[36m:[m247[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
    print("\n4. Chercher les fonctions en ROUGE (> 10% du temps) pour optimiser")
                                                                               ^
[1m.\tests\profiler.py[m[36m:[m15[36m:[m80[36m:[m [1m[31mE501[m line too long (91 > 79 characters)
"""
Profiler de Performance - Backtest Core

Outils pour profiler et analyser les performances du code.
Identifie les goulots d'√©tranglement (bottlenecks) pour optimisation.

Usage:
    # Profiler un backtest simple
    python tools/profiler.py simple --strategy ema_cross

    # Profiler une optimisation Grid Search
    python tools/profiler.py grid --strategy ema_cross --combinations 50

    # Analyser un rapport de profiling
    python tools/profiler.py analyze --report profiling_results/report_20250101_120000.prof
"""
   
                                       

                                  ^
[1m.\tests\profiler.py[m[36m:[m246[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
    param_grid = generate_param_grid(param_specs, max_combinations=n_combinations)
                                                                               ^
[1m.\tests\profiler.py[m[36m:[m266[36m:[m80[36m:[m [1m[31mE501[m line too long (96 > 79 characters)
            print(f"   Progression: {i+1}/{len(param_grid)} ({(i+1)/len(param_grid)*100:.1f}%)")
                                                                               ^
[1m.\tests\profiler.py[m[36m:[m343[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
    subparsers = parser.add_subparsers(dest="command", help="Commande √† ex√©cuter")
                                                                               ^
[1m.\tests\profiler.py[m[36m:[m346[36m:[m80[36m:[m [1m[31mE501[m line too long (87 > 79 characters)
    parser_simple = subparsers.add_parser("simple", help="Profiler un backtest simple")
                                                                               ^
[1m.\tests\profiler.py[m[36m:[m347[36m:[m80[36m:[m [1m[31mE501[m line too long (87 > 79 characters)
    parser_simple.add_argument("--strategy", required=True, help="Nom de la strat√©gie")
                                                                               ^
[1m.\tests\profiler.py[m[36m:[m348[36m:[m80[36m:[m [1m[31mE501[m line too long (95 > 79 characters)
    parser_simple.add_argument("--symbol", default="BTCUSDT", help="Symbole (d√©faut: BTCUSDT)")
                                                                               ^
[1m.\tests\profiler.py[m[36m:[m349[36m:[m80[36m:[m [1m[31mE501[m line too long (90 > 79 characters)
    parser_simple.add_argument("--timeframe", default="1h", help="Timeframe (d√©faut: 1h)")
                                                                               ^
[1m.\tests\profiler.py[m[36m:[m350[36m:[m80[36m:[m [1m[31mE501[m line too long (85 > 79 characters)
    parser_simple.add_argument("--start", default="2024-01-01", help="Date de d√©but")
                                                                               ^
[1m.\tests\profiler.py[m[36m:[m351[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
    parser_simple.add_argument("--end", default="2024-12-31", help="Date de fin")
                                                                               ^
[1m.\tests\profiler.py[m[36m:[m354[36m:[m80[36m:[m [1m[31mE501[m line too long (93 > 79 characters)
    parser_grid = subparsers.add_parser("grid", help="Profiler une optimisation Grid Search")
                                                                               ^
[1m.\tests\profiler.py[m[36m:[m355[36m:[m80[36m:[m [1m[31mE501[m line too long (85 > 79 characters)
    parser_grid.add_argument("--strategy", required=True, help="Nom de la strat√©gie")
                                                                               ^
[1m.\tests\profiler.py[m[36m:[m356[36m:[m80[36m:[m [1m[31mE501[m line too long (99 > 79 characters)
    parser_grid.add_argument("--combinations", type=int, default=50, help="Nombre de combinaisons")
                                                                               ^
[1m.\tests\profiler.py[m[36m:[m357[36m:[m80[36m:[m [1m[31mE501[m line too long (93 > 79 characters)
    parser_grid.add_argument("--symbol", default="BTCUSDT", help="Symbole (d√©faut: BTCUSDT)")
                                                                               ^
[1m.\tests\profiler.py[m[36m:[m358[36m:[m80[36m:[m [1m[31mE501[m line too long (88 > 79 characters)
    parser_grid.add_argument("--timeframe", default="1h", help="Timeframe (d√©faut: 1h)")
                                                                               ^
[1m.\tests\profiler.py[m[36m:[m359[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
    parser_grid.add_argument("--start", default="2024-01-01", help="Date de d√©but")
                                                                               ^
[1m.\tests\profiler.py[m[36m:[m363[36m:[m80[36m:[m [1m[31mE501[m line too long (94 > 79 characters)
    parser_analyze = subparsers.add_parser("analyze", help="Analyser un rapport de profiling")
                                                                               ^
[1m.\tests\profiler.py[m[36m:[m364[36m:[m80[36m:[m [1m[31mE501[m line too long (95 > 79 characters)
    parser_analyze.add_argument("--report", required=True, help="Chemin vers le fichier .prof")
                                                                               ^
[1m.\tests\profiler_detailed.py[m[36m:[m4[36m:[m80[36m:[m [1m[31mE501[m line too long (121 > 79 characters)
"""
Module-ID: profiler_detailed

Purpose: Profiler d√©taill√© BacktestEngine pour identifier bottlenecks - timing par √©tape (indicateurs, signaux, trading).

Role in pipeline: performance profiling

Key components: DetailedProfiler, engine.run(), granular timing

Inputs: 1000 barres synth√©tiques, grille 3 param√®tres

Outputs: Timings d√©taill√©s par fonction, analyse bottlenecks

Dependencies: numpy, pandas, time, backtest.engine

Conventions: Profiling manuel par fonction; temps en millisecondes

Read-if: Deep dive bottlenecks, optimisation sp√©cifiques.

Skip-if: Baseline perf suffisant ou utilisez cProfile.
"""
   
                            

                                             ^
[1m.\tests\profiler_detailed.py[m[36m:[m74[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
    strat_obj = get_strategy(strategy) if isinstance(strategy, str) else strategy
                                                                               ^
[1m.\tests\profiler_detailed.py[m[36m:[m171[36m:[m80[36m:[m [1m[31mE501[m line too long (89 > 79 characters)
print(f"\n{'√âtape':<20} {'Total (s)':<12} {'Moy (ms)':<12} {'% Total':<10} {'Appels/s'}")
                                                                               ^
[1m.\tests\profiler_detailed.py[m[36m:[m183[36m:[m80[36m:[m [1m[31mE501[m line too long (90 > 79 characters)
    print(f"{key:<20} {total:<12.3f} {mean_ms:<12.2f} {pct:<9.1f}% {calls_per_sec:>8.0f}")
                                                                               ^
[1m.\tests\profiler_detailed.py[m[36m:[m217[36m:[m80[36m:[m [1m[31mE501[m line too long (87 > 79 characters)
    print(f"\nüí° Objectif: 500 runs/sec (gain possible: +{gain_possible:.0f} runs/sec)")
                                                                               ^
[1m.\tests\profiler_simple.py[m[36m:[m4[36m:[m80[36m:[m [1m[31mE501[m line too long (111 > 79 characters)
"""
Module-ID: profiler_simple

Purpose: Profiler simple BacktestEngine - exploiter PerfCounters natives (time_indicators, time_signals, etc.).

Role in pipeline: performance profiling

Key components: engine.run(), consultation result.counters, timing

Inputs: 1000 barres synth√©tiques, grille 4 param√®tres

Outputs: PerfCounters (time_indicators, time_signals, time_trading, etc.)

Dependencies: numpy, pandas, backtest.engine, utils.config

Conventions: Compteurs en millisecondes

Read-if: Identifier bottlenecks via compteurs natifs engine.

Skip-if: Profiling pas besoin (ou utilisez profiler_detailed).
"""
   
                          

                                               ^
[1m.\tests\profiler_simple.py[m[36m:[m77[36m:[m80[36m:[m [1m[31mE501[m line too long (91 > 79 characters)
        silent_mode=True  # Activer le mode silencieux pour tester les gains de performance
                                                                               ^
[1m.\tests\profiler_simple.py[m[36m:[m123[36m:[m80[36m:[m [1m[31mE501[m line too long (100 > 79 characters)
avg_total_ms = sum(total_ms_list) / len(total_ms_list) if total_ms_list else elapsed * 1000 / N_RUNS
                                                                               ^
[1m.\tests\profiler_simple.py[m[36m:[m147[36m:[m80[36m:[m [1m[31mE501[m line too long (98 > 79 characters)
bottlenecks = [(name, total_s) for name, (total_s, avg_ms) in sorted_steps if name != 'total'][:3]
                                                                               ^
[1m.\tests\profiler_simple.py[m[36m:[m183[36m:[m80[36m:[m [1m[31mE501[m line too long (114 > 79 characters)
    print(f"   Gap √† combler: +{500 - runs_per_sec:.0f} runs/sec ({(500/runs_per_sec - 1)*100:.0f}% plus rapide)")
                                                                               ^
[1m.\tests\profiler_simple.py[m[36m:[m191[36m:[m80[36m:[m [1m[31mE501[m line too long (99 > 79 characters)
            print(f"\nüéØ Focus prioritaire: optimiser '{top_bottleneck}' ({top_pct:.0f}% du temps)")
                                                                               ^
[1m.\tests\reorganize_root.py[m[36m:[m8[36m:[m80[36m:[m [1m[31mE501[m line too long (123 > 79 characters)
"""R√©organisation automatique de la racine du d√©p√¥t.

Usage :
    python tools/reorganize_root.py           # dry-run (par d√©faut)
    python tools/reorganize_root.py --execute # applique les d√©placements

Le script applique la cartographie d√©crite dans docs/ROOT_REORGANISATION.md.
Il n'est **pas ex√©cut√© automatiquement** : lancez-le manuellement depuis votre poste apr√®s v√©rification de vos sauvegardes.
Il ignore les entr√©es inexistantes et prot√®ge les fichiers d√©j√† pr√©sents en cr√©ant
un backup horodat√© en cas de collision.
"""
                                                    

       
                 ^
[1m.\tests\reorganize_root.py[m[36m:[m9[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
"""R√©organisation automatique de la racine du d√©p√¥t.

Usage :
    python tools/reorganize_root.py           # dry-run (par d√©faut)
    python tools/reorganize_root.py --execute # applique les d√©placements

Le script applique la cartographie d√©crite dans docs/ROOT_REORGANISATION.md.
Il n'est **pas ex√©cut√© automatiquement** : lancez-le manuellement depuis votre poste apr√®s v√©rification de vos sauvegardes.
Il ignore les entr√©es inexistantes et prot√®ge les fichiers d√©j√† pr√©sents en cr√©ant
un backup horodat√© en cas de collision.
"""
                                                    

       
                 ^
[1m.\tests\reorganize_root.py[m[36m:[m151[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
def safe_move(source: Path, destination_dir: Path, *, dry_run: bool = True) -> None:
                                                                               ^
[1m.\tests\reorganize_root.py[m[36m:[m172[36m:[m80[36m:[m [1m[31mE501[m line too long (88 > 79 characters)
        # ne pas toucher aux fichiers du contr√¥le de version ou aux r√©pertoires internes
                                                                               ^
[1m.\tests\reorganize_root.py[m[36m:[m185[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
    dry_run = "--execute" not in {arg.lower() for arg in __import__("sys").argv[1:]}
                                                                               ^
[1m.\tests\reorganize_root.py[m[36m:[m189[36m:[m80[36m:[m [1m[31mE501[m line too long (97 > 79 characters)
    print(f"\nR√©sum√© ({mode}) : {moved} √©l√©ment(s) concern√©(s) sur {len(items)} entr√©es racine.")
                                                                               ^
[1m.\tests\run_atr_grid_mini.py[m[36m:[m24[36m:[m1[36m:[m [1m[31mE402[m module level import not at top of file
from backtest.sweep import SweepEngine
^
[1m.\tests\run_atr_grid_mini.py[m[36m:[m25[36m:[m1[36m:[m [1m[31mE402[m module level import not at top of file
from strategies.atr_channel import ATRChannelStrategy
^
[1m.\tests\run_atr_grid_mini.py[m[36m:[m28[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
def generate_test_data(n_bars: int = 500, volatility: float = 0.02) -> pd.DataFrame:
                                                                               ^
[1m.\tests\run_atr_grid_mini.py[m[36m:[m74[36m:[m80[36m:[m [1m[31mE501[m line too long (94 > 79 characters)
    parser = argparse.ArgumentParser(description="Grid search mini sur strat√©gie ATR Channel")
                                                                               ^
[1m.\tests\run_atr_grid_mini.py[m[36m:[m75[36m:[m80[36m:[m [1m[31mE501[m line too long (89 > 79 characters)
    parser.add_argument("--n-bars", type=int, default=500, help="Nombre de barres OHLCV")
                                                                               ^
[1m.\tests\run_atr_grid_mini.py[m[36m:[m76[36m:[m80[36m:[m [1m[31mE501[m line too long (94 > 79 characters)
    parser.add_argument("--workers", type=int, default=4, help="Nombre de workers parall√®les")
                                                                               ^
[1m.\tests\run_atr_grid_mini.py[m[36m:[m100[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
    n_combinations = len(param_grid['atr_period']) * len(param_grid['atr_mult'])
                                                                               ^
[1m.\tests\run_atr_grid_mini.py[m[36m:[m136[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
        print(f"üìä Combinaisons test√©es: {results.n_completed}/{n_combinations}")
                                                                               ^
[1m.\tests\run_atr_grid_mini.py[m[36m:[m156[36m:[m80[36m:[m [1m[31mE501[m line too long (88 > 79 characters)
        output_file = Path("backtest_results") / f"atr_grid_mini_{int(time.time())}.csv"
                                                                               ^
[1m.\tests\run_profile_big.py[m[36m:[m11[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
from tools.profile_backtest_cprofile import ProfileConfig, run_profile  # noqa: E402
                                                                               ^
[1m.\tests\save_best_run.py[m[36m:[m17[36m:[m1[36m:[m [1m[31mE402[m module level import not at top of file
from backtest.engine import BacktestEngine
^
[1m.\tests\save_best_run.py[m[36m:[m18[36m:[m1[36m:[m [1m[31mE402[m module level import not at top of file
from backtest.storage import ResultStorage
^
[1m.\tests\save_best_run.py[m[36m:[m19[36m:[m1[36m:[m [1m[31mE402[m module level import not at top of file
from strategies import get_strategy
^
[1m.\tests\save_best_run.py[m[36m:[m20[36m:[m1[36m:[m [1m[31mE402[m module level import not at top of file
from data.loader import load_ohlcv
^
[1m.\tests\save_best_run.py[m[36m:[m21[36m:[m1[36m:[m [1m[31mE402[m module level import not at top of file
from utils.log import get_logger
^
[1m.\tests\save_best_run.py[m[36m:[m25[36m:[m1[36m:[m [1m[31mE302[m expected 2 blank lines, found 1
def main():
^
[1m.\tests\save_best_run.py[m[36m:[m89[36m:[m80[36m:[m [1m[31mE501[m line too long (91 > 79 characters)
        logger.info(f"üìã Cl√©s disponibles dans metrics: {list(result.metrics.keys())[:20]}")
                                                                               ^
[1m.\tests\save_best_run.py[m[36m:[m92[36m:[m80[36m:[m [1m[31mE501[m line too long (86 > 79 characters)
        logger.info(f"Total Return: {result.metrics.get('total_return_pct', 0):.2f}%")
                                                                               ^
[1m.\tests\save_best_run.py[m[36m:[m93[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
        logger.info(f"Sharpe Ratio: {result.metrics.get('sharpe_ratio', 0):.4f}")
                                                                               ^
[1m.\tests\save_best_run.py[m[36m:[m94[36m:[m80[36m:[m [1m[31mE501[m line too long (86 > 79 characters)
        logger.info(f"Max Drawdown: {result.metrics.get('max_drawdown_pct', 0):.2f}%")
                                                                               ^
[1m.\tests\save_best_run.py[m[36m:[m96[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
        logger.info(f"Win Rate Pct: {result.metrics.get('win_rate_pct', 0):.2f}%")
                                                                               ^
[1m.\tests\save_best_run.py[m[36m:[m97[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
        logger.info(f"Nombre de trades: {result.metrics.get('total_trades', 0)}")
                                                                               ^
[1m.\tests\save_best_run.py[m[36m:[m105[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
            logger.info(f"‚úÖ PNL confirm√©: {actual_pnl:.2f} ‚âà {expected_pnl:.2f}")
                                                                               ^
[1m.\tests\save_best_run.py[m[36m:[m107[36m:[m80[36m:[m [1m[31mE501[m line too long (95 > 79 characters)
            logger.warning(f"‚ö†Ô∏è PNL diff√©rent: {actual_pnl:.2f} vs attendu {expected_pnl:.2f}")
                                                                               ^
[1m.\tests\save_best_run.py[m[36m:[m108[36m:[m80[36m:[m [1m[31mE501[m line too long (104 > 79 characters)
            logger.warning("   Cela peut √™tre d√ª √† des donn√©es diff√©rentes ou des param√®tres manquants")
                                                                               ^
[1m.\tests\save_best_run.py[m[36m:[m126[36m:[m25[36m:[m [1m[31mF541[m f-string is missing placeholders
            logger.info(f"‚úÖ M√©tadonn√©es sauvegard√©es:")
                        ^
[1m.\tests\save_best_run.py[m[36m:[m128[36m:[m80[36m:[m [1m[31mE501[m line too long (88 > 79 characters)
            logger.info(f"   - Sharpe: {saved_meta.metrics.get('sharpe_ratio', 0):.4f}")
                                                                               ^
[1m.\tests\save_best_run.py[m[36m:[m138[36m:[m1[36m:[m [1m[31mE305[m expected 2 blank lines after class or function definition, found 1
if __name__ == "__main__":
^
[1m.\tests\setup_llama33_70b.py[m[36m:[m3[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
"""
Script de t√©l√©chargement et configuration de Llama-3.3-70B-Instruct pour Ollama.

Optimisations:
- Distribution sur 2 GPUs
- Offloading RAM DDR5 automatique
- Quantization Q4 (~40GB VRAM total)
- Configuration multi-GPU optimis√©e

Usage:
    python tools/setup_llama33_70b.py
"""
   
                                                                           ^
[1m.\tests\setup_llama33_70b.py[m[36m:[m200[36m:[m80[36m:[m [1m[31mE501[m line too long (204 > 79 characters)
    return f"""FROM {base_model}

# Param√®tres syst√®me - Optimisation multi-GPU
PARAMETER num_gpu {num_gpus}
PARAMETER num_thread 16
PARAMETER num_ctx 8192

# Param√®tres g√©n√©ration
PARAMETER temperature 0.7
PARAMETER top_p 0.9
PARAMETER top_k 40
PARAMETER repeat_penalty 1.1

# System prompt
SYSTEM You are Llama 3.3, a helpful AI assistant specialized in analyzing trading strategies and financial data. You provide clear, data-driven insights and identify potential risks in trading approaches.
"""
                                

                                             ^
[1m.\tests\setup_llama33_70b.py[m[36m:[m239[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
            print("   Configuration: multi-GPU, contexte 8K, optimis√© pour trading")
                                                                               ^
[1m.\tests\setup_llama33_70b.py[m[36m:[m336[36m:[m80[36m:[m [1m[31mE501[m line too long (94 > 79 characters)
        print(f"‚ùå Espace disque insuffisant ({available_gb:.1f} GB disponible, 40 GB requis)")
                                                                               ^
[1m.\tests\setup_llama33_70b.py[m[36m:[m343[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
        print("‚ö†Ô∏è  Aucun GPU d√©tect√© - Le mod√®le fonctionnera mais sera TR√àS lent")
                                                                               ^
[1m.\tests\setup_llama33_70b.py[m[36m:[m348[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
            print(f"   GPU {gpu['id']}: {gpu['name']} ({gpu['memory_gb']:.1f} GB)")
                                                                               ^
[1m.\tests\setup_llama33_70b.py[m[36m:[m353[36m:[m80[36m:[m [1m[31mE501[m line too long (86 > 79 characters)
        print(f"‚ö†Ô∏è  RAM limit√©e ({ram_gb:.1f} GB) - 32GB+ recommand√© pour offloading")
                                                                               ^
[1m.\tests\setup_llama33_70b.py[m[36m:[m379[36m:[m80[36m:[m [1m[31mE501[m line too long (86 > 79 characters)
        print("‚ö†Ô∏è  √âchec cr√©ation mod√®le optimis√© - Le mod√®le de base est utilisable")
                                                                               ^
[1m.\tests\setup_llama33_70b.py[m[36m:[m387[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
    model_to_test = CUSTOM_MODEL if is_model_installed(CUSTOM_MODEL) else BASE_MODEL
                                                                               ^
[1m.\tests\setup_llama33_70b.py[m[36m:[m399[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
    print("   2. Disponible pour les r√¥les: Critic (iter>=2), Validator (iter>=3)")
                                                                               ^
[1m.\tests\summary_all_tokens.py[m[36m:[m5[36m:[m80[36m:[m [1m[31mE501[m line too long (90 > 79 characters)
"""
Module-ID: summary_all_tokens

Purpose: R√©sum√© global couverture donn√©es pour tous les tokens - p√©riode backtest commune.

Role in pipeline: data summary

Key components: summarize_all_tokens(), affichage table glob

Inputs: Dossier parquet multi-tokens

Outputs: R√©sum√© par timeframe (min/max dates, tokens dispos)

Dependencies: pandas, pathlib, collections

Conventions: Timeframes: 1m, 5m, 15m, 1h, 4h, 1d

Read-if: Vue d'ensemble couverture globale todos tokens.

Skip-if: Analyse par token suffisante.
"""
   
                             

                                            ^
[1m.\tests\summary_all_tokens.py[m[36m:[m64[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
                    df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms')
                                                                               ^
[1m.\tests\summary_all_tokens.py[m[36m:[m81[36m:[m80[36m:[m [1m[31mE501[m line too long (91 > 79 characters)
    print(f"{'Timeframe':<10} {'Tokens':>7} {'Date d√©but MIN':<20} {'Date d√©but MAX':<20} "
                                                                               ^
[1m.\tests\summary_all_tokens.py[m[36m:[m82[36m:[m80[36m:[m [1m[31mE501[m line too long (93 > 79 characters)
          f"{'Date fin MIN':<20} {'Date fin MAX':<20} {'√âcart d√©but':>12} {'√âcart fin':>10}")
                                                                               ^
[1m.\tests\summary_all_tokens.py[m[36m:[m83[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
    print(f"{'-'*10} {'-'*7} {'-'*20} {'-'*20} {'-'*20} {'-'*20} {'-'*12} {'-'*10}")
                                                                               ^
[1m.\tests\summary_all_tokens.py[m[36m:[m106[36m:[m80[36m:[m [1m[31mE501[m line too long (103 > 79 characters)
            print(f"{tf:<10} {len(tokens):>7} {str(min_start.date()):<20} {str(max_start.date()):<20} "
                                                                               ^
[1m.\tests\summary_all_tokens.py[m[36m:[m130[36m:[m80[36m:[m [1m[31mE501[m line too long (103 > 79 characters)
                problems.append(f"‚ö†Ô∏è  {tf}: Dates de D√âBUT incoh√©rentes (√©cart de {start_diff} jours)")
                                                                               ^
[1m.\tests\summary_all_tokens.py[m[36m:[m135[36m:[m80[36m:[m [1m[31mE501[m line too long (99 > 79 characters)
                problems.append(f"‚ö†Ô∏è  {tf}: Dates de FIN incoh√©rentes (√©cart de {end_diff} jours)")
                                                                               ^
[1m.\tests\summary_all_tokens.py[m[36m:[m143[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
        print("‚úÖ Aucun probl√®me d√©tect√© - toutes les p√©riodes sont coh√©rentes!")
                                                                               ^
[1m.\tests\summary_all_tokens.py[m[36m:[m157[36m:[m80[36m:[m [1m[31mE501[m line too long (102 > 79 characters)
            print(f"‚ö†Ô∏è  Les timeframes longs (4h, 1d, 1w, 1M) manquent {gap_days} jours d'historique")
                                                                               ^
[1m.\tests\summary_all_tokens.py[m[36m:[m158[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
            print("   par rapport aux timeframes courts (3m, 5m, 15m, 30m, 1h)")
                                                                               ^
[1m.\tests\summary_all_tokens.py[m[36m:[m161[36m:[m80[36m:[m [1m[31mE501[m line too long (92 > 79 characters)
            print("   2. Relancer le t√©l√©chargement pour √©tendre les donn√©es jusqu'en 2020")
                                                                               ^
[1m.\tests\summary_all_tokens.py[m[36m:[m162[36m:[m80[36m:[m [1m[31mE501[m line too long (96 > 79 characters)
            print("   3. Commande: cd D:\\my_soft\\gestionnaire_telechargement_multi-timeframe")
                                                                               ^
[1m.\tests\summary_all_tokens.py[m[36m:[m163[36m:[m80[36m:[m [1m[31mE501[m line too long (86 > 79 characters)
            print("                python unified_data_historique_with_indicators.py")
                                                                               ^
[1m.\tests\test_all_fixes.py[m[36m:[m164[36m:[m80[36m:[m [1m[31mE501[m line too long (93 > 79 characters)
    equity_short = pd.Series(10000 + np.cumsum(np.random.randn(30) * 100), index=dates_short)
                                                                               ^
[1m.\tests\test_all_fixes.py[m[36m:[m167[36m:[m80[36m:[m [1m[31mE501[m line too long (92 > 79 characters)
    sharpe_short = sharpe_ratio(returns_short, method='daily_resample', equity=equity_short)
                                                                               ^
[1m.\tests\test_all_fixes.py[m[36m:[m168[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
    assert sharpe_short == 0.0, f"Expected 0.0 for <60 days, got {sharpe_short}"
                                                                               ^
[1m.\tests\test_all_fixes.py[m[36m:[m169[36m:[m80[36m:[m [1m[31mE501[m line too long (89 > 79 characters)
    print(f"   ‚úÖ Sharpe avec 30 jours equity = {sharpe_short} (garde daily_resample OK)")
                                                                               ^
[1m.\tests\test_all_fixes.py[m[36m:[m187[36m:[m80[36m:[m [1m[31mE501[m line too long (96 > 79 characters)
    df_1m = pd.read_csv('data/sample_data/BTCUSDT_1m_sample.csv', index_col=0, parse_dates=True)
                                                                               ^
[1m.\tests\test_all_fixes.py[m[36m:[m190[36m:[m80[36m:[m [1m[31mE501[m line too long (96 > 79 characters)
    df_1h = pd.read_csv('data/sample_data/BTCUSDT_1h_sample.csv', index_col=0, parse_dates=True)
                                                                               ^
[1m.\tests\test_all_fixes.py[m[36m:[m209[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
    print(f"   üìà 1m: {trades_1m} trades, PnL={pnl_1m:.2f}, Sharpe={sharpe_1m:.2f}")
                                                                               ^
[1m.\tests\test_all_fixes.py[m[36m:[m223[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
    print(f"   üìà 1h: {trades_1h} trades, PnL={pnl_1h:.2f}, Sharpe={sharpe_1h:.2f}")
                                                                               ^
[1m.\tests\test_autonomous_strategist_sweep.py[m[36m:[m31[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
        assert '"action": "continue|accept|stop|change_direction|sweep"' in prompt
                                                                               ^
[1m.\tests\test_autonomous_strategist_sweep.py[m[36m:[m223[36m:[m80[36m:[m [1m[31mE501[m line too long (87 > 79 characters)
        executor_mock.get_context_for_agent = Mock(return_value="Baseline: Sharpe=1.5")
                                                                               ^
[1m.\tests\test_autonomous_strategist_sweep.py[m[36m:[m229[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
        # Monkey-patch _run_backtest_with_gpu_optimization to avoid actual backtest
                                                                               ^
[1m.\tests\test_autonomous_strategist_sweep.py[m[36m:[m292[36m:[m80[36m:[m [1m[31mE501[m line too long (87 > 79 characters)
        executor_mock.get_context_for_agent = Mock(return_value="Baseline: Sharpe=1.5")
                                                                               ^
[1m.\tests\test_autonomous_strategist_sweep.py[m[36m:[m324[36m:[m80[36m:[m [1m[31mE501[m line too long (86 > 79 characters)
        assert session.final_status in ("success", "no_improvement", "max_iterations")
                                                                               ^
[1m.\tests\test_best_strategies_2024.py[m[36m:[m9[36m:[m1[36m:[m [1m[31mE402[m module level import not at top of file
from backtest.engine import BacktestEngine
^
[1m.\tests\test_best_strategies_2024.py[m[36m:[m10[36m:[m1[36m:[m [1m[31mE402[m module level import not at top of file
from data.loader import load_ohlcv
^
[1m.\tests\test_best_strategies_2024.py[m[36m:[m64[36m:[m1[36m:[m [1m[31mE303[m too many blank lines (3)
def test_bollinger_atr_optimized():
^
[1m.\tests\test_best_strategies_2024.py[m[36m:[m119[36m:[m1[36m:[m [1m[31mE303[m too many blank lines (3)
def test_top_5_ema():
^
[1m.\tests\test_best_strategies_2024.py[m[36m:[m163[36m:[m80[36m:[m [1m[31mE501[m line too long (93 > 79 characters)
        print(f"   PnL: ${m['total_pnl']:>10.2f} | Return: {m['total_return_pct']:>6.2f}% | "
                                                                               ^
[1m.\tests\test_best_strategies_2024.py[m[36m:[m164[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
              f"Sharpe: {m['sharpe_ratio']:>4.2f} | Trades: {m['total_trades']:>3}")
                                                                               ^
[1m.\tests\test_best_strategies_2024.py[m[36m:[m173[36m:[m80[36m:[m [1m[31mE501[m line too long (94 > 79 characters)
    sorted_results = sorted(results, key=lambda x: x[3].metrics['sharpe_ratio'], reverse=True)
                                                                               ^
[1m.\tests\test_best_strategies_2024.py[m[36m:[m178[36m:[m80[36m:[m [1m[31mE501[m line too long (92 > 79 characters)
              f"Sharpe: {m['sharpe_ratio']:>5.2f} | Return: {m['total_return_pct']:>6.2f}%")
                                                                               ^
[1m.\tests\test_best_strategies_2024.py[m[36m:[m184[36m:[m1[36m:[m [1m[31mE303[m too many blank lines (3)
def main():
^
[1m.\tests\test_best_strategies_2024.py[m[36m:[m211[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
    print(f"\n{'M√©trique':<20} {'EMA(21/38)':<15} {'BollingerATR':<15} {'Gagnant'}")
                                                                               ^
[1m.\tests\test_best_strategies_2024.py[m[36m:[m213[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
    print(f"{'PnL':<20} ${ema_m['total_pnl']:<14.2f} ${boll_m['total_pnl']:<14.2f} "
                                                                               ^
[1m.\tests\test_best_strategies_2024.py[m[36m:[m214[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
          f"{'EMA' if ema_m['total_pnl'] > boll_m['total_pnl'] else 'Bollinger'}")
                                                                               ^
[1m.\tests\test_best_strategies_2024.py[m[36m:[m215[36m:[m80[36m:[m [1m[31mE501[m line too long (101 > 79 characters)
    print(f"{'Return %':<20} {ema_m['total_return_pct']:<14.2f} {boll_m['total_return_pct']:<14.2f} "
                                                                               ^
[1m.\tests\test_best_strategies_2024.py[m[36m:[m216[36m:[m80[36m:[m [1m[31mE501[m line too long (96 > 79 characters)
          f"{'EMA' if ema_m['total_return_pct'] > boll_m['total_return_pct'] else 'Bollinger'}")
                                                                               ^
[1m.\tests\test_best_strategies_2024.py[m[36m:[m217[36m:[m80[36m:[m [1m[31mE501[m line too long (91 > 79 characters)
    print(f"{'Sharpe':<20} {ema_m['sharpe_ratio']:<14.2f} {boll_m['sharpe_ratio']:<14.2f} "
                                                                               ^
[1m.\tests\test_best_strategies_2024.py[m[36m:[m218[36m:[m80[36m:[m [1m[31mE501[m line too long (88 > 79 characters)
          f"{'EMA' if ema_m['sharpe_ratio'] > boll_m['sharpe_ratio'] else 'Bollinger'}")
                                                                               ^
[1m.\tests\test_best_strategies_2024.py[m[36m:[m219[36m:[m80[36m:[m [1m[31mE501[m line too long (95 > 79 characters)
    print(f"{'Win Rate %':<20} {ema_m['win_rate_pct']:<14.2f} {boll_m['win_rate_pct']:<14.2f} "
                                                                               ^
[1m.\tests\test_best_strategies_2024.py[m[36m:[m220[36m:[m80[36m:[m [1m[31mE501[m line too long (88 > 79 characters)
          f"{'EMA' if ema_m['win_rate_pct'] > boll_m['win_rate_pct'] else 'Bollinger'}")
                                                                               ^
[1m.\tests\test_best_strategies_2024.py[m[36m:[m221[36m:[m80[36m:[m [1m[31mE501[m line too long (100 > 79 characters)
    print(f"{'Profit Factor':<20} {ema_m['profit_factor']:<14.2f} {boll_m['profit_factor']:<14.2f} "
                                                                               ^
[1m.\tests\test_best_strategies_2024.py[m[36m:[m222[36m:[m80[36m:[m [1m[31mE501[m line too long (90 > 79 characters)
          f"{'EMA' if ema_m['profit_factor'] > boll_m['profit_factor'] else 'Bollinger'}")
                                                                               ^
[1m.\tests\test_best_strategies_2024.py[m[36m:[m223[36m:[m80[36m:[m [1m[31mE501[m line too long (101 > 79 characters)
    print(f"{'Max DD %':<20} {ema_m['max_drawdown_pct']:<14.2f} {boll_m['max_drawdown_pct']:<14.2f} "
                                                                               ^
[1m.\tests\test_best_strategies_2024.py[m[36m:[m224[36m:[m80[36m:[m [1m[31mE501[m line too long (106 > 79 characters)
          f"{'EMA' if abs(ema_m['max_drawdown_pct']) < abs(boll_m['max_drawdown_pct']) else 'Bollinger'}")
                                                                               ^
[1m.\tests\test_best_strategies_2024.py[m[36m:[m225[36m:[m80[36m:[m [1m[31mE501[m line too long (85 > 79 characters)
    print(f"{'Trades':<20} {ema_m['total_trades']:<14} {boll_m['total_trades']:<14} "
                                                                               ^
[1m.\tests\test_best_strategies_2024.py[m[36m:[m226[36m:[m80[36m:[m [1m[31mE501[m line too long (88 > 79 characters)
          f"{'EMA' if ema_m['total_trades'] > boll_m['total_trades'] else 'Bollinger'}")
                                                                               ^
[1m.\tests\test_bollinger_visualization.py[m[36m:[m62[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
    upper_old, middle_old, lower_old = bollinger_bands(ps_old, bb_period, bb_std)
                                                                               ^
[1m.\tests\test_bollinger_visualization.py[m[36m:[m63[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
    upper_new, middle_new, lower_new = bollinger_bands(ps_new, bb_period, bb_std)
                                                                               ^
[1m.\tests\test_bollinger_visualization.py[m[36m:[m97[36m:[m80[36m:[m [1m[31mE501[m line too long (97 > 79 characters)
        print(f"\n  üéØ SUCC√àS! Les bandes sont maintenant {width_new/width_old:.1f}x plus larges")
                                                                               ^
[1m.\tests\test_bollinger_visualization.py[m[36m:[m98[36m:[m80[36m:[m [1m[31mE501[m line too long (85 > 79 characters)
        print("     L'impact d'une p√©riode √©lev√©e (42) est VISIBLE sur le graphique")
                                                                               ^
[1m.\tests\test_bollinger_visualization.py[m[36m:[m112[36m:[m80[36m:[m [1m[31mE501[m line too long (100 > 79 characters)
        print(f"\n  ‚úÖ Une p√©riode de 42 produit des bandes {width_new/width_std:.1f}x plus larges!")
                                                                               ^
[1m.\tests\test_budget_iterations.py[m[36m:[m47[36m:[m80[36m:[m [1m[31mE501[m line too long (87 > 79 characters)
        executor_mock.get_context_for_agent = Mock(return_value="Baseline: Sharpe=1.5")
                                                                               ^
[1m.\tests\test_budget_iterations.py[m[36m:[m111[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
        # Le total_combinations_tested devrait √™tre: 1 (baseline) + 20 (sweep) = 21
                                                                               ^
[1m.\tests\test_budget_iterations.py[m[36m:[m116[36m:[m80[36m:[m [1m[31mE501[m line too long (86 > 79 characters)
        assert session.final_status in ("success", "no_improvement", "max_iterations")
                                                                               ^
[1m.\tests\test_budget_iterations.py[m[36m:[m141[36m:[m80[36m:[m [1m[31mE501[m line too long (87 > 79 characters)
        executor_mock.get_context_for_agent = Mock(return_value="Baseline: Sharpe=1.5")
                                                                               ^
[1m.\tests\test_budget_iterations.py[m[36m:[m159[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
        # Mock _get_llm_decision pour demander 5 sweeps (d√©passe la limite de 3)
                                                                               ^
[1m.\tests\test_budget_iterations.py[m[36m:[m196[36m:[m80[36m:[m [1m[31mE501[m line too long (98 > 79 characters)
        assert session.final_status in ("sweep_limit_reached", "no_improvement", "max_iterations")
                                                                               ^
[1m.\tests\test_budget_iterations.py[m[36m:[m362[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
        # V√©rifier que le budget a d√©clench√© un arr√™t (transition vers REJECTED)
                                                                               ^
[1m.\tests\test_bug_fixes.py[m[36m:[m4[36m:[m80[36m:[m [1m[31mE501[m line too long (97 > 79 characters)
"""
Module-ID: test_bug_fixes

Purpose: Test validation corrections bugs - passage param√®tres, mapping bb_std, perf ProcessPool.

Role in pipeline: testing

Key components: BollingerATRStrategy param mapping, engine.run(), ProcessPoolExecutor

Inputs: Donn√©es synth√©tiques, grille param√©tres

Outputs: V√©rification mappings corrects et perf acceptable

Dependencies: backtest.engine, strategies.bollinger_atr

Conventions: Tests de r√©gressions pour bugs fix√©s

Read-if: V√©rifier bugs fix√©s ne r√©apparus.

Skip-if: Bugs d√©j√† r√©solu et test√©s.
"""
   
                         

                                                ^
[1m.\tests\test_bug_fixes.py[m[36m:[m8[36m:[m80[36m:[m [1m[31mE501[m line too long (85 > 79 characters)
"""
Module-ID: test_bug_fixes

Purpose: Test validation corrections bugs - passage param√®tres, mapping bb_std, perf ProcessPool.

Role in pipeline: testing

Key components: BollingerATRStrategy param mapping, engine.run(), ProcessPoolExecutor

Inputs: Donn√©es synth√©tiques, grille param√©tres

Outputs: V√©rification mappings corrects et perf acceptable

Dependencies: backtest.engine, strategies.bollinger_atr

Conventions: Tests de r√©gressions pour bugs fix√©s

Read-if: V√©rifier bugs fix√©s ne r√©apparus.

Skip-if: Bugs d√©j√† r√©solu et test√©s.
"""
   
                         

                                                ^
[1m.\tests\test_bug_fixes.py[m[36m:[m48[36m:[m80[36m:[m [1m[31mE501[m line too long (86 > 79 characters)
    indicator_params = engine._extract_indicator_params(strategy, "bollinger", params)
                                                                               ^
[1m.\tests\test_bug_fixes.py[m[36m:[m54[36m:[m80[36m:[m [1m[31mE501[m line too long (96 > 79 characters)
    assert "std_dev" in indicator_params, "‚ùå √âCHEC: 'std_dev' manquant dans param√®tres extraits"
                                                                               ^
[1m.\tests\test_bug_fixes.py[m[36m:[m55[36m:[m80[36m:[m [1m[31mE501[m line too long (109 > 79 characters)
    assert indicator_params["std_dev"] == 2.5, f"‚ùå √âCHEC: std_dev={indicator_params['std_dev']}, attendu 2.5"
                                                                               ^
[1m.\tests\test_bug_fixes.py[m[36m:[m56[36m:[m80[36m:[m [1m[31mE501[m line too long (104 > 79 characters)
    assert indicator_params["period"] == 20, f"‚ùå √âCHEC: period={indicator_params['period']}, attendu 20"
                                                                               ^
[1m.\tests\test_bug_fixes.py[m[36m:[m63[36m:[m1[36m:[m [1m[31mE303[m too many blank lines (3)
def test_grid_param_passing():
^
[1m.\tests\test_bug_fixes.py[m[36m:[m64[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
    """Test 2: V√©rifier que tous les param√®tres UI sont transmis √† la grille."""
                                                                               ^
[1m.\tests\test_bug_fixes.py[m[36m:[m91[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
        values = list(range(int(pr["min"]), int(pr["max"]) + 1, int(pr["step"])))
                                                                               ^
[1m.\tests\test_bug_fixes.py[m[36m:[m107[36m:[m80[36m:[m [1m[31mE501[m line too long (86 > 79 characters)
    assert len(param_grid) == 3, f"‚ùå √âCHEC: {len(param_grid)} combinaisons, attendu 3"
                                                                               ^
[1m.\tests\test_bug_fixes.py[m[36m:[m111[36m:[m80[36m:[m [1m[31mE501[m line too long (95 > 79 characters)
        assert p["bb_std"] == 2.5, f"‚ùå √âCHEC: bb_std={p['bb_std']} dans combo {i}, attendu 2.5"
                                                                               ^
[1m.\tests\test_bug_fixes.py[m[36m:[m112[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
        assert "atr_period" in p, f"‚ùå √âCHEC: atr_period manquant dans combo {i}"
                                                                               ^
[1m.\tests\test_bug_fixes.py[m[36m:[m113[36m:[m80[36m:[m [1m[31mE501[m line too long (105 > 79 characters)
        assert p["atr_period"] == 14, f"‚ùå √âCHEC: atr_period={p['atr_period']} dans combo {i}, attendu 14"
                                                                               ^
[1m.\tests\test_bug_fixes.py[m[36m:[m114[36m:[m80[36m:[m [1m[31mE501[m line too long (105 > 79 characters)
        assert "leverage" not in p, f"‚ùå √âCHEC: leverage ne doit pas √™tre optimis√© par d√©faut (combo {i})"
                                                                               ^
[1m.\tests\test_bug_fixes.py[m[36m:[m121[36m:[m1[36m:[m [1m[31mE303[m too many blank lines (3)
def test_backtest_results_vary():
^
[1m.\tests\test_bug_fixes.py[m[36m:[m122[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
    """Test 3: V√©rifier que les r√©sultats varient avec des param√®tres diff√©rents."""
                                                                               ^
[1m.\tests\test_bug_fixes.py[m[36m:[m149[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
        # Cr√©er un DataFrame l√©g√®rement diff√©rent pour chaque test (√©viter cache)
                                                                               ^
[1m.\tests\test_bug_fixes.py[m[36m:[m181[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
        print(f"‚ùå √âCHEC: Tous les r√©sultats sont identiques ({pnl_values[0]:.2f})")
                                                                               ^
[1m.\tests\test_bug_fixes.py[m[36m:[m184[36m:[m80[36m:[m [1m[31mE501[m line too long (86 > 79 characters)
        print(f"‚úÖ SUCC√àS: Les r√©sultats varient ({len(unique_pnls)} valeurs uniques)")
                                                                               ^
[1m.\tests\test_bug_fixes.py[m[36m:[m190[36m:[m1[36m:[m [1m[31mE303[m too many blank lines (3)
def _simple_task(x):
^
[1m.\tests\test_bug_fixes.py[m[36m:[m196[36m:[m1[36m:[m [1m[31mE303[m too many blank lines (3)
def test_performance_comparison():
^
[1m.\tests\test_bug_fixes.py[m[36m:[m197[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
    """Test 4: Comparer performance s√©quentiel vs multi-process (simulation)."""
                                                                               ^
[1m.\tests\test_bug_fixes.py[m[36m:[m202[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
    # Note: Ce test ne peut pas vraiment tester ProcessPoolExecutor avec backtests
                                                                               ^
[1m.\tests\test_bug_fixes.py[m[36m:[m203[36m:[m80[36m:[m [1m[31mE501[m line too long (97 > 79 characters)
    # car il n√©cessite l'UI Streamlit. On v√©rifie juste que l'import et le pickling fonctionnent.
                                                                               ^
[1m.\tests\test_bug_fixes.py[m[36m:[m213[36m:[m80[36m:[m [1m[31mE501[m line too long (91 > 79 characters)
        assert results == [0, 2, 4, 6, 8], "‚ùå √âCHEC: ProcessPoolExecutor ne fonctionne pas"
                                                                               ^
[1m.\tests\test_bug_fixes.py[m[36m:[m222[36m:[m80[36m:[m [1m[31mE501[m line too long (103 > 79 characters)
        print("‚ö†Ô∏è  Note: ui.main._run_backtest_multiprocess non disponible (normal si UI non charg√©e)")
                                                                               ^
[1m.\tests\test_bug_fixes.py[m[36m:[m231[36m:[m1[36m:[m [1m[31mE303[m too many blank lines (3)
def main():
^
[1m.\tests\test_bug_fixes.py[m[36m:[m260[36m:[m1[36m:[m [1m[31mE303[m too many blank lines (3)
if __name__ == "__main__":
^
[1m.\tests\test_cpu_gpu_parallel.py[m[36m:[m4[36m:[m80[36m:[m [1m[31mE501[m line too long (91 > 79 characters)
"""
Test CPU + GPU parall√®le
V√©rifie que BacktestEngine utilise le GPU et ProcessPoolExecutor utilise tous les CPU cores
"""
   
                        
                                                  ^
[1m.\tests\test_cpu_gpu_parallel.py[m[36m:[m51[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
    result = engine_gpu.run(df, "ema_cross", {"fast_period": 10, "slow_period": 21})
                                                                               ^
[1m.\tests\test_cpu_gpu_parallel.py[m[36m:[m76[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
    result = engine.run(df, "ema_cross", {"fast_period": fast, "slow_period": slow})
                                                                               ^
[1m.\tests\test_cpu_gpu_parallel.py[m[36m:[m93[36m:[m80[36m:[m [1m[31mE501[m line too long (88 > 79 characters)
    param_grid = [(fast, slow) for fast in range(5, 15, 2) for slow in range(20, 40, 5)]
                                                                               ^
[1m.\tests\test_cpu_gpu_parallel.py[m[36m:[m112[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
    sorted_results = sorted(results, key=lambda x: x["sharpe"], reverse=True)[:3]
                                                                               ^
[1m.\tests\test_cpu_gpu_parallel.py[m[36m:[m114[36m:[m80[36m:[m [1m[31mE501[m line too long (117 > 79 characters)
        print(f"   {i}. {res['params']}: Sharpe={res['sharpe']:.2f}, Trades={res['trades']}, Device={res['device']}")
                                                                               ^
[1m.\tests\test_emergency_stop.py[m[36m:[m35[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
    assert not handler.is_stop_requested(), "Flag devrait √™tre False apr√®s reset"
                                                                               ^
[1m.\tests\test_emergency_stop.py[m[36m:[m85[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
        print(f"   ‚Ä¢ Composants nettoy√©s: {len(final_stats['components_cleaned'])}")
                                                                               ^
[1m.\tests\test_equity_mtm.py[m[36m:[m59[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
    print("‚úÖ Mark-to-market fonctionne (equity augmente pendant position ouverte)")
                                                                               ^
[1m.\tests\test_facade_warmup.py[m[36m:[m4[36m:[m80[36m:[m [1m[31mE501[m line too long (95 > 79 characters)
"""
Module-ID: tests.test_facade_warmup

Purpose: Valider warmup dans BackendFacade (detection fen√™tres courtes, InsufficientDataError).

Role in pipeline: testing

Key components: test_warmup_validation, test_insufficient_data, fixtures facade/ohlcv_data

Inputs: Mock DataFrame OHLCV, BacktestRequest avec validations

Outputs: Pass/Fail assertions sur erreurs data

Dependencies: pytest, unittest.mock, backtest.facade, backtest.errors

Conventions: Fixtures pytest; mocks optionnels; tests isol√©s data.

Read-if: Modification warmup logic ou validation data.

Skip-if: Tests unitaires non critiques.
"""
   
                                   

                                      ^
[1m.\tests\test_facade_warmup.py[m[36m:[m8[36m:[m80[36m:[m [1m[31mE501[m line too long (90 > 79 characters)
"""
Module-ID: tests.test_facade_warmup

Purpose: Valider warmup dans BackendFacade (detection fen√™tres courtes, InsufficientDataError).

Role in pipeline: testing

Key components: test_warmup_validation, test_insufficient_data, fixtures facade/ohlcv_data

Inputs: Mock DataFrame OHLCV, BacktestRequest avec validations

Outputs: Pass/Fail assertions sur erreurs data

Dependencies: pytest, unittest.mock, backtest.facade, backtest.errors

Conventions: Fixtures pytest; mocks optionnels; tests isol√©s data.

Read-if: Modification warmup logic ou validation data.

Skip-if: Tests unitaires non critiques.
"""
   
                                   

                                      ^
[1m.\tests\test_facade_warmup.py[m[36m:[m97[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
        # Mock: premi√®re fois avec fen√™tre courte (ignor√©), deuxi√®me fois sans dates
                                                                               ^
[1m.\tests\test_facade_warmup.py[m[36m:[m116[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
        mock_load.assert_called_once_with("BTCUSDT", "1h", start=None, end=None)
                                                                               ^
[1m.\tests\test_facade_warmup.py[m[36m:[m145[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
        mock_load.assert_called_once_with("BTCUSDT", "1h", start=start, end=end)
                                                                               ^
[1m.\tests\test_facade_warmup.py[m[36m:[m186[36m:[m80[36m:[m [1m[31mE501[m line too long (86 > 79 characters)
def test_validate_dataframe_with_warmup_insufficient(facade, insufficient_ohlcv_data):
                                                                               ^
[1m.\tests\test_facade_warmup.py[m[36m:[m200[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
def test_validate_dataframe_without_warmup_check(facade, insufficient_ohlcv_data):
                                                                               ^
[1m.\tests\test_gardes_adaptatifs.py[m[36m:[m4[36m:[m80[36m:[m [1m[31mE501[m line too long (87 > 79 characters)
"""
Module-ID: test_gardes_adaptatifs

Purpose: Test gardes adaptatifs pour backtests courts - MIN_SAMPLES et volatilt√© seuil.

Role in pipeline: testing

Key components: sharpe_ratio adaptatif, seuils < 30 jours

Inputs: Backtests longs et courts (< 30 jours)

Outputs: V√©rification MIN_SAMPLES=2 et min_vol adapt√©e pour courts

Dependencies: backtest.performance, utils.observability

Conventions: < 30 jours = court; MIN_SAMPLES r√©duit

Read-if: V√©rifier gardes adaptatifs backtests courts.

Skip-if: Backtests toujours longs.
"""
   
                                 

                                        ^
[1m.\tests\test_gardes_adaptatifs.py[m[36m:[m38[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
dates_long = pd.date_range(start="2025-01-01", periods=40, freq="1D")  # 40 jours
                                                                               ^
[1m.\tests\test_gardes_adaptatifs.py[m[36m:[m44[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
run_id_long = generate_run_id(strategy="test_long", symbol="BTC", timeframe="1d")
                                                                               ^
[1m.\tests\test_gardes_adaptatifs.py[m[36m:[m49[36m:[m80[36m:[m [1m[31mE501[m line too long (101 > 79 characters)
# Avec seulement 2 returns MAIS equity compl√®te (40 jours), devrait return 0.0 (MIN_SAMPLES=3 strict)
                                                                               ^
[1m.\tests\test_gardes_adaptatifs.py[m[36m:[m55[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
    equity=equity_long,  # Equity compl√®te (40 jours) pour d√©tection dur√©e correcte
                                                                               ^
[1m.\tests\test_gardes_adaptatifs.py[m[36m:[m61[36m:[m80[36m:[m [1m[31mE501[m line too long (105 > 79 characters)
assert sharpe_long == 0.0, f"Expected 0.0 but got {sharpe_long} (gardes devraient √™tre stricts pour 40j)"
                                                                               ^
[1m.\tests\test_gardes_adaptatifs.py[m[36m:[m68[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
dates_short = pd.date_range(start="2025-01-01", periods=20, freq="1D")  # 20 jours
                                                                               ^
[1m.\tests\test_gardes_adaptatifs.py[m[36m:[m74[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
run_id_short = generate_run_id(strategy="test_short", symbol="BTC", timeframe="1d")
                                                                               ^
[1m.\tests\test_gardes_adaptatifs.py[m[36m:[m85[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
    equity=equity_short,  # Equity compl√®te (20 jours) pour d√©tection dur√©e correcte
                                                                               ^
[1m.\tests\test_gardes_adaptatifs.py[m[36m:[m93[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
    print("‚ö†Ô∏è  Sharpe = 0.0 malgr√© gardes assouplis (peut-√™tre std trop faible)")
                                                                               ^
[1m.\tests\test_gardes_adaptatifs.py[m[36m:[m94[36m:[m80[36m:[m [1m[31mE501[m line too long (85 > 79 characters)
# Note : Peut √™tre 0.0 si std trop faible, mais ne devrait PAS fail sur min_samples=3
                                                                               ^
[1m.\tests\test_gardes_adaptatifs.py[m[36m:[m105[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
print(f"\nSharpe avec tous les returns (backtest court): {sharpe_short_all:.4f}")
                                                                               ^
[1m.\tests\test_gardes_adaptatifs.py[m[36m:[m116[36m:[m80[36m:[m [1m[31mE501[m line too long (96 > 79 characters)
dates_few = pd.date_range(start="2025-01-01", periods=50, freq="1D")  # Long mais peu de samples
                                                                               ^
[1m.\tests\test_gardes_adaptatifs.py[m[36m:[m139[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
print("‚úÖ Backtest long (> 30j) : Gardes stricts (MIN_SAMPLES=3, min_vol=0.001)")
                                                                               ^
[1m.\tests\test_gardes_adaptatifs.py[m[36m:[m140[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
print("‚úÖ Backtest court (< 30j) : Gardes assouplis (MIN_SAMPLES=2, min_vol=0.0001)")
                                                                               ^
[1m.\tests\test_grid_search_trades.py[m[36m:[m21[36m:[m80[36m:[m [1m[31mE501[m line too long (94 > 79 characters)
    df = pd.read_csv('data/sample_data/BTCUSDT_1h_6months.csv', index_col=0, parse_dates=True)
                                                                               ^
[1m.\tests\test_grid_search_trades.py[m[36m:[m45[36m:[m80[36m:[m [1m[31mE501[m line too long (85 > 79 characters)
    result = engine.run(df=df, strategy='atr_channel', params=params, timeframe='1h')
                                                                               ^
[1m.\tests\test_grid_ui_simulation.py[m[36m:[m29[36m:[m80[36m:[m [1m[31mE501[m line too long (94 > 79 characters)
    df = pd.read_csv('data/sample_data/BTCUSDT_1h_6months.csv', index_col=0, parse_dates=True)
                                                                               ^
[1m.\tests\test_grid_ui_simulation.py[m[36m:[m96[36m:[m80[36m:[m [1m[31mE501[m line too long (91 > 79 characters)
logger.info(f"Lancement de {len(param_grid)} backtests en parall√®le (workers={n_workers})")
                                                                               ^
[1m.\tests\test_grid_ui_simulation.py[m[36m:[m115[36m:[m80[36m:[m [1m[31mE501[m line too long (109 > 79 characters)
            logger.info(f"Progression: {completed}/{len(param_grid)} ({completed/len(param_grid)*100:.0f}%)")
                                                                               ^
[1m.\tests\test_grid_ui_simulation.py[m[36m:[m134[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
    logger.info(f"   Premi√®res valeurs: {results_df['trades'].head(10).tolist()}")
                                                                               ^
[1m.\tests\test_grid_ui_simulation.py[m[36m:[m135[36m:[m80[36m:[m [1m[31mE501[m line too long (136 > 79 characters)
    logger.info(f"   Stats: min={results_df['trades'].min()}, max={results_df['trades'].max()}, mean={results_df['trades'].mean():.2f}")
                                                                               ^
[1m.\tests\test_grid_ui_simulation.py[m[36m:[m139[36m:[m80[36m:[m [1m[31mE501[m line too long (90 > 79 characters)
    fractional = [x for x in trades_values if isinstance(x, float) and not x.is_integer()]
                                                                               ^
[1m.\tests\test_grid_ui_simulation.py[m[36m:[m141[36m:[m80[36m:[m [1m[31mE501[m line too long (102 > 79 characters)
        logger.warning(f"   ‚ö†Ô∏è  {len(fractional)} valeurs fractionnaires d√©tect√©es: {fractional[:5]}")
                                                                               ^
[1m.\tests\test_grid_ui_simulation.py[m[36m:[m185[36m:[m80[36m:[m [1m[31mE501[m line too long (102 > 79 characters)
    print(valid_results[['params', 'sharpe', 'total_pnl', 'trades', 'win_rate']].head(10).to_string())
                                                                               ^
[1m.\tests\test_indicator_bank_cache.py[m[36m:[m4[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
"""
Module-ID: tests.test_indicator_bank_cache

Purpose: Tester cache IndicatorBank (hit/miss, CPU vs GPU distinction, cl√©s cache).

Role in pipeline: testing

Key components: test_* functions, create_sample_data fixture

Inputs: IndicatorBank, OHLCV DataFrame, backend (CPU/GPU), params

Outputs: Cache keys, hit_rate, persisted cache files

Dependencies: pytest, pandas, numpy, data.indicator_bank

Conventions: Cache distingue CPU/GPU par cl√©; hit_rate tracking; file-based persistence.

Read-if: Modification cache key generation ou backend distinction.

Skip-if: Tests cache non critiques.
"""
   
                                          

                               ^
[1m.\tests\test_indicator_bank_cache.py[m[36m:[m16[36m:[m80[36m:[m [1m[31mE501[m line too long (88 > 79 characters)
"""
Module-ID: tests.test_indicator_bank_cache

Purpose: Tester cache IndicatorBank (hit/miss, CPU vs GPU distinction, cl√©s cache).

Role in pipeline: testing

Key components: test_* functions, create_sample_data fixture

Inputs: IndicatorBank, OHLCV DataFrame, backend (CPU/GPU), params

Outputs: Cache keys, hit_rate, persisted cache files

Dependencies: pytest, pandas, numpy, data.indicator_bank

Conventions: Cache distingue CPU/GPU par cl√©; hit_rate tracking; file-based persistence.

Read-if: Modification cache key generation ou backend distinction.

Skip-if: Tests cache non critiques.
"""
   
                                          

                               ^
[1m.\tests\test_indicator_bank_cache.py[m[36m:[m65[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
        key_cpu = bank._generate_key("rsi", {"period": 14, "_backend": "cpu"}, df)
                                                                               ^
[1m.\tests\test_indicator_bank_cache.py[m[36m:[m66[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
        key_gpu = bank._generate_key("rsi", {"period": 14, "_backend": "gpu"}, df)
                                                                               ^
[1m.\tests\test_indicator_bank_cache.py[m[36m:[m69[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
        assert key_cpu[0] != key_gpu[0], "Cl√©s doivent √™tre diff√©rentes CPU vs GPU"
                                                                               ^
[1m.\tests\test_indicator_bank_cache.py[m[36m:[m72[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
        assert key_cpu[1] != key_gpu[1], "Hash params doivent diff√©rer CPU vs GPU"
                                                                               ^
[1m.\tests\test_indicator_bank_cache.py[m[36m:[m91[36m:[m80[36m:[m [1m[31mE501[m line too long (91 > 79 characters)
        key_cpu_explicit = bank._generate_key("rsi", {"period": 14, "_backend": "cpu"}, df)
                                                                               ^
[1m.\tests\test_indicator_bank_cache.py[m[36m:[m93[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
        assert key[0] == key_cpu_explicit[0], "Petites donn√©es ‚Üí auto-d√©tection CPU"
                                                                               ^
[1m.\tests\test_indicator_bank_cache.py[m[36m:[m98[36m:[m80[36m:[m [1m[31mE501[m line too long (88 > 79 characters)
        """
        Test : Avec grandes donn√©es (>= 5000), le backend doit √™tre 'gpu' si disponible.
        """
           
                                                                   ^
[1m.\tests\test_indicator_bank_cache.py[m[36m:[m118[36m:[m80[36m:[m [1m[31mE501[m line too long (96 > 79 characters)
        assert key[0] == key_expected[0], f"Grandes donn√©es ‚Üí auto-d√©tection {expected_backend}"
                                                                               ^
[1m.\tests\test_indicator_bank_cache.py[m[36m:[m142[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
        assert cached_cpu is None, "Cache GPU ne doit pas √™tre utilis√© pour CPU"
                                                                               ^
[1m.\tests\test_indicator_bank_cache.py[m[36m:[m171[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
        assert cached_cpu.dtype == np.float64, "dtype doit √™tre pr√©serv√© (float64)"
                                                                               ^
[1m.\tests\test_indicator_bank_cache.py[m[36m:[m206[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
        print(f"\n[4/5] ‚ùå test_cache_no_collision_same_params_diff_backend: {e}")
                                                                               ^
[1m.\tests\test_jour1_diagnostic.py[m[36m:[m4[36m:[m80[36m:[m [1m[31mE501[m line too long (112 > 79 characters)
"""
Module-ID: test_jour1_diagnostic

Purpose: Test infrastructure logging JOUR 1 - diagnostic sharpe_ratio et calculate_equity_curve logs structur√©s.

Role in pipeline: testing

Key components: sharpe_ratio logs, equity_curve logs, run_id correlation

Inputs: Returns synth√©tiques, equity curve

Outputs: V√©rification logs: SHARPE_INPUT, SANITY, CALC, OUTPUT, EQUITY_SERIES_META, DD, RECONCILE

Dependencies: utils.observability, backtest.performance

Conventions: Logs stock√©s par run_id

Read-if: V√©rifier infrastructure logging JOUR 1.

Skip-if: Infrastructure stabil√©e.
"""
   
                                

                                         ^
[1m.\tests\test_jour1_diagnostic.py[m[36m:[m12[36m:[m80[36m:[m [1m[31mE501[m line too long (97 > 79 characters)
"""
Module-ID: test_jour1_diagnostic

Purpose: Test infrastructure logging JOUR 1 - diagnostic sharpe_ratio et calculate_equity_curve logs structur√©s.

Role in pipeline: testing

Key components: sharpe_ratio logs, equity_curve logs, run_id correlation

Inputs: Returns synth√©tiques, equity curve

Outputs: V√©rification logs: SHARPE_INPUT, SANITY, CALC, OUTPUT, EQUITY_SERIES_META, DD, RECONCILE

Dependencies: utils.observability, backtest.performance

Conventions: Logs stock√©s par run_id

Read-if: V√©rifier infrastructure logging JOUR 1.

Skip-if: Infrastructure stabil√©e.
"""
   
                                

                                         ^
[1m.\tests\test_jour1_diagnostic.py[m[36m:[m47[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
run_id = generate_run_id(strategy="test", symbol="BTC", timeframe="1h", seed=123)
                                                                               ^
[1m.\tests\test_jour1_diagnostic.py[m[36m:[m69[36m:[m80[36m:[m [1m[31mE501[m line too long (91 > 79 characters)
print("   V√©rifiez les logs pour: SHARPE_INPUT, SHARPE_SANITY, SHARPE_CALC, SHARPE_OUTPUT")
                                                                               ^
[1m.\tests\test_jour1_diagnostic.py[m[36m:[m97[36m:[m80[36m:[m [1m[31mE501[m line too long (92 > 79 characters)
equity_curve = calculate_equity_curve(df, trades_df, initial_capital=10000.0, run_id=run_id)
                                                                               ^
[1m.\tests\test_jour1_diagnostic.py[m[36m:[m99[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
print(f"Equity courbe: len={len(equity_curve)}, final={equity_curve.iloc[-1]:.2f}")
                                                                               ^
[1m.\tests\test_jour1_diagnostic.py[m[36m:[m101[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
print("   V√©rifiez les logs pour: EQUITY_SERIES_META, EQUITY_DD, EQUITY_COMPLETE")
                                                                               ^
[1m.\tests\test_jour1_diagnostic.py[m[36m:[m143[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
print("‚úÖ SHARPE_ZERO warning devrait √™tre dans les logs (reason=low_volatility)")
                                                                               ^
[1m.\tests\test_jour1_diagnostic.py[m[36m:[m155[36m:[m80[36m:[m [1m[31mE501[m line too long (86 > 79 characters)
print("   - Cherchez: grep 'SHARPE_INPUT\\|SHARPE_SANITY\\|SHARPE_OUTPUT' logs/*.log")
                                                                               ^
[1m.\tests\test_jour1_diagnostic.py[m[36m:[m156[36m:[m80[36m:[m [1m[31mE501[m line too long (90 > 79 characters)
print("   - Cherchez: grep 'EQUITY_SERIES_META\\|EQUITY_DD\\|EQUITY_COMPLETE' logs/*.log")
                                                                               ^
[1m.\tests\test_llama33_70b.py[m[36m:[m72[36m:[m80[36m:[m [1m[31mE501[m line too long (97 > 79 characters)
            print(f"   Allow heavy apr√®s it√©ration: {config.critic.allow_heavy_after_iteration}")
                                                                               ^
[1m.\tests\test_llama33_70b.py[m[36m:[m81[36m:[m80[36m:[m [1m[31mE501[m line too long (100 > 79 characters)
            print(f"   Allow heavy apr√®s it√©ration: {config.validator.allow_heavy_after_iteration}")
                                                                               ^
[1m.\tests\test_llama33_70b.py[m[36m:[m117[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
        model_critic = config.get_model("critic", iteration=3, allow_heavy=True)
                                                                               ^
[1m.\tests\test_llama33_70b.py[m[36m:[m121[36m:[m80[36m:[m [1m[31mE501[m line too long (86 > 79 characters)
        model_validator = config.get_model("validator", iteration=4, allow_heavy=True)
                                                                               ^
[1m.\tests\test_llama33_70b.py[m[36m:[m122[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
        print(f"   S√©lection Validator (iter=4, heavy=True): {model_validator}")
                                                                               ^
[1m.\tests\test_llama33_70b.py[m[36m:[m136[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
        from agents.ollama_manager import is_ollama_available, list_ollama_models
                                                                               ^
[1m.\tests\test_llama33_70b.py[m[36m:[m237[36m:[m80[36m:[m [1m[31mE501[m line too long (117 > 79 characters)
        print(f"   VRAM utilis√©e: {info.get('cupy_memory_total_gb', 0) - info.get('cupy_memory_free_gb', 0):.2f} GB")
                                                                               ^
[1m.\tests\test_llama33_70b.py[m[36m:[m265[36m:[m80[36m:[m [1m[31mE501[m line too long (98 > 79 characters)
        print(f"   √âtat: was_loaded={state.was_loaded}, unload_time={state.unload_time_ms:.0f}ms")
                                                                               ^
[1m.\tests\test_llama33_70b.py[m[36m:[m292[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
    print("   - Le mod√®le sera automatiquement s√©lectionn√© pour Critic (iter>=2)")
                                                                               ^
[1m.\tests\test_llama33_70b.py[m[36m:[m294[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
    print("   - Utilisez allow_heavy=True pour forcer l'utilisation d√®s iter=1")
                                                                               ^
[1m.\tests\test_llama33_70b.py[m[36m:[m302[36m:[m80[36m:[m [1m[31mE501[m line too long (85 > 79 characters)
    print("   - Utilisez gpu_compute_context() pour lib√©rer la VRAM avant backtests")
                                                                               ^
[1m.\tests\test_llama33_70b.py[m[36m:[m364[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
    print(f"\nüìä Total: {passed}/{total} r√©ussis, {failed} √©checs, {skipped} skip")
                                                                               ^
[1m.\tests\test_llama33_70b.py[m[36m:[m381[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
            print("   - V√©rifiez que model_config.py a √©t√© modifi√© correctement")
                                                                               ^
[1m.\tests\test_llama33_70b.py[m[36m:[m383[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
            print("   - Installez le mod√®le: python tools/setup_llama33_70b.py")
                                                                               ^
[1m.\tests\test_llama33_backtest.py[m[36m:[m6[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
"""
Script de test: Llama 3.3 70B dans un backtest r√©el avec agents.

Objectif:
- Tester l'int√©gration du mod√®le Llama 3.3 70B dans un workflow de backtest complet
- Mesurer les temps de r√©ponse r√©els pour analyses complexes
- V√©rifier la distribution GPU pendant l'inf√©rence
- Valider le comportement du mod√®le comme Critic

Usage:
    python tools/test_llama33_backtest.py

Options:
    --iterations N      Nombre max d'it√©rations (d√©faut: 3)
    --force-heavy       Forcer l'utilisation de Llama 3.3 d√®s iter=1
    --strategy NAME     Strat√©gie √† tester (d√©faut: ema_cross)
    --monitor-gpu       Monitorer le GPU en continu
"""
   
                                                                

         ^
[1m.\tests\test_llama33_backtest.py[m[36m:[m29[36m:[m1[36m:[m [1m[31mE402[m module level import not at top of file
import numpy as np
^
[1m.\tests\test_llama33_backtest.py[m[36m:[m30[36m:[m1[36m:[m [1m[31mE402[m module level import not at top of file
import pandas as pd
^
[1m.\tests\test_llama33_backtest.py[m[36m:[m32[36m:[m1[36m:[m [1m[31mE402[m module level import not at top of file
from agents.integration import create_orchestrator_with_backtest
^
[1m.\tests\test_llama33_backtest.py[m[36m:[m33[36m:[m1[36m:[m [1m[31mE402[m module level import not at top of file
from agents.model_config import RoleModelConfig
^
[1m.\tests\test_llama33_backtest.py[m[36m:[m34[36m:[m1[36m:[m [1m[31mE402[m module level import not at top of file
from agents.orchestration_logger import OrchestrationLogger, generate_session_id
^
[1m.\tests\test_llama33_backtest.py[m[36m:[m34[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
from agents.orchestration_logger import OrchestrationLogger, generate_session_id
                                                                               ^
[1m.\tests\test_llama33_backtest.py[m[36m:[m35[36m:[m1[36m:[m [1m[31mE402[m module level import not at top of file
from agents.orchestrator import Orchestrator
^
[1m.\tests\test_llama33_backtest.py[m[36m:[m38[36m:[m80[36m:[m [1m[31mE501[m line too long (85 > 79 characters)
def create_sample_data(n_bars: int = 2000, volatility: float = 0.02) -> pd.DataFrame:
                                                                               ^
[1m.\tests\test_llama33_backtest.py[m[36m:[m230[36m:[m80[36m:[m [1m[31mE501[m line too long (100 > 79 characters)
            print(f"   VRAM: {gpu_before['vram_used_gb']:.2f}/{gpu_before['vram_total_gb']:.2f} GB")
                                                                               ^
[1m.\tests\test_llama33_backtest.py[m[36m:[m246[36m:[m80[36m:[m [1m[31mE501[m line too long (102 > 79 characters)
                print(f"   VRAM: {gpu_after['vram_used_gb']:.2f}/{gpu_after['vram_total_gb']:.2f} GB")
                                                                               ^
[1m.\tests\test_llama33_backtest.py[m[36m:[m247[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
                delta_vram = gpu_after['vram_used_gb'] - gpu_before['vram_used_gb']
                                                                               ^
[1m.\tests\test_llama33_backtest.py[m[36m:[m307[36m:[m80[36m:[m [1m[31mE501[m line too long (92 > 79 characters)
    parser = argparse.ArgumentParser(description="Test Llama 3.3 70B dans un backtest r√©el")
                                                                               ^
[1m.\tests\test_llama33_backtest.py[m[36m:[m308[36m:[m80[36m:[m [1m[31mE501[m line too long (92 > 79 characters)
    parser.add_argument("--iterations", type=int, default=3, help="Nombre max d'it√©rations")
                                                                               ^
[1m.\tests\test_llama33_backtest.py[m[36m:[m309[36m:[m80[36m:[m [1m[31mE501[m line too long (97 > 79 characters)
    parser.add_argument("--force-heavy", action="store_true", help="Forcer Llama 3.3 d√®s iter=1")
                                                                               ^
[1m.\tests\test_llama33_backtest.py[m[36m:[m310[36m:[m80[36m:[m [1m[31mE501[m line too long (95 > 79 characters)
    parser.add_argument("--strategy", type=str, default="ema_cross", help="Strat√©gie √† tester")
                                                                               ^
[1m.\tests\test_llama33_backtest.py[m[36m:[m311[36m:[m80[36m:[m [1m[31mE501[m line too long (86 > 79 characters)
    parser.add_argument("--monitor-gpu", action="store_true", help="Monitorer le GPU")
                                                                               ^
[1m.\tests\test_llama33_backtest.py[m[36m:[m312[36m:[m80[36m:[m [1m[31mE501[m line too long (90 > 79 characters)
    parser.add_argument("--n-bars", type=int, default=2000, help="Nombre de barres OHLCV")
                                                                               ^
[1m.\tests\test_llama33_backtest.py[m[36m:[m322[36m:[m80[36m:[m [1m[31mE501[m line too long (85 > 79 characters)
    print(f"   Force heavy: {'Oui' if args.force_heavy else 'Non (auto √† iter>=2)'}")
                                                                               ^
[1m.\tests\test_llama33_backtest.py[m[36m:[m349[36m:[m80[36m:[m [1m[31mE501[m line too long (92 > 79 characters)
        print("\nüí° Le mod√®le Llama 3.3 70B fonctionne correctement dans un backtest r√©el !")
                                                                               ^
[1m.\tests\test_llm_grid_phase1.py[m[36m:[m13[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
from utils.parameters import ParameterSpec, RangeProposal, normalize_param_ranges
                                                                               ^
[1m.\tests\test_llm_grid_phase1.py[m[36m:[m66[36m:[m80[36m:[m [1m[31mE501[m line too long (101 > 79 characters)
            ParameterSpec("bb_period", min_val=10, max_val=50, default=20, step=1, param_type="int"),
                                                                               ^
[1m.\tests\test_llm_grid_phase1.py[m[36m:[m67[36m:[m80[36m:[m [1m[31mE501[m line too long (104 > 79 characters)
            ParameterSpec("bb_std", min_val=1.0, max_val=3.0, default=2.0, step=0.1, param_type="float")
                                                                               ^
[1m.\tests\test_llm_grid_phase1.py[m[36m:[m88[36m:[m80[36m:[m [1m[31mE501[m line too long (95 > 79 characters)
            ParameterSpec("test", min_val=10, max_val=50, default=20, step=1, param_type="int")
                                                                               ^
[1m.\tests\test_llm_grid_phase1.py[m[36m:[m103[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
            ParameterSpec("bb_period", min_val=10, max_val=50, default=20, step=1)
                                                                               ^
[1m.\tests\test_llm_grid_phase1.py[m[36m:[m120[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
        with pytest.raises(ValueError, match="'min' et 'max' sont obligatoires"):
                                                                               ^
[1m.\tests\test_llm_grid_phase1.py[m[36m:[m126[36m:[m80[36m:[m [1m[31mE501[m line too long (95 > 79 characters)
            ParameterSpec("test", min_val=10, max_val=15, default=12, step=2, param_type="int")
                                                                               ^
[1m.\tests\test_llm_grid_phase1.py[m[36m:[m164[36m:[m80[36m:[m [1m[31mE501[m line too long (95 > 79 characters)
            ParameterSpec("test", min_val=10, max_val=15, default=12, step=1, param_type="int")
                                                                               ^
[1m.\tests\test_llm_grid_phase1.py[m[36m:[m177[36m:[m80[36m:[m [1m[31mE501[m line too long (102 > 79 characters)
            ParameterSpec("test", min_val=1.0, max_val=2.0, default=1.5, step=0.5, param_type="float")
                                                                               ^
[1m.\tests\test_llm_grid_phase1.py[m[36m:[m210[36m:[m80[36m:[m [1m[31mE501[m line too long (90 > 79 characters)
        summary = "Grid Search Results (48 combinations tested):\nTop config: Sharpe=2.45"
                                                                               ^
[1m.\tests\test_logging_infrastructure.py[m[36m:[m4[36m:[m80[36m:[m [1m[31mE501[m line too long (111 > 79 characters)
"""
Module-ID: test_logging_infrastructure

Purpose: Test infrastructure logging structur√© - generate_run_id, detect_gaps, get_git_commit, CountingHandler.

Role in pipeline: testing

Key components: generate_run_id(), detect_gaps(), get_git_commit(), CountingHandler, structured logs

Inputs: OHLCV data, logs

Outputs: V√©rification logs pr√©sents (RUN_START, DATA_LOADED, PARAMS_RESOLVED, RUN_END)

Dependencies: logging, utils.observability

Conventions: Logs structur√©s avec contexte run_id

Read-if: V√©rifier logging ne casse lors modifications.

Skip-if: Infrastructure logging stable.
"""
   
                                      

                                   ^
[1m.\tests\test_logging_infrastructure.py[m[36m:[m8[36m:[m80[36m:[m [1m[31mE501[m line too long (100 > 79 characters)
"""
Module-ID: test_logging_infrastructure

Purpose: Test infrastructure logging structur√© - generate_run_id, detect_gaps, get_git_commit, CountingHandler.

Role in pipeline: testing

Key components: generate_run_id(), detect_gaps(), get_git_commit(), CountingHandler, structured logs

Inputs: OHLCV data, logs

Outputs: V√©rification logs pr√©sents (RUN_START, DATA_LOADED, PARAMS_RESOLVED, RUN_END)

Dependencies: logging, utils.observability

Conventions: Logs structur√©s avec contexte run_id

Read-if: V√©rifier logging ne casse lors modifications.

Skip-if: Infrastructure logging stable.
"""
   
                                      

                                   ^
[1m.\tests\test_logging_infrastructure.py[m[36m:[m12[36m:[m80[36m:[m [1m[31mE501[m line too long (86 > 79 characters)
"""
Module-ID: test_logging_infrastructure

Purpose: Test infrastructure logging structur√© - generate_run_id, detect_gaps, get_git_commit, CountingHandler.

Role in pipeline: testing

Key components: generate_run_id(), detect_gaps(), get_git_commit(), CountingHandler, structured logs

Inputs: OHLCV data, logs

Outputs: V√©rification logs pr√©sents (RUN_START, DATA_LOADED, PARAMS_RESOLVED, RUN_END)

Dependencies: logging, utils.observability

Conventions: Logs structur√©s avec contexte run_id

Read-if: V√©rifier logging ne casse lors modifications.

Skip-if: Infrastructure logging stable.
"""
   
                                      

                                   ^
[1m.\tests\test_logging_infrastructure.py[m[36m:[m55[36m:[m80[36m:[m [1m[31mE501[m line too long (94 > 79 characters)
run_id_full = generate_run_id(strategy="ema_cross", symbol="BTCUSDT", timeframe="1h", seed=42)
                                                                               ^
[1m.\tests\test_logging_infrastructure.py[m[36m:[m96[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
print(f"Gaps d√©tect√©s : {gaps_info['gaps_count']} ({gaps_info['gaps_pct']:.2f}%)")
                                                                               ^
[1m.\tests\test_logging_infrastructure.py[m[36m:[m98[36m:[m80[36m:[m [1m[31mE501[m line too long (97 > 79 characters)
assert gaps_info['gaps_count'] == 5, f"Devrait d√©tecter 5 gaps, trouv√© {gaps_info['gaps_count']}"
                                                                               ^
[1m.\tests\test_logging_infrastructure.py[m[36m:[m122[36m:[m80[36m:[m [1m[31mE501[m line too long (86 > 79 characters)
assert counter.warnings == 2, f"Devrait compter 2 warnings, trouv√© {counter.warnings}"
                                                                               ^
[1m.\tests\test_logging_infrastructure.py[m[36m:[m123[36m:[m80[36m:[m [1m[31mE501[m line too long (97 > 79 characters)
assert counter.errors == 2, f"Devrait compter 2 errors (error+critical), trouv√© {counter.errors}"
                                                                               ^
[1m.\tests\test_logging_infrastructure.py[m[36m:[m149[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
    # Note : Cela n√©cessite une strat√©gie, ce qui peut √©chouer selon l'environnement
                                                                               ^
[1m.\tests\test_logging_infrastructure.py[m[36m:[m151[36m:[m80[36m:[m [1m[31mE501[m line too long (87 > 79 characters)
    print("\n‚ÑπÔ∏è  Pour tester compl√®tement, lancez un backtest r√©el avec une strat√©gie")
                                                                               ^
[1m.\tests\test_logging_infrastructure.py[m[36m:[m168[36m:[m80[36m:[m [1m[31mE501[m line too long (92 > 79 characters)
print("  - JOUR 1 : Ajouter logs d√©taill√©s sharpe_ratio(), equity_curve(), LLM, validation")
                                                                               ^
[1m.\tests\test_logging_infrastructure.py[m[36m:[m169[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
print("  - JOUR 2 : Corrections des gardes adaptatifs et validation LLM stricte")
                                                                               ^
[1m.\tests\test_metrics_fixes.py[m[36m:[m4[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
"""
Module-ID: tests.test_metrics_fixes

Purpose: Tester correctifs m√©triques (drawdown clamped -100%, ruine, cas normaux).

Role in pipeline: testing

Key components: test_drawdown_clamped_at_minus_100, test_drawdown_normal_case

Inputs: Equity Series, drawdown_series(), max_drawdown()

Outputs: Drawdown <= 0 et >= -1.0 (clamped -100%)

Dependencies: pytest, numpy, pandas, backtest.performance

Conventions: Drawdown toujours [-1.0, 0]; ruine detect√©e (equit√© <0).

Read-if: Modification drawdown calculation.

Skip-if: Tests metrics non critiques.
"""
   
                                   

                                      ^
[1m.\tests\test_metrics_fixes.py[m[36m:[m56[36m:[m80[36m:[m [1m[31mE501[m line too long (92 > 79 characters)
    expected_dd = pd.Series([0.0, 0.0, -2.857142857142857e-02, 0.0, -1.818181818181818e-02])
                                                                               ^
[1m.\tests\test_metrics_fixes.py[m[36m:[m77[36m:[m80[36m:[m [1m[31mE501[m line too long (85 > 79 characters)
    assert metrics["account_ruined"] is True, "Flag account_ruined devrait √™tre True"
                                                                               ^
[1m.\tests\test_metrics_fixes.py[m[36m:[m78[36m:[m80[36m:[m [1m[31mE501[m line too long (91 > 79 characters)
    assert metrics["min_equity"] == -1000, f"Min equity incorrect: {metrics['min_equity']}"
                                                                               ^
[1m.\tests\test_metrics_fixes.py[m[36m:[m91[36m:[m80[36m:[m [1m[31mE501[m line too long (94 > 79 characters)
    assert metrics_normal["account_ruined"] is False, "Flag account_ruined devrait √™tre False"
                                                                               ^
[1m.\tests\test_metrics_fixes.py[m[36m:[m121[36m:[m80[36m:[m [1m[31mE501[m line too long (98 > 79 characters)
    assert abs(max_dd - expected_max_dd) < 1e-6, f"Max DD attendu {expected_max_dd}, got {max_dd}"
                                                                               ^
[1m.\tests\test_metrics_pipeline.py[m[36m:[m15[36m:[m80[36m:[m [1m[31mE501[m line too long (92 > 79 characters)
    """Strat√©gie de test pour pipeline metrics (prefixe _ pour eviter collection pytest)."""
                                                                               ^
[1m.\tests\test_model_selection_robust.py[m[36m:[m4[36m:[m80[36m:[m [1m[31mE501[m line too long (89 > 79 characters)
"""
Module-ID: tests.test_model_selection_robust

Purpose: Tester robustesse s√©lection mod√®les LLM (retry Ollama, fallback lists, timeout).

Role in pipeline: testing

Key components: TestModelSelectionRobustness, test_retry_on_ollama_connection_error

Inputs: Mock httpx.get, patch time.sleep, RoleModelConfig

Outputs: Retry logic valid√©e, fallback OK si Ollama down

Dependencies: pytest, unittest.mock, agents.model_config

Conventions: 3 retries max; timeout 2s; connection error handling.

Read-if: Modification retry logic ou fallback.

Skip-if: Tests model selection non critiques.
"""
   
                                            

                             ^
[1m.\tests\test_model_selection_robust.py[m[36m:[m8[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
"""
Module-ID: tests.test_model_selection_robust

Purpose: Tester robustesse s√©lection mod√®les LLM (retry Ollama, fallback lists, timeout).

Role in pipeline: testing

Key components: TestModelSelectionRobustness, test_retry_on_ollama_connection_error

Inputs: Mock httpx.get, patch time.sleep, RoleModelConfig

Outputs: Retry logic valid√©e, fallback OK si Ollama down

Dependencies: pytest, unittest.mock, agents.model_config

Conventions: 3 retries max; timeout 2s; connection error handling.

Read-if: Modification retry logic ou fallback.

Skip-if: Tests model selection non critiques.
"""
   
                                            

                             ^
[1m.\tests\test_model_selection_robust.py[m[36m:[m79[36m:[m80[36m:[m [1m[31mE501[m line too long (120 > 79 characters)
            assert model in ["deepseek-r1:8b", "mistral:7b-instruct", "martain7r/finance-llama-8b:q4_k_m", "gemma3:12b"]
                                                                               ^
[1m.\tests\test_model_selection_robust.py[m[36m:[m84[36m:[m80[36m:[m [1m[31mE501[m line too long (87 > 79 characters)
            # Niveau 1: Ollama OK avec 1 mod√®le install√© (pas dans la liste configur√©e)
                                                                               ^
[1m.\tests\test_model_selection_robust.py[m[36m:[m96[36m:[m80[36m:[m [1m[31mE501[m line too long (120 > 79 characters)
            assert model in ["deepseek-r1:8b", "mistral:7b-instruct", "martain7r/finance-llama-8b:q4_k_m", "gemma3:12b"]
                                                                               ^
[1m.\tests\test_model_selection_robust.py[m[36m:[m116[36m:[m80[36m:[m [1m[31mE501[m line too long (104 > 79 characters)
            warning_messages = [rec.message for rec in caplog.records if rec.levelno == logging.WARNING]
                                                                               ^
[1m.\tests\test_model_selection_robust.py[m[36m:[m117[36m:[m80[36m:[m [1m[31mE501[m line too long (88 > 79 characters)
            assert not any("Aucun mod√®le disponible" in msg for msg in warning_messages)
                                                                               ^
[1m.\tests\test_model_selection_robust.py[m[36m:[m143[36m:[m80[36m:[m [1m[31mE501[m line too long (114 > 79 characters)
            assert model in ["deepseek-r1-distill:14b", "mistral:22b", "gemma3:27b", "deepseek-r1:32b", "qwq:32b"]
                                                                               ^
[1m.\tests\test_model_selection_robust.py[m[36m:[m157[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
            # Par d√©faut: 5 tentatives => 4 sleeps (backoff exponentiel: 1,2,4,8)
                                                                               ^
[1m.\tests\test_model_selection_robust.py[m[36m:[m174[36m:[m80[36m:[m [1m[31mE501[m line too long (93 > 79 characters)
            # ‚Üí Fallback niveau 2: mod√®les configur√©s (car installed est vide apr√®s filtrage)
                                                                               ^
[1m.\tests\test_model_selection_robust.py[m[36m:[m178[36m:[m80[36m:[m [1m[31mE501[m line too long (94 > 79 characters)
            # Le comportement actuel: niveau 2 activ√© car installed_models vide apr√®s filtrage
                                                                               ^
[1m.\tests\test_model_selection_robust.py[m[36m:[m179[36m:[m80[36m:[m [1m[31mE501[m line too long (95 > 79 characters)
            # On s'attend √† un mod√®le configur√© (martain7r/finance-llama-8b:q4_k_m par exemple)
                                                                               ^
[1m.\tests\test_model_selection_robust.py[m[36m:[m180[36m:[m80[36m:[m [1m[31mE501[m line too long (146 > 79 characters)
            assert model in ["deepseek-r1:8b", "mistral:7b-instruct", "martain7r/finance-llama-8b:q4_k_m", "gemma3:12b", "completely-unknown:99b"]
                                                                               ^
[1m.\tests\test_model_selection_robust.py[m[36m:[m198[36m:[m80[36m:[m [1m[31mE501[m line too long (120 > 79 characters)
            assert model in ["deepseek-r1:8b", "mistral:7b-instruct", "martain7r/finance-llama-8b:q4_k_m", "gemma3:12b"]
                                                                               ^
[1m.\tests\test_multigpu_realtime.py[m[36m:[m41[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
                    "--query-gpu=index,utilization.gpu,memory.used,memory.total",
                                                                               ^
[1m.\tests\test_multigpu_realtime.py[m[36m:[m80[36m:[m80[36m:[m [1m[31mE501[m line too long (94 > 79 characters)
                    f"GPU0 {gpu0_color} {gpu0_util:3d}% ({gpu0_vram:5d}/{gpu0_total:5d}MB) | "
                                                                               ^
[1m.\tests\test_multigpu_realtime.py[m[36m:[m81[36m:[m80[36m:[m [1m[31mE501[m line too long (91 > 79 characters)
                    f"GPU1 {gpu1_color} {gpu1_util:3d}% ({gpu1_vram:5d}/{gpu1_total:5d}MB)"
                                                                               ^
[1m.\tests\test_multigpu_realtime.py[m[36m:[m108[36m:[m80[36m:[m [1m[31mE501[m line too long (85 > 79 characters)
        print("   1. Red√©marrer Ollama: D:\\backtest_core\\Start-OllamaMultiGPU.ps1")
                                                                               ^
[1m.\tests\test_multigpu_realtime.py[m[36m:[m109[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
        print("   2. V√©rifier Modelfile: ollama show llama3.3-70b-2gpu --modelfile")
                                                                               ^
[1m.\tests\test_multigpu_realtime.py[m[36m:[m111[36m:[m80[36m:[m [1m[31mE501[m line too long (86 > 79 characters)
        print("‚ùå AUCUN GPU UTILIS√â : Ollama n'est peut-√™tre pas en cours d'ex√©cution")
                                                                               ^
[1m.\tests\test_multigpu_realtime.py[m[36m:[m118[36m:[m80[36m:[m [1m[31mE501[m line too long (113 > 79 characters)
def run_inference(model: str = "llama3.3-70b-2gpu", prompt: str = "Explain reinforcement learning in 100 words"):
                                                                               ^
[1m.\tests\test_multigpu_realtime.py[m[36m:[m184[36m:[m80[36m:[m [1m[31mE501[m line too long (94 > 79 characters)
        prompt="Explain what is reinforcement learning in 100 words. Be concise and precise.",
                                                                               ^
[1m.\tests\test_orchestration.py[m[36m:[m4[36m:[m80[36m:[m [1m[31mE501[m line too long (94 > 79 characters)
"""
Module-ID: test_orchestration

Purpose: Test orchestration compl√®te - strat√©gies ‚Üî indicateurs ‚Üî granularit√© de bout en bout.

Role in pipeline: testing

Key components: list_strategies(), get_strategy_info(), generate_param_grid(), compatibility checks

Inputs: Registry strat√©gies/indicateurs, Presets

Outputs: V√©rification compat sb√©lit√© et coh√©rence

Dependencies: pytest, strategies, indicators, utils.parameters

Conventions: V√©rification indicateurs existent, param ranges valides

Read-if: Modification strat√©gies/indicateurs/granularit√©.

Skip-if: Orch√©stration d√©j√† test√©e.
"""
   
                             

                                            ^
[1m.\tests\test_orchestration.py[m[36m:[m8[36m:[m80[36m:[m [1m[31mE501[m line too long (99 > 79 characters)
"""
Module-ID: test_orchestration

Purpose: Test orchestration compl√®te - strat√©gies ‚Üî indicateurs ‚Üî granularit√© de bout en bout.

Role in pipeline: testing

Key components: list_strategies(), get_strategy_info(), generate_param_grid(), compatibility checks

Inputs: Registry strat√©gies/indicateurs, Presets

Outputs: V√©rification compat sb√©lit√© et coh√©rence

Dependencies: pytest, strategies, indicators, utils.parameters

Conventions: V√©rification indicateurs existent, param ranges valides

Read-if: Modification strat√©gies/indicateurs/granularit√©.

Skip-if: Orch√©stration d√©j√† test√©e.
"""
   
                             

                                            ^
[1m.\tests\test_orchestration.py[m[36m:[m229[36m:[m80[36m:[m [1m[31mE501[m line too long (86 > 79 characters)
    results.append(("Indicateurs par Strat√©gie", test_indicators_for_each_strategy()))
                                                                               ^
[1m.\tests\test_orchestration_logger_persistence.py[m[36m:[m4[36m:[m80[36m:[m [1m[31mE501[m line too long (105 > 79 characters)
"""
Module-ID: tests.test_orchestration_logger_persistence

Purpose: Tester persistence JSONL OrchestrationLogger (header + events sauvegard√©s, pas de fichier vide).

Role in pipeline: testing

Key components: test_orchestration_logger_writes_events_to_jsonl, tmp_path fixture

Inputs: OrchestrationLogger, √©v√©nements via log() API, tmp_path

Outputs: trace.jsonl avec header + √©v√©nements (‚â•3 lignes)

Dependencies: pytest, agents.orchestration_logger

Conventions: JSONL format; 1 header + N √©v√©nements; auto_save optionnel.

Read-if: Modification persistence ou format log.

Skip-if: Tests persistence non critiques.
"""
   
                                                      

                   ^
[1m.\tests\test_orchestration_logger_persistence.py[m[36m:[m8[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
"""
Module-ID: tests.test_orchestration_logger_persistence

Purpose: Tester persistence JSONL OrchestrationLogger (header + events sauvegard√©s, pas de fichier vide).

Role in pipeline: testing

Key components: test_orchestration_logger_writes_events_to_jsonl, tmp_path fixture

Inputs: OrchestrationLogger, √©v√©nements via log() API, tmp_path

Outputs: trace.jsonl avec header + √©v√©nements (‚â•3 lignes)

Dependencies: pytest, agents.orchestration_logger

Conventions: JSONL format; 1 header + N √©v√©nements; auto_save optionnel.

Read-if: Modification persistence ou format log.

Skip-if: Tests persistence non critiques.
"""
   
                                                      

                   ^
[1m.\tests\test_orchestration_logger_persistence.py[m[36m:[m35[36m:[m80[36m:[m [1m[31mE501[m line too long (96 > 79 characters)
    logger = OrchestrationLogger(session_id="testsession", auto_save=False, save_path=save_path)
                                                                               ^
[1m.\tests\test_orchestration_logger_persistence.py[m[36m:[m38[36m:[m80[36m:[m [1m[31mE501[m line too long (121 > 79 characters)
    logger.log("run_start", {"event_type": "run_start", "session_id": "testsession", "timestamp": "2025-01-01T00:00:00"})
                                                                               ^
[1m.\tests\test_orchestration_logger_persistence.py[m[36m:[m39[36m:[m80[36m:[m [1m[31mE501[m line too long (132 > 79 characters)
    logger.log("error", {"event_type": "error", "session_id": "testsession", "message": "boom", "timestamp": "2025-01-01T00:00:01"})
                                                                               ^
[1m.\tests\test_orchestration_logger_persistence.py[m[36m:[m61[36m:[m80[36m:[m [1m[31mE501[m line too long (100 > 79 characters)
def test_create_orchestrator_with_backtest_uses_injected_logger_and_session_id(monkeypatch) -> None:
                                                                               ^
[1m.\tests\test_orchestration_logger_persistence.py[m[36m:[m62[36m:[m80[36m:[m [1m[31mE501[m line too long (96 > 79 characters)
    """V√©rifie que l'orchestrateur multi-agents r√©utilise le logger UI (session_id coh√©rent)."""
                                                                               ^
[1m.\tests\test_orchestration_logger_persistence.py[m[36m:[m77[36m:[m80[36m:[m [1m[31mE501[m line too long (90 > 79 characters)
    monkeypatch.setattr(orchestrator_module, "create_llm_client", _fake_create_llm_client)
                                                                               ^
[1m.\tests\test_orchestration_logger_persistence.py[m[36m:[m83[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
        def log(self, action_type: str, details: dict) -> None:  # pragma: no cover
                                                                               ^
[1m.\tests\test_orchestrator_sweep.py[m[36m:[m35[36m:[m80[36m:[m [1m[31mE501[m line too long (95 > 79 characters)
        assert "ALTERNATIVE: Grid Search" in content or "Grid Search (Sweep) Format" in content
                                                                               ^
[1m.\tests\test_orchestrator_sweep.py[m[36m:[m45[36m:[m80[36m:[m [1m[31mE501[m line too long (89 > 79 characters)
        assert "GRID SEARCH CONSIDERATION" in content or "grid search" in content.lower()
                                                                               ^
[1m.\tests\test_orchestrator_sweep.py[m[36m:[m46[36m:[m80[36m:[m [1m[31mE501[m line too long (95 > 79 characters)
        assert "parameter correlations" in content.lower() or "correlations" in content.lower()
                                                                               ^
[1m.\tests\test_orchestrator_sweep.py[m[36m:[m129[36m:[m80[36m:[m [1m[31mE501[m line too long (101 > 79 characters)
        assert orchestrator.context.strategist_proposals[0]["parameters"] == {"fast": 10, "slow": 22}
                                                                               ^
[1m.\tests\test_orchestrator_sweep.py[m[36m:[m132[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
        """Test que _handle_propose() g√®re normalement les proposals (non-sweep)."""
                                                                               ^
[1m.\tests\test_orchestrator_sweep.py[m[36m:[m174[36m:[m80[36m:[m [1m[31mE501[m line too long (111 > 79 characters)
        assert not hasattr(orchestrator.context, 'sweep_results') or orchestrator.context.sweep_results is None
                                                                               ^
[1m.\tests\test_orchestrator_sweep.py[m[36m:[m238[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
        assert orchestrator.context.sweep_results == mock_run_llm_sweep.return_value
                                                                               ^
[1m.\tests\test_orchestrator_sweep.py[m[36m:[m239[36m:[m80[36m:[m [1m[31mE501[m line too long (93 > 79 characters)
        assert orchestrator.context.sweep_summary == "Grid search completed: 30 combinations"
                                                                               ^
[1m.\tests\test_parallel_sweep.py[m[36m:[m4[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
"""
Module-ID: test_parallel_sweep

Purpose: Test parall√©lisation SweepEngine - v√©rifier 8 workers ex√©cution parall√®le.

Role in pipeline: testing

Key components: SweepEngine, parallel workers, timing validation

Inputs: Grille param√©tres, strat√©gie RSI

Outputs: V√©rification temps ex√©cution (parall√®le < s√©rie)

Dependencies: pytest, backtest.sweep, time

Conventions: N workers = 8; mes timing d'ex√©cution

Read-if: V√©rifier parall√©lisation sweep fonctionne.

Skip-if: Performance par√©e connue.
"""
   
                              

                                           ^
[1m.\tests\test_parallel_sweep.py[m[36m:[m34[36m:[m80[36m:[m [1m[31mE501[m line too long (101 > 79 characters)
    dates = pd.date_range('2020-01-01', periods=n_bars, freq='h')  # 'h' au lieu de '1H' (deprecated)
                                                                               ^
[1m.\tests\test_parallel_sweep.py[m[36m:[m71[36m:[m80[36m:[m [1m[31mE501[m line too long (122 > 79 characters)
    print(f"Grille de param√®tres: {len(param_grid['rsi_period'])} x {len(param_grid['rsi_oversold'])} = 100 combinaisons")
                                                                               ^
[1m.\tests\test_parallel_sweep.py[m[36m:[m77[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
    engine_seq = SweepEngine(max_workers=1, use_processes=True, auto_save=False)
                                                                               ^
[1m.\tests\test_parallel_sweep.py[m[36m:[m91[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
    print(f"   - Throughput: {results_seq.n_completed / time_seq:.2f} backtests/s")
                                                                               ^
[1m.\tests\test_parallel_sweep.py[m[36m:[m97[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
    engine_par = SweepEngine(max_workers=8, use_processes=True, auto_save=False)
                                                                               ^
[1m.\tests\test_parallel_sweep.py[m[36m:[m111[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
    print(f"   - Throughput: {results_par.n_completed / time_par:.2f} backtests/s")
                                                                               ^
[1m.\tests\test_parallel_sweep.py[m[36m:[m124[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
    print(f"Overhead:          {100 - efficiency:.1f}% (pickle, IPC, scheduling)")
                                                                               ^
[1m.\tests\test_parallel_sweep.py[m[36m:[m174[36m:[m80[36m:[m [1m[31mE501[m line too long (85 > 79 characters)
    if isinstance(sharpe_seq, (int, float)) and isinstance(sharpe_par, (int, float)):
                                                                               ^
[1m.\tests\test_parallel_sweep.py[m[36m:[m193[36m:[m80[36m:[m [1m[31mE501[m line too long (117 > 79 characters)
    print(f"Workers OK:   {'‚úÖ Oui' if status == 'PASS' else '‚ö†Ô∏è Partiellement' if status == 'WARNING' else '‚ùå Non'}")
                                                                               ^
[1m.\tests\test_performance_metrics.py[m[36m:[m4[36m:[m80[36m:[m [1m[31mE501[m line too long (96 > 79 characters)
"""
Module-ID: tests.test_performance_metrics

Purpose: Tester calculate_metrics() - rendement annualis√© calendrier, volatilit√© daily resample.

Role in pipeline: testing

Key components: test_calculate_metrics_annualized_return, test_volatility_annual_respects_daily_resample

Inputs: Equity Series, returns Series, trades DataFrame

Outputs: Metrics dict {annualized_return, volatility, etc.}

Dependencies: pytest, numpy, pandas, backtest.performance

Conventions: Temps calendaire pour annualis√©; daily resample si intraday; edge cases g√©r√©s.

Read-if: Modification metric calculation.

Skip-if: Tests unitaires non critiques.
"""
   
                                         

                                ^
[1m.\tests\test_performance_metrics.py[m[36m:[m8[36m:[m80[36m:[m [1m[31mE501[m line too long (104 > 79 characters)
"""
Module-ID: tests.test_performance_metrics

Purpose: Tester calculate_metrics() - rendement annualis√© calendrier, volatilit√© daily resample.

Role in pipeline: testing

Key components: test_calculate_metrics_annualized_return, test_volatility_annual_respects_daily_resample

Inputs: Equity Series, returns Series, trades DataFrame

Outputs: Metrics dict {annualized_return, volatility, etc.}

Dependencies: pytest, numpy, pandas, backtest.performance

Conventions: Temps calendaire pour annualis√©; daily resample si intraday; edge cases g√©r√©s.

Read-if: Modification metric calculation.

Skip-if: Tests unitaires non critiques.
"""
   
                                         

                                ^
[1m.\tests\test_performance_metrics.py[m[36m:[m16[36m:[m80[36m:[m [1m[31mE501[m line too long (91 > 79 characters)
"""
Module-ID: tests.test_performance_metrics

Purpose: Tester calculate_metrics() - rendement annualis√© calendrier, volatilit√© daily resample.

Role in pipeline: testing

Key components: test_calculate_metrics_annualized_return, test_volatility_annual_respects_daily_resample

Inputs: Equity Series, returns Series, trades DataFrame

Outputs: Metrics dict {annualized_return, volatility, etc.}

Dependencies: pytest, numpy, pandas, backtest.performance

Conventions: Temps calendaire pour annualis√©; daily resample si intraday; edge cases g√©r√©s.

Read-if: Modification metric calculation.

Skip-if: Tests unitaires non critiques.
"""
   
                                         

                                ^
[1m.\tests\test_performance_metrics.py[m[36m:[m51[36m:[m80[36m:[m [1m[31mE501[m line too long (90 > 79 characters)
        day_index = pd.date_range(start + pd.Timedelta(days=offset), periods=24, freq="h")
                                                                               ^
[1m.\tests\test_performance_metrics.py[m[36m:[m65[36m:[m80[36m:[m [1m[31mE501[m line too long (98 > 79 characters)
    daily_series = pd.Series(daily_prices, index=pd.date_range("2024-01-01", periods=3, freq="D"))
                                                                               ^
[1m.\tests\test_performance_metrics.py[m[36m:[m80[36m:[m80[36m:[m [1m[31mE501[m line too long (89 > 79 characters)
    assert metrics["max_drawdown_duration_days"] == pytest.approx(expected_duration_days)
                                                                               ^
[1m.\tests\test_preset_compatibility.py[m[36m:[m52[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
                    print(f"   ‚ö†Ô∏è  INCOH√âRENT avec strat√©gie '{strategy_name}'")
                                                                               ^
[1m.\tests\test_preset_compatibility.py[m[36m:[m58[36m:[m80[36m:[m [1m[31mE501[m line too long (88 > 79 characters)
                print(f"   ‚ö†Ô∏è  Strat√©gie '{strategy_name}' non trouv√©e dans le mapping")
                                                                               ^
[1m.\tests\test_preset_compatibility.py[m[36m:[m68[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
    """
    V√©rifie quelles strat√©gies ont des Presets d√©di√©s et lesquelles n'en ont pas.
    """
       
                                                                       ^
[1m.\tests\test_preset_compatibility.py[m[36m:[m89[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
            print(f"   - {strategy_name}: indicateurs={info.required_indicators}")
                                                                               ^
[1m.\tests\test_preset_compatibility.py[m[36m:[m93[36m:[m80[36m:[m [1m[31mE501[m line too long (90 > 79 characters)
        print(f"\nüí° Opportunit√©: Cr√©er des Presets pour {len(missing_preset)} strat√©gies")
                                                                               ^
[1m.\tests\test_preset_compatibility.py[m[36m:[m122[36m:[m80[36m:[m [1m[31mE501[m line too long (87 > 79 characters)
                print(f"   ‚úó ERREUR: Indicateur '{ind}' n'existe PAS dans le registre")
                                                                               ^
[1m.\tests\test_preset_compatibility.py[m[36m:[m130[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
    """
    V√©rifie que le syst√®me de granularit√© fonctionne ind√©pendamment des indicateurs.
    """
       
                                                                       ^
[1m.\tests\test_preset_compatibility.py[m[36m:[m173[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
    print("   - Presets.indicators utilise la m√™me nomenclature que le mapping")
                                                                               ^
[1m.\tests\test_preset_compatibility.py[m[36m:[m174[36m:[m80[36m:[m [1m[31mE501[m line too long (86 > 79 characters)
    print("   - Le champ 'indicators' dans Preset correspond √† 'required_indicators'")
                                                                               ^
[1m.\tests\test_preset_compatibility.py[m[36m:[m178[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
    print("   1. Cr√©er des Presets pour toutes les strat√©gies (actuellement 2/9)")
                                                                               ^
[1m.\tests\test_preset_compatibility.py[m[36m:[m179[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
    print("   2. Auto-remplir Preset.indicators depuis get_required_indicators()")
                                                                               ^
[1m.\tests\test_presets_and_orchestration.py[m[36m:[m109[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
    logger.log_strategy_selection("Strategist", "bollinger_atr", "March√© range")
                                                                               ^
[1m.\tests\test_presets_and_orchestration.py[m[36m:[m148[36m:[m80[36m:[m [1m[31mE501[m line too long (86 > 79 characters)
    backtest_logs = logger.get_logs_by_type(OrchestrationActionType.BACKTEST_COMPLETE)
                                                                               ^
[1m.\tests\test_presets_and_orchestration.py[m[36m:[m153[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
    print(f"\n‚úì Logs sauvegard√©s dans orchestration_logs_{logger.session_id}.json")
                                                                               ^
[1m.\tests\test_presets_and_orchestration.py[m[36m:[m181[36m:[m80[36m:[m [1m[31mE501[m line too long (95 > 79 characters)
    logger.log_strategy_selection("Analyst", "bollinger_atr", "Mean reversion Bollinger + ATR")
                                                                               ^
[1m.\tests\test_sharpe_fix.py[m[36m:[m56[36m:[m80[36m:[m [1m[31mE501[m line too long (85 > 79 characters)
    result = engine.run(df=df, strategy='atr_channel', params=params, timeframe='1h')
                                                                               ^
[1m.\tests\test_sharpe_fix.py[m[36m:[m74[36m:[m80[36m:[m [1m[31mE501[m line too long (85 > 79 characters)
    print(f"   ‚ùå √âCHEC: Toutes les valeurs sont identiques ({sharpe_values[0]:.4f})")
                                                                               ^
[1m.\tests\test_sharpe_fix.py[m[36m:[m80[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
    print(f"      Min: {min(sharpe_values):.4f}, Max: {max(sharpe_values):.4f}")
                                                                               ^
[1m.\tests\test_sharpe_ratio.py[m[36m:[m8[36m:[m80[36m:[m [1m[31mE501[m line too long (120 > 79 characters)
"""
Module-ID: tests.test_sharpe_ratio

Purpose: Tester calcul Sharpe ratio (standard, daily resample, edge cases).

Role in pipeline: testing

Key components: test_sharpe_ratio_standard_expected_value, test_sharpe_ratio_no_trades, test_sharpe_ratio_daily_resample

Inputs: Returns Series, equity Series, parametres (periods_per_year, method)

Outputs: Sharpe ratio float (ou 0.0 si pas de trades)

Dependencies: pytest, numpy, pandas, backtest.performance

Conventions: Annualis√© 252 p√©riodes par d√©faut; edge cases retours=0.

Read-if: Modification Sharpe calculation ou tests.

Skip-if: Tests unitaires non critiques.
"""
   
                                  

                                       ^
[1m.\tests\test_sharpe_ratio.py[m[36m:[m34[36m:[m80[36m:[m [1m[31mE501[m line too long (100 > 79 characters)
    assert sharpe_ratio(returns, periods_per_year=252, method="standard") == pytest.approx(expected)
                                                                               ^
[1m.\tests\test_sharpe_ratio.py[m[36m:[m40[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
    assert sharpe_ratio(returns, periods_per_year=252, method="standard") == 0.0
                                                                               ^
[1m.\tests\test_sharpe_ratio.py[m[36m:[m51[36m:[m80[36m:[m [1m[31mE501[m line too long (86 > 79 characters)
    expected = (expected_returns.mean() * np.sqrt(252)) / expected_returns.std(ddof=1)
                                                                               ^
[1m.\tests\test_sharpe_ratio.py[m[36m:[m66[36m:[m80[36m:[m [1m[31mE501[m line too long (85 > 79 characters)
    assert sharpe_ratio(tiny_returns, periods_per_year=252, method="standard") == 0.0
                                                                               ^
[1m.\tests\test_sharpe_ratio.py[m[36m:[m87[36m:[m80[36m:[m [1m[31mE501[m line too long (107 > 79 characters)
    daily_changes = pd.Series([0.02, -0.01, 0.015], index=pd.date_range("2024-03-01", periods=3, freq="D"))
                                                                               ^
[1m.\tests\test_sharpe_ratio.py[m[36m:[m95[36m:[m80[36m:[m [1m[31mE501[m line too long (86 > 79 characters)
    expected = (expected_returns.mean() * np.sqrt(252)) / expected_returns.std(ddof=1)
                                                                               ^
[1m.\tests\test_sharpe_ratio.py[m[36m:[m112[36m:[m80[36m:[m [1m[31mE501[m line too long (85 > 79 characters)
    assert sharpe_ratio(tiny_returns, periods_per_year=252, method="standard") == 0.0
                                                                               ^
[1m.\tests\test_sharpe_realdata.py[m[36m:[m48[36m:[m80[36m:[m [1m[31mE501[m line too long (90 > 79 characters)
print(f"   Market return: {(df['close'].iloc[-1] / df['close'].iloc[0] - 1) * 100:+.1f}%")
                                                                               ^
[1m.\tests\test_sharpe_realdata.py[m[36m:[m70[36m:[m80[36m:[m [1m[31mE501[m line too long (85 > 79 characters)
    result = engine.run(df=df, strategy='atr_channel', params=params, timeframe='1h')
                                                                               ^
[1m.\tests\test_sharpe_realdata.py[m[36m:[m85[36m:[m80[36m:[m [1m[31mE501[m line too long (97 > 79 characters)
    print(f"   {i:2d}. atr_period={params['atr_period']:2d} atr_mult={params['atr_mult']:.1f} ‚Üí "
                                                                               ^
[1m.\tests\test_sharpe_realdata.py[m[36m:[m107[36m:[m80[36m:[m [1m[31mE501[m line too long (88 > 79 characters)
    print(f"   ‚ùå PROBL√àME: Toutes les valeurs sont identiques ({sharpe_values[0]:.3f})")
                                                                               ^
[1m.\tests\test_sharpe_realdata.py[m[36m:[m109[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
        print("      ‚Üí Sharpe = 0.0 ‚Üí Pas assez de donn√©es apr√®s daily_resample?")
                                                                               ^
[1m.\tests\test_sharpe_realdata.py[m[36m:[m114[36m:[m80[36m:[m [1m[31mE501[m line too long (86 > 79 characters)
    print("      ‚Üí V√©rifier MIN_DAYS_FOR_SHARPE (devrait avoir assez avec 180 jours)")
                                                                               ^
[1m.\tests\test_sharpe_realdata.py[m[36m:[m116[36m:[m80[36m:[m [1m[31mE501[m line too long (111 > 79 characters)
    print(f"   ‚úÖ SUCC√àS: Sharpe varie correctement entre {min(sharpe_values):.3f} et {max(sharpe_values):.3f}")
                                                                               ^
[1m.\tests\test_sharpe_realdata.py[m[36m:[m131[36m:[m80[36m:[m [1m[31mE501[m line too long (111 > 79 characters)
    print(f"   ‚úÖ Normal pour march√© haussier (+{(df['close'].iloc[-1] / df['close'].iloc[0] - 1) * 100:.1f}%)")
                                                                               ^
[1m.\tests\test_sharpe_realdata.py[m[36m:[m139[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
    print(f"   {i}. {r['params']} ‚Üí Sharpe={r['sharpe']:.3f}, PnL={r['pnl']:+.2f}")
                                                                               ^
[1m.\tests\test_template_robustness.py[m[36m:[m4[36m:[m80[36m:[m [1m[31mE501[m line too long (96 > 79 characters)
"""
Module-ID: tests.test_template_robustness

Purpose: Tester robustesse templates Jinja2 (fallback N/A si champs manquent, pas de TypeError).

Role in pipeline: testing

Key components: test_format_float_handles_missing, test_critic_template_renders_without_walk_forward

Inputs: Template string/name, context dict (optionnel avec fields manquants)

Outputs: Rendered HTML string (pas d'exception)

Dependencies: pytest, utils.template

Conventions: Fallback N/A pour variables manquantes; pas d'erreurs rendu.

Read-if: Modification templates Jinja2 ou filters.

Skip-if: Tests templates non critiques.
"""
   
                                         

                                ^
[1m.\tests\test_template_robustness.py[m[36m:[m8[36m:[m80[36m:[m [1m[31mE501[m line too long (100 > 79 characters)
"""
Module-ID: tests.test_template_robustness

Purpose: Tester robustesse templates Jinja2 (fallback N/A si champs manquent, pas de TypeError).

Role in pipeline: testing

Key components: test_format_float_handles_missing, test_critic_template_renders_without_walk_forward

Inputs: Template string/name, context dict (optionnel avec fields manquants)

Outputs: Rendered HTML string (pas d'exception)

Dependencies: pytest, utils.template

Conventions: Fallback N/A pour variables manquantes; pas d'erreurs rendu.

Read-if: Modification templates Jinja2 ou filters.

Skip-if: Tests templates non critiques.
"""
   
                                         

                                ^
[1m.\tests\test_template_robustness.py[m[36m:[m27[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
    rendered = render_prompt_from_string("Value={{ missing|format_float(2) }}", {})
                                                                               ^
[1m.\tests\test_template_robustness.py[m[36m:[m32[36m:[m80[36m:[m [1m[31mE501[m line too long (103 > 79 characters)
    # Simule le cas qui crashait: overfitting_ratio present (>0) mais classic_ratio absent du contexte.
                                                                               ^
[1m.\tests\test_template_robustness.py[m[36m:[m58[36m:[m80[36m:[m [1m[31mE501[m line too long (108 > 79 characters)
    """V√©rifie que le template validator.jinja2 rend correctement avec toutes les variables walk-forward."""
                                                                               ^
[1m.\tests\test_ui_orchestration_integration.py[m[36m:[m158[36m:[m80[36m:[m [1m[31mE501[m line too long (90 > 79 characters)
        print("\n‚úì Composants UI valid√©s (ex√©cution Streamlit requise pour test complet)")
                                                                               ^
[1m.\tests\test_ui_orchestration_integration.py[m[36m:[m172[36m:[m80[36m:[m [1m[31mE501[m line too long (88 > 79 characters)
        from agents.orchestration_logger import OrchestrationLogger, generate_session_id
                                                                               ^
[1m.\tests\test_ui_orchestration_integration.py[m[36m:[m184[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
        # V√©rifier que create_optimizer_from_engine accepte orchestration_logger
                                                                               ^
[1m.\tests\test_ui_orchestration_integration.py[m[36m:[m191[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
            print("‚úì create_optimizer_from_engine accepte orchestration_logger")
                                                                               ^
[1m.\tests\test_ui_orchestration_integration.py[m[36m:[m193[36m:[m80[36m:[m [1m[31mE501[m line too long (86 > 79 characters)
            print("‚ùå orchestration_logger manquant dans create_optimizer_from_engine")
                                                                               ^
[1m.\tests\test_ui_orchestration_integration.py[m[36m:[m202[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
            print("‚úì AutonomousStrategist.__init__ accepte orchestration_logger")
                                                                               ^
[1m.\tests\test_ui_orchestration_integration.py[m[36m:[m242[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
    analysis_logs = logger.get_logs_by_type(OrchestrationActionType.ANALYSIS_START)
                                                                               ^
[1m.\tests\test_ui_orchestration_integration.py[m[36m:[m243[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
    backtest_logs = logger.get_logs_by_type(OrchestrationActionType.BACKTEST_LAUNCH)
                                                                               ^
[1m.\tests\test_versioned_presets.py[m[36m:[m4[36m:[m80[36m:[m [1m[31mE501[m line too long (93 > 79 characters)
"""
Module-ID: tests.test_versioned_presets

Purpose: Tester syst√®me versioning presets (roundtrip save/load, resolve latest, validation).

Role in pipeline: testing

Key components: test_resolve_latest_version, test_versioned_preset_roundtrip, fixtures monkeypatch

Inputs: Versioned preset params dict, tmp_path, env var BACKTEST_PRESETS_DIR

Outputs: Loaded preset dict matched saved, version resolved

Dependencies: pytest, utils.parameters

Conventions: DEFAULT_STRATEGY_VERSION constant; roundtrip fidelit√©; validation avant use.

Read-if: Modification versioning system ou file structure.

Skip-if: Tests presets non critiques.
"""
   
                                       

                                  ^
[1m.\tests\test_versioned_presets.py[m[36m:[m8[36m:[m80[36m:[m [1m[31mE501[m line too long (98 > 79 characters)
"""
Module-ID: tests.test_versioned_presets

Purpose: Tester syst√®me versioning presets (roundtrip save/load, resolve latest, validation).

Role in pipeline: testing

Key components: test_resolve_latest_version, test_versioned_preset_roundtrip, fixtures monkeypatch

Inputs: Versioned preset params dict, tmp_path, env var BACKTEST_PRESETS_DIR

Outputs: Loaded preset dict matched saved, version resolved

Dependencies: pytest, utils.parameters

Conventions: DEFAULT_STRATEGY_VERSION constant; roundtrip fidelit√©; validation avant use.

Read-if: Modification versioning system ou file structure.

Skip-if: Tests presets non critiques.
"""
   
                                       

                                  ^
[1m.\tests\test_versioned_presets.py[m[36m:[m16[36m:[m80[36m:[m [1m[31mE501[m line too long (89 > 79 characters)
"""
Module-ID: tests.test_versioned_presets

Purpose: Tester syst√®me versioning presets (roundtrip save/load, resolve latest, validation).

Role in pipeline: testing

Key components: test_resolve_latest_version, test_versioned_preset_roundtrip, fixtures monkeypatch

Inputs: Versioned preset params dict, tmp_path, env var BACKTEST_PRESETS_DIR

Outputs: Loaded preset dict matched saved, version resolved

Dependencies: pytest, utils.parameters

Conventions: DEFAULT_STRATEGY_VERSION constant; roundtrip fidelit√©; validation avant use.

Read-if: Modification versioning system ou file structure.

Skip-if: Tests presets non critiques.
"""
   
                                       

                                  ^
[1m.\tests\test_worker_pool.py[m[36m:[m52[36m:[m80[36m:[m [1m[31mE501[m line too long (95 > 79 characters)
        futures = [executor.submit(run_single_backtest_worker, args) for args in backtest_args]
                                                                               ^
[1m.\tests\test_worker_pool.py[m[36m:[m66[36m:[m80[36m:[m [1m[31mE501[m line too long (90 > 79 characters)
                print(f"  ‚ùå Run {i+1}/{len(param_grid)}: ERREUR - {result['error'][:50]}")
                                                                               ^
[1m.\tests\test_worker_pool.py[m[36m:[m75[36m:[m80[36m:[m [1m[31mE501[m line too long (90 > 79 characters)
    print(f"  Runs r√©ussis: {sum(1 for r in results if 'error' not in r)}/{len(results)}")
                                                                               ^
[1m.\tests\update_readme_tree.py[m[36m:[m66[36m:[m80[36m:[m [1m[31mE501[m line too long (87 > 79 characters)
def _build_tree_lines(path: Path, rel_path: str, prefix: str, depth: int) -> list[str]:
                                                                               ^
[1m.\tests\update_readme_tree.py[m[36m:[m76[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
            child_rel = entry.name if not rel_path else f"{rel_path}/{entry.name}"
                                                                               ^
[1m.\tests\update_readme_tree.py[m[36m:[m80[36m:[m80[36m:[m [1m[31mE501[m line too long (89 > 79 characters)
                lines.extend(_build_tree_lines(entry, child_rel, next_prefix, depth + 1))
                                                                               ^
[1m.\tests\update_readme_tree.py[m[36m:[m105[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
    README.write_text(f"{before}{block}{after}", encoding="utf-8", newline=newline)
                                                                               ^
[1m.\tests\validate_backtest_integrity.py[m[36m:[m20[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
def validate_backtest_result(result, df, initial_capital=10000.0, verbose=True):
                                                                               ^
[1m.\tests\validate_backtest_integrity.py[m[36m:[m57[36m:[m80[36m:[m [1m[31mE501[m line too long (104 > 79 characters)
        errors.append(f"total_trades n'est pas un entier : {total_trades} (type: {type(total_trades)})")
                                                                               ^
[1m.\tests\validate_backtest_integrity.py[m[36m:[m60[36m:[m80[36m:[m [1m[31mE501[m line too long (91 > 79 characters)
        errors.append(f"total_trades ({total_trades}) ‚â† len(trades_df) ({len(trades_df)})")
                                                                               ^
[1m.\tests\validate_backtest_integrity.py[m[36m:[m64[36m:[m80[36m:[m [1m[31mE501[m line too long (88 > 79 characters)
        print(f"   total_trades = {total_trades} (type: {type(total_trades).__name__})")
                                                                               ^
[1m.\tests\validate_backtest_integrity.py[m[36m:[m98[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
        errors.append(f"{len(invalid_entries)} trades avec entry_ts hors p√©riode")
                                                                               ^
[1m.\tests\validate_backtest_integrity.py[m[36m:[m117[36m:[m80[36m:[m [1m[31mE501[m line too long (88 > 79 characters)
        warnings.append(f"{len(incomplete_trades)} trades incomplets (ferm√©s √† la fin)")
                                                                               ^
[1m.\tests\validate_backtest_integrity.py[m[36m:[m119[36m:[m80[36m:[m [1m[31mE501[m line too long (87 > 79 characters)
            print(f"   ‚ö†Ô∏è  {len(incomplete_trades)} trades ferm√©s √† la derni√®re barre")
                                                                               ^
[1m.\tests\validate_backtest_integrity.py[m[36m:[m147[36m:[m80[36m:[m [1m[31mE501[m line too long (129 > 79 characters)
            errors.append(f"Incoh√©rence P&L: sum(trades)={sum_pnl_trades:.2f} ‚â† metrics={metrics_pnl:.2f} (diff={diff_pnl:.2f})")
                                                                               ^
[1m.\tests\validate_backtest_integrity.py[m[36m:[m170[36m:[m80[36m:[m [1m[31mE501[m line too long (97 > 79 characters)
        errors.append(f"Equity start={equity_start:.2f} ‚â† initial_capital={initial_capital:.2f}")
                                                                               ^
[1m.\tests\validate_backtest_integrity.py[m[36m:[m172[36m:[m80[36m:[m [1m[31mE501[m line too long (90 > 79 characters)
            print(f"   ‚ùå equity[0] = {equity_start:.2f} (attendu: {initial_capital:.2f})")
                                                                               ^
[1m.\tests\validate_backtest_integrity.py[m[36m:[m182[36m:[m80[36m:[m [1m[31mE501[m line too long (116 > 79 characters)
        errors.append(f"Equity finale={equity_end:.2f} ‚â† capital+PnL={expected_final:.2f} (diff={diff_equity:.2f})")
                                                                               ^
[1m.\tests\validate_backtest_integrity.py[m[36m:[m203[36m:[m80[36m:[m [1m[31mE501[m line too long (99 > 79 characters)
        warnings.append(f"Equity a seulement {equity_unique_values} valeurs uniques (MTM suspect)")
                                                                               ^
[1m.\tests\validate_backtest_integrity.py[m[36m:[m205[36m:[m80[36m:[m [1m[31mE501[m line too long (101 > 79 characters)
            print(f"   ‚ö†Ô∏è  Equity a {equity_unique_values} valeurs uniques sur {len(equity)} barres")
                                                                               ^
[1m.\tests\validate_backtest_integrity.py[m[36m:[m209[36m:[m80[36m:[m [1m[31mE501[m line too long (97 > 79 characters)
            print(f"   ‚úÖ Equity varie correctement : {equity_changes}/{len(equity)} changements")
                                                                               ^
[1m.\tests\validate_backtest_integrity.py[m[36m:[m223[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
                print(f"      Entry: {row['entry_ts']}, Exit: {row['exit_ts']}")
                                                                               ^
[1m.\tests\validate_backtest_integrity.py[m[36m:[m264[36m:[m80[36m:[m [1m[31mE501[m line too long (98 > 79 characters)
        df = pd.read_csv('data/sample_data/BTCUSDT_1h_6months.csv', index_col=0, parse_dates=True)
                                                                               ^
[1m.\tests\validate_backtest_integrity.py[m[36m:[m288[36m:[m80[36m:[m [1m[31mE501[m line too long (89 > 79 characters)
        result = engine.run(df=df, strategy='atr_channel', params=params, timeframe='1h')
                                                                               ^
[1m.\tests\validate_backtest_integrity.py[m[36m:[m290[36m:[m80[36m:[m [1m[31mE501[m line too long (94 > 79 characters)
        validation = validate_backtest_result(result, df, initial_capital=10000, verbose=True)
                                                                               ^
[1m.\tests\verify_install.py[m[36m:[m5[36m:[m80[36m:[m [1m[31mE501[m line too long (93 > 79 characters)
"""
Module-ID: verify_install

Purpose: V√©rifier installation compl√®te de toutes d√©pendances (core, UI, perf, testing, LLM).

Role in pipeline: installation validation

Key components: check_module(), affichage r√©sultat, colorisation

Inputs: Aucun (v√©rifie sys.modules)

Outputs: Rapport d'installation (core, UI, perf, LLM) avec ‚úì/‚úó

Dependencies: sys, importlib, colorama (optionnel)

Conventions: D√©pendances par cat√©gorie (Core, UI, Perf, LLM, Testing)

Read-if: Installation premi√®re ou d√©pannage imports manquants.

Skip-if: Environnement d√©j√† v√©rifi√©.
"""
   
                         

                                                ^
[1m.\tests\verify_install.py[m[36m:[m75[36m:[m80[36m:[m [1m[31mE501[m line too long (86 > 79 characters)
    if major < required_major or (major == required_major and minor < required_minor):
                                                                               ^
[1m.\tests\verify_install.py[m[36m:[m115[36m:[m80[36m:[m [1m[31mE501[m line too long (88 > 79 characters)
        print(f"\n‚úÖ {len(success)}/{len(DEPENDENCIES)} packages install√©s avec succ√®s:")
                                                                               ^
[1m.\tests\verify_token_coverage.py[m[36m:[m5[36m:[m80[36m:[m [1m[31mE501[m line too long (109 > 79 characters)
"""
Module-ID: verify_token_coverage

Purpose: V√©rifier couverture donn√©es OHLCV par token et timeframe - affiche p√©riodes de backtest disponibles.

Role in pipeline: data validation

Key components: analyze_token_coverage(), affichage format√©

Inputs: Dossier parquet avec fichiers SYMBOL_TIMEFRAME.parquet

Outputs: Tableaux couverture par token/timeframe, statistiques dates

Dependencies: pandas, pathlib, collections

Conventions: Fichiers nomm√©s SYMBOL_TIMEFRAME.ext; parquet lu avec pandas.read_parquet()

Read-if: V√©rifier disponibilit√© donn√©es avant backtest.

Skip-if: Donn√©es compl√®tes et valid√©es.
"""
   
                                

                                         ^
[1m.\tests\verify_token_coverage.py[m[36m:[m17[36m:[m80[36m:[m [1m[31mE501[m line too long (88 > 79 characters)
"""
Module-ID: verify_token_coverage

Purpose: V√©rifier couverture donn√©es OHLCV par token et timeframe - affiche p√©riodes de backtest disponibles.

Role in pipeline: data validation

Key components: analyze_token_coverage(), affichage format√©

Inputs: Dossier parquet avec fichiers SYMBOL_TIMEFRAME.parquet

Outputs: Tableaux couverture par token/timeframe, statistiques dates

Dependencies: pandas, pathlib, collections

Conventions: Fichiers nomm√©s SYMBOL_TIMEFRAME.ext; parquet lu avec pandas.read_parquet()

Read-if: V√©rifier disponibilit√© donn√©es avant backtest.

Skip-if: Donn√©es compl√®tes et valid√©es.
"""
   
                                

                                         ^
[1m.\tests\verify_token_coverage.py[m[36m:[m68[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
            if token_filter and not token.upper().startswith(token_filter.upper()):
                                                                               ^
[1m.\tests\verify_token_coverage.py[m[36m:[m78[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
                    df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms')
                                                                               ^
[1m.\tests\verify_token_coverage.py[m[36m:[m110[36m:[m80[36m:[m [1m[31mE501[m line too long (90 > 79 characters)
        print(f"\n{'Timeframe':<10} {'D√©but':<20} {'Fin':<20} {'Barres':>8} {'Jours':>6}")
                                                                               ^
[1m.\tests\verify_token_coverage.py[m[36m:[m127[36m:[m80[36m:[m [1m[31mE501[m line too long (90 > 79 characters)
                print(f"{tf:<10} {start.date()} {start.time()} {end.date()} {end.time()} "
                                                                               ^
[1m.\tests\verify_token_coverage.py[m[36m:[m149[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
                print(f"   Plus ancienne : {min_start.date()} {min_start.time()}")
                                                                               ^
[1m.\tests\verify_token_coverage.py[m[36m:[m150[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
                print(f"   Plus r√©cente  : {max_start.date()} {max_start.time()}")
                                                                               ^
[1m.\tests\verify_token_coverage.py[m[36m:[m169[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
                print("\nüìä P√âRIODE COMMUNE (intersection de tous les timeframes):")
                                                                               ^
[1m.\tests\verify_token_coverage.py[m[36m:[m170[36m:[m80[36m:[m [1m[31mE501[m line too long (94 > 79 characters)
                print(f"   {common_start.date()} ‚Üí {common_end.date()} ({common_days} jours)")
                                                                               ^
[1m.\tests\verify_ui_imports.py[m[36m:[m24[36m:[m80[36m:[m [1m[31mE501[m line too long (85 > 79 characters)
    print(f"   ‚úÖ STRATEGY_INDICATORS_MAP: {len(strategy_indicators_map)} strat√©gies")
                                                                               ^
[1m.\ui\app.py[m[36m:[m4[36m:[m80[36m:[m [1m[31mE501[m line too long (96 > 79 characters)
"""
Module-ID: ui.app

Purpose: Application Streamlit principale - UI orchestration, page config, sidebar/main/results.

Role in pipeline: user interface

Key components: configure_page(), install_best_pnl_tracker(), main()

Inputs: Streamlit state, user interactions

Outputs: Rendered UI pages (setup, backtest, results, analysis)

Dependencies: streamlit, ui.*, backtest.*, utils.observability

Conventions: PYTHONPATH setup; init_logging() first; st.set_page_config() before sidebar.

Read-if: Modification page layout ou flow control.

Skip-if: Vous lancez juste `streamlit run ui/app.py`.
"""
   
                 

                                                        ^
[1m.\ui\app.py[m[36m:[m16[36m:[m80[36m:[m [1m[31mE501[m line too long (89 > 79 characters)
"""
Module-ID: ui.app

Purpose: Application Streamlit principale - UI orchestration, page config, sidebar/main/results.

Role in pipeline: user interface

Key components: configure_page(), install_best_pnl_tracker(), main()

Inputs: Streamlit state, user interactions

Outputs: Rendered UI pages (setup, backtest, results, analysis)

Dependencies: streamlit, ui.*, backtest.*, utils.observability

Conventions: PYTHONPATH setup; init_logging() first; st.set_page_config() before sidebar.

Read-if: Modification page layout ou flow control.

Skip-if: Vous lancez juste `streamlit run ui/app.py`.
"""
   
                 

                                                        ^
[1m.\ui\app.py[m[36m:[m35[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
from ui.context import BACKEND_AVAILABLE, IMPORT_ERROR, LLM_AVAILABLE  # noqa: E402
                                                                               ^
[1m.\ui\app.py[m[36m:[m37[36m:[m80[36m:[m [1m[31mE501[m line too long (85 > 79 characters)
from ui.main import render_controls, render_main, render_setup_previews  # noqa: E402
                                                                               ^
[1m.\ui\app.py[m[36m:[m71[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
    optimization_mode = st.session_state.get("optimization_mode", "Backtest Simple")
                                                                               ^
[1m.\ui\components\__init__.py[m[36m:[m4[36m:[m80[36m:[m [1m[31mE501[m line too long (103 > 79 characters)
"""
Module-ID: ui.components.__init__

Purpose: Package UI components - centralizes re-exports (charts, monitor, selector, validation, sweep).

Role in pipeline: user interface

Key components: Re-exports render_* functions from active modules

Inputs: None (module imports only)

Outputs: Public API via __all__

Dependencies: .charts, .monitor, .model_selector, .validation_viewer, .sweep_monitor

Conventions: __all__ d√©finit API publique; imports optionnels si deps manquent.

Read-if: Ajout nouveau component ou modification structure.

Skip-if: Vous importez directement depuis ui.components.charts.
"""
   
                                 

                                        ^
[1m.\ui\components\__init__.py[m[36m:[m14[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
"""
Module-ID: ui.components.__init__

Purpose: Package UI components - centralizes re-exports (charts, monitor, selector, validation, sweep).

Role in pipeline: user interface

Key components: Re-exports render_* functions from active modules

Inputs: None (module imports only)

Outputs: Public API via __all__

Dependencies: .charts, .monitor, .model_selector, .validation_viewer, .sweep_monitor

Conventions: __all__ d√©finit API publique; imports optionnels si deps manquent.

Read-if: Ajout nouveau component ou modification structure.

Skip-if: Vous importez directement depuis ui.components.charts.
"""
   
                                 

                                        ^
[1m.\ui\components\agent_timeline.py[m[36m:[m4[36m:[m80[36m:[m [1m[31mE501[m line too long (115 > 79 characters)
"""
Module-ID: ui.components.agent_timeline

Purpose: Timeline visuelle activit√© agents LLM - events d√©tails par agent (Analyst, Strategist, Critic, Validator).

Role in pipeline: visualization/monitoring

Key components: AgentActivity, AgentActivityTimeline, render_agent_timeline(), render_mini_timeline()

Inputs: Agent events (timestamps, decisions, metrics)

Outputs: Plotly interactive timeline Streamlit

Dependencies: streamlit, plotly, dataclasses

Conventions: AgentType enum, ActivityType categorization, metrics snapshot

Read-if: Afficher timeline agents LLM.

Skip-if: Pas d'agents LLM ou monitoring minimal.

Usage:
    >>> from ui.components.agent_timeline import render_agent_timeline
    >>> render_agent_timeline(timeline)
"""
   
                                       

                                  ^
[1m.\ui\components\agent_timeline.py[m[36m:[m8[36m:[m80[36m:[m [1m[31mE501[m line too long (101 > 79 characters)
"""
Module-ID: ui.components.agent_timeline

Purpose: Timeline visuelle activit√© agents LLM - events d√©tails par agent (Analyst, Strategist, Critic, Validator).

Role in pipeline: visualization/monitoring

Key components: AgentActivity, AgentActivityTimeline, render_agent_timeline(), render_mini_timeline()

Inputs: Agent events (timestamps, decisions, metrics)

Outputs: Plotly interactive timeline Streamlit

Dependencies: streamlit, plotly, dataclasses

Conventions: AgentType enum, ActivityType categorization, metrics snapshot

Read-if: Afficher timeline agents LLM.

Skip-if: Pas d'agents LLM ou monitoring minimal.

Usage:
    >>> from ui.components.agent_timeline import render_agent_timeline
    >>> render_agent_timeline(timeline)
"""
   
                                       

                                  ^
[1m.\ui\components\agent_timeline.py[m[36m:[m104[36m:[m80[36m:[m [1m[31mE501[m line too long (85 > 79 characters)
    """
    Data carrier for a single agent event inside the orchestration timeline.

    Responsible for keeping metadata (agent type, activity type, iteration, duration)
    so that the UI can plot decisions and alerts without leaking orchestration logic.
    Lifecycle: created by `AgentActivityTimeline.log_activity` when the orchestrator
    reports a new event, then rendered in the Streamlit timeline panels.
    """
       
                                                                       ^
[1m.\ui\components\agent_timeline.py[m[36m:[m105[36m:[m80[36m:[m [1m[31mE501[m line too long (85 > 79 characters)
    """
    Data carrier for a single agent event inside the orchestration timeline.

    Responsible for keeping metadata (agent type, activity type, iteration, duration)
    so that the UI can plot decisions and alerts without leaking orchestration logic.
    Lifecycle: created by `AgentActivityTimeline.log_activity` when the orchestrator
    reports a new event, then rendered in the Streamlit timeline panels.
    """
       
                                                                       ^
[1m.\ui\components\agent_timeline.py[m[36m:[m106[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
    """
    Data carrier for a single agent event inside the orchestration timeline.

    Responsible for keeping metadata (agent type, activity type, iteration, duration)
    so that the UI can plot decisions and alerts without leaking orchestration logic.
    Lifecycle: created by `AgentActivityTimeline.log_activity` when the orchestrator
    reports a new event, then rendered in the Streamlit timeline panels.
    """
       
                                                                       ^
[1m.\ui\components\agent_timeline.py[m[36m:[m172[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
    """
    Represents a discrete decision emitted by an agent.

    Encapsulates agent identity, reasoning and confidence so that the UI can render
    proposal/approval flows in the timeline. Decisions are collected during a run and
    displayed in the Streamlit detail tab, never altering engine state.
    """
       
                                                       

              ^
[1m.\ui\components\agent_timeline.py[m[36m:[m173[36m:[m80[36m:[m [1m[31mE501[m line too long (85 > 79 characters)
    """
    Represents a discrete decision emitted by an agent.

    Encapsulates agent identity, reasoning and confidence so that the UI can render
    proposal/approval flows in the timeline. Decisions are collected during a run and
    displayed in the Streamlit detail tab, never altering engine state.
    """
       
                                                       

              ^
[1m.\ui\components\agent_timeline.py[m[36m:[m197[36m:[m80[36m:[m [1m[31mE501[m line too long (91 > 79 characters)
    """
    Stateful container that records agent activities, decisions, and metrics for a session.

    Position: UI instrumentation layer that subscribes to orchestrator events.
    Responsibilities: aggregate activities/decisions per iteration, compute summary,
    expose serialization helpers, and drive the timeline renderers.
    Lifecycle: created at start of a backtest session, receives `log_activity`/`log_decision`,
    then passed to Streamlit renderers (`render_agent_timeline`, `render_mini_timeline`).
    """
       
                                                                       ^
[1m.\ui\components\agent_timeline.py[m[36m:[m200[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
    """
    Stateful container that records agent activities, decisions, and metrics for a session.

    Position: UI instrumentation layer that subscribes to orchestrator events.
    Responsibilities: aggregate activities/decisions per iteration, compute summary,
    expose serialization helpers, and drive the timeline renderers.
    Lifecycle: created at start of a backtest session, receives `log_activity`/`log_decision`,
    then passed to Streamlit renderers (`render_agent_timeline`, `render_mini_timeline`).
    """
       
                                                                       ^
[1m.\ui\components\agent_timeline.py[m[36m:[m202[36m:[m80[36m:[m [1m[31mE501[m line too long (94 > 79 characters)
    """
    Stateful container that records agent activities, decisions, and metrics for a session.

    Position: UI instrumentation layer that subscribes to orchestrator events.
    Responsibilities: aggregate activities/decisions per iteration, compute summary,
    expose serialization helpers, and drive the timeline renderers.
    Lifecycle: created at start of a backtest session, receives `log_activity`/`log_decision`,
    then passed to Streamlit renderers (`render_agent_timeline`, `render_mini_timeline`).
    """
       
                                                                       ^
[1m.\ui\components\agent_timeline.py[m[36m:[m203[36m:[m80[36m:[m [1m[31mE501[m line too long (89 > 79 characters)
    """
    Stateful container that records agent activities, decisions, and metrics for a session.

    Position: UI instrumentation layer that subscribes to orchestrator events.
    Responsibilities: aggregate activities/decisions per iteration, compute summary,
    expose serialization helpers, and drive the timeline renderers.
    Lifecycle: created at start of a backtest session, receives `log_activity`/`log_decision`,
    then passed to Streamlit renderers (`render_agent_timeline`, `render_mini_timeline`).
    """
       
                                                                       ^
[1m.\ui\components\agent_timeline.py[m[36m:[m352[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
    def get_activities_by_iteration(self, iteration: int) -> List[AgentActivity]:
                                                                               ^
[1m.\ui\components\agent_timeline.py[m[36m:[m365[36m:[m80[36m:[m [1m[31mE501[m line too long (87 > 79 characters)
            activities_by_agent[agent.value] = len(self.get_activities_by_agent(agent))
                                                                               ^
[1m.\ui\components\agent_timeline.py[m[36m:[m425[36m:[m80[36m:[m [1m[31mE501[m line too long (88 > 79 characters)
    """
    Builds the Plotly figure used by the timeline renderer.

    This function anchors the streamlit panel with a Gantt-like view of agent activities
    and a summary of metrics history. It is called with the timeline produced by
    `AgentActivityTimeline` just before plotting.

    Args:
        timeline: Timeline containing the current run's activities and metrics.

    Returns:
        Plotly Figure ready for `st.plotly_chart`.
    """
       
                                                           

          ^
[1m.\ui\components\agent_timeline.py[m[36m:[m426[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
    """
    Builds the Plotly figure used by the timeline renderer.

    This function anchors the streamlit panel with a Gantt-like view of agent activities
    and a summary of metrics history. It is called with the timeline produced by
    `AgentActivityTimeline` just before plotting.

    Args:
        timeline: Timeline containing the current run's activities and metrics.

    Returns:
        Plotly Figure ready for `st.plotly_chart`.
    """
       
                                                           

          ^
[1m.\ui\components\agent_timeline.py[m[36m:[m452[36m:[m80[36m:[m [1m[31mE501[m line too long (93 > 79 characters)
        text = [f"{ACTIVITY_ICONS.get(a.activity_type, '')} {a.message}" for a in activities]
                                                                               ^
[1m.\ui\components\agent_timeline.py[m[36m:[m465[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
                text=[ACTIVITY_ICONS.get(a.activity_type, "‚Ä¢") for a in activities],
                                                                               ^
[1m.\ui\components\agent_timeline.py[m[36m:[m541[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
    """
    Streamlit panel that surfaces agent activity and metrics history.

    Called after each orchestration run to visualize session health for analysts.

    Args:
        timeline: Activity timeline collected from the orchestrator.
        key: Unique widget key to allow reruns without collision.
    """
       
                                                                     

^
[1m.\ui\components\agent_timeline.py[m[36m:[m618[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
                st.progress(dec.confidence, text=f"Confiance: {dec.confidence:.0%}")
                                                                               ^
[1m.\ui\components\agent_timeline.py[m[36m:[m641[36m:[m80[36m:[m [1m[31mE501[m line too long (90 > 79 characters)
                    f"üèÜ Meilleur r√©sultat (Iter {summary['best_metrics']['iteration']}): "
                                                                               ^
[1m.\ui\components\agent_timeline.py[m[36m:[m671[36m:[m80[36m:[m [1m[31mE501[m line too long (87 > 79 characters)
    """
    Compact sidebar summary of the most recent agent events.

    Used by the sidebar to keep orchestration feedback visible while running backtests.

    Args:
        timeline: Same timeline instance rendered in the main panel.
        max_activities: Maximum number items shown for quick review.
        key: Widget key to avoid Streamlit collisions.
    """
       
                                                            

         ^
[1m.\ui\components\archive\indicator_explorer.py[m[36m:[m4[36m:[m80[36m:[m [1m[31mE501[m line too long (114 > 79 characters)
"""
Module-ID: ui.components.archive.indicator_explorer

Purpose: Explorateur indicateurs interactif Phase 5.3 - visualiser indicateurs techniques avec overlay prix OHLCV.

Role in pipeline: visualization (archive)

Key components: IndicatorExplorer, render_explorer(), dynamique param inputs

Inputs: DataFrame OHLCV, indicateur s√©lectionn√©, params

Outputs: Graphique Plotly interactif (candlesticks + indicateur)

Dependencies: streamlit, plotly, indicators.registry

Conventions: Composant Streamlit optionnel

Read-if: Vous voulez explorer/visualiser indicateurs.

Skip-if: Archive - utiliser composants actifs ui/components/
"""
   
                                                   

                      ^
[1m.\ui\components\archive\indicator_explorer.py[m[36m:[m41[36m:[m80[36m:[m [1m[31mE501[m line too long (87 > 79 characters)
    from indicators.registry import calculate_indicator, get_indicator, list_indicators
                                                                               ^
[1m.\ui\components\archive\indicator_explorer.py[m[36m:[m46[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
from utils.indicator_ranges import get_indicator_param_specs, load_indicator_ranges
                                                                               ^
[1m.\ui\components\archive\indicator_explorer.py[m[36m:[m69[36m:[m80[36m:[m [1m[31mE501[m line too long (98 > 79 characters)
    secondary_colors: List[str] = field(default_factory=lambda: ["#ff7f0e", "#2ca02c", "#d62728"])
                                                                               ^
[1m.\ui\components\archive\indicator_explorer.py[m[36m:[m94[36m:[m80[36m:[m [1m[31mE501[m line too long (86 > 79 characters)
    "rsi": {"type": IndicatorType.OSCILLATOR, "color": "#9c27b0", "levels": [30, 70]},
                                                                               ^
[1m.\ui\components\archive\indicator_explorer.py[m[36m:[m95[36m:[m80[36m:[m [1m[31mE501[m line too long (93 > 79 characters)
    "stochastic": {"type": IndicatorType.OSCILLATOR, "color": "#2196f3", "levels": [20, 80]},
                                                                               ^
[1m.\ui\components\archive\indicator_explorer.py[m[36m:[m96[36m:[m80[36m:[m [1m[31mE501[m line too long (92 > 79 characters)
    "stoch_rsi": {"type": IndicatorType.OSCILLATOR, "color": "#00bcd4", "levels": [20, 80]},
                                                                               ^
[1m.\ui\components\archive\indicator_explorer.py[m[36m:[m97[36m:[m80[36m:[m [1m[31mE501[m line too long (95 > 79 characters)
    "williams_r": {"type": IndicatorType.OSCILLATOR, "color": "#ff9800", "levels": [-80, -20]},
                                                                               ^
[1m.\ui\components\archive\indicator_explorer.py[m[36m:[m98[36m:[m80[36m:[m [1m[31mE501[m line too long (89 > 79 characters)
    "cci": {"type": IndicatorType.OSCILLATOR, "color": "#4caf50", "levels": [-100, 100]},
                                                                               ^
[1m.\ui\components\archive\indicator_explorer.py[m[36m:[m99[36m:[m80[36m:[m [1m[31mE501[m line too long (86 > 79 characters)
    "mfi": {"type": IndicatorType.OSCILLATOR, "color": "#e91e63", "levels": [20, 80]},
                                                                               ^
[1m.\ui\components\archive\indicator_explorer.py[m[36m:[m101[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
    "adx": {"type": IndicatorType.OSCILLATOR, "color": "#ff5722", "levels": [25]},
                                                                               ^
[1m.\ui\components\archive\indicator_explorer.py[m[36m:[m110[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
    "standard_deviation": {"type": IndicatorType.OSCILLATOR, "color": "#795548"},
                                                                               ^
[1m.\ui\components\archive\indicator_explorer.py[m[36m:[m114[36m:[m80[36m:[m [1m[31mE501[m line too long (93 > 79 characters)
    "fear_greed": {"type": IndicatorType.OSCILLATOR, "color": "#ffc107", "levels": [20, 80]},
                                                                               ^
[1m.\ui\components\archive\indicator_explorer.py[m[36m:[m230[36m:[m80[36m:[m [1m[31mE501[m line too long (96 > 79 characters)
            colors = [color] + config.get("secondary_colors", ["#ff7f0e", "#2ca02c", "#d62728"])
                                                                               ^
[1m.\ui\components\archive\indicator_explorer.py[m[36m:[m284[36m:[m80[36m:[m [1m[31mE501[m line too long (119 > 79 characters)
                            marker_color=colors_hist.tolist() if hasattr(colors_hist, 'tolist') else list(colors_hist),
                                                                               ^
[1m.\ui\components\archive\indicator_explorer.py[m[36m:[m637[36m:[m80[36m:[m [1m[31mE501[m line too long (86 > 79 characters)
        elif param.default_factory is not MISSING:  # type: ignore[comparison-overlap]
                                                                               ^
[1m.\ui\components\archive\indicator_explorer.py[m[36m:[m678[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
            return {"upper": result[0], "middle": result[1], "lower": result[2]}
                                                                               ^
[1m.\ui\components\archive\indicator_explorer.py[m[36m:[m714[36m:[m80[36m:[m [1m[31mE501[m line too long (94 > 79 characters)
        available_indicators = {name: info.function for name, info in indicator_infos.items()}
                                                                               ^
[1m.\ui\components\archive\indicator_explorer.py[m[36m:[m728[36m:[m80[36m:[m [1m[31mE501[m line too long (89 > 79 characters)
            show_volume = st.checkbox("Afficher volume", value=True, key=f"{key}_volume")
                                                                               ^
[1m.\ui\components\archive\indicator_explorer.py[m[36m:[m730[36m:[m80[36m:[m [1m[31mE501[m line too long (88 > 79 characters)
            range_slider = st.checkbox("Range slider", value=False, key=f"{key}_slider")
                                                                               ^
[1m.\ui\components\archive\indicator_explorer.py[m[36m:[m790[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
                # Param√®tres depuis indicator_ranges.toml (fallback settings_class)
                                                                               ^
[1m.\ui\components\archive\indicator_explorer.py[m[36m:[m792[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
                param_specs = get_indicator_param_specs(ind_name, indicator_ranges)
                                                                               ^
[1m.\ui\components\archive\indicator_explorer.py[m[36m:[m798[36m:[m80[36m:[m [1m[31mE501[m line too long (86 > 79 characters)
                if info and info.settings_class and is_dataclass(info.settings_class):
                                                                               ^
[1m.\ui\components\archive\indicator_explorer.py[m[36m:[m799[36m:[m80[36m:[m [1m[31mE501[m line too long (90 > 79 characters)
                    allowed_params = {field.name for field in fields(info.settings_class)}
                                                                               ^
[1m.\ui\components\archive\indicator_explorer.py[m[36m:[m833[36m:[m80[36m:[m [1m[31mE501[m line too long (116 > 79 characters)
                            ) if ind_name.lower() not in ["sma", "ema", "rsi", "momentum", "roc"] else indicator_fn(
                                                                               ^
[1m.\ui\components\archive\indicator_explorer.py[m[36m:[m843[36m:[m80[36m:[m [1m[31mE501[m line too long (88 > 79 characters)
                    default_config = DEFAULT_INDICATOR_CONFIGS.get(ind_name.lower(), {})
                                                                               ^
[1m.\ui\components\archive\indicator_explorer.py[m[36m:[m844[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
                    ind_type = default_config.get("type", IndicatorType.OVERLAY)
                                                                               ^
[1m.\ui\components\archive\indicator_explorer.py[m[36m:[m872[36m:[m80[36m:[m [1m[31mE501[m line too long (90 > 79 characters)
                        if isinstance(info["stats"], dict) and "current" in info["stats"]:
                                                                               ^
[1m.\ui\components\archive\indicator_explorer.py[m[36m:[m874[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
                            col1.metric("Actuel", f"{info['stats']['current']:.4f}")
                                                                               ^
[1m.\ui\components\archive\indicator_explorer.py[m[36m:[m877[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
                            col4.metric("Moyenne", f"{info['stats']['mean']:.4f}")
                                                                               ^
[1m.\ui\components\archive\indicator_explorer.py[m[36m:[m881[36m:[m80[36m:[m [1m[31mE501[m line too long (93 > 79 characters)
                                    st.write(f"**{key}**: {stats.get('current', 'N/A'):.4f}")
                                                                               ^
[1m.\ui\components\archive\sweep_monitor.py[m[36m:[m4[36m:[m80[36m:[m [1m[31mE501[m line too long (103 > 79 characters)
"""
Module-ID: ui.components.archive.sweep_monitor

Purpose: Composant monitoring sweep temps r√©el Phase 5.2 - progression, meilleurs r√©sultats, m√©triques.

Role in pipeline: visualization (archive)

Key components: SweepMonitor, render_sweep_progress(), render_sweep_summary()

Inputs: Param grid, backtest results en continu

Outputs: UI temps r√©el avec progress bar, top results

Dependencies: streamlit, backtest.sweep

Conventions: Composant optionnel archive

Read-if: Vous voulez monitoring temps r√©el sweep.

Skip-if: Archive - utiliser composants actifs ui/components/
"""
   
                                              

                           ^
[1m.\ui\components\archive\sweep_monitor.py[m[36m:[m145[36m:[m80[36m:[m [1m[31mE501[m line too long (92 > 79 characters)
        self.objectives = objectives or ['sharpe_ratio', 'total_return_pct', 'max_drawdown']
                                                                               ^
[1m.\ui\components\archive\sweep_monitor.py[m[36m:[m300[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
            moving_avg = np.convolve(values, np.ones(window)/window, mode='valid')
                                                                               ^
[1m.\ui\components\archive\sweep_monitor.py[m[36m:[m316[36m:[m80[36m:[m [1m[31mE501[m line too long (85 > 79 characters)
        legend=dict(orientation="h", yanchor="bottom", y=1.02, xanchor="right", x=1),
                                                                               ^
[1m.\ui\components\archive\sweep_monitor.py[m[36m:[m429[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
        if show_evolution and monitor.get_metric_history(monitor.objectives[0]):
                                                                               ^
[1m.\ui\components\archive\sweep_monitor.py[m[36m:[m442[36m:[m80[36m:[m [1m[31mE501[m line too long (85 > 79 characters)
        tabs = st.tabs([obj.replace('_', ' ').title() for obj in monitor.objectives])
                                                                               ^
[1m.\ui\components\archive\sweep_monitor.py[m[36m:[m490[36m:[m80[36m:[m [1m[31mE501[m line too long (91 > 79 characters)
        st.metric("Taux de pruning", f"{(stats.pruned/stats.total_combinations)*100:.1f}%")
                                                                               ^
[1m.\ui\components\archive\sweep_monitor.py[m[36m:[m498[36m:[m80[36m:[m [1m[31mE501[m line too long (101 > 79 characters)
            with st.expander(f"**{obj.replace('_', ' ').title()}**: {best.metrics.get(obj, 0):.4f}"):
                                                                               ^
[1m.\ui\components\archive\themes.py[m[36m:[m4[36m:[m80[36m:[m [1m[31mE501[m line too long (113 > 79 characters)
"""
Module-ID: ui.components.archive.themes

Purpose: Gestion th√®mes UI et persistance pr√©f√©rences Phase 5.6 - personnaliser apparence + sauvegarder settings.

Role in pipeline: visualization (archive)

Key components: ThemeMode, ColorPalette, set_theme(), get_theme(), persist_settings()

Inputs: Pr√©f√©rences utilisateur (light/dark/auto)

Outputs: Style CSS/Streamlit apply√©

Dependencies: streamlit, json, pathlib

Conventions: Persistance via fichier local .streamlit/config.toml

Read-if: Personnaliser th√®mes ou persistance settings.

Skip-if: Archive - utiliser composants actifs ou th√®mes standard.
"""
   
                                       

                                  ^
[1m.\ui\components\archive\themes.py[m[36m:[m8[36m:[m80[36m:[m [1m[31mE501[m line too long (85 > 79 characters)
"""
Module-ID: ui.components.archive.themes

Purpose: Gestion th√®mes UI et persistance pr√©f√©rences Phase 5.6 - personnaliser apparence + sauvegarder settings.

Role in pipeline: visualization (archive)

Key components: ThemeMode, ColorPalette, set_theme(), get_theme(), persist_settings()

Inputs: Pr√©f√©rences utilisateur (light/dark/auto)

Outputs: Style CSS/Streamlit apply√©

Dependencies: streamlit, json, pathlib

Conventions: Persistance via fichier local .streamlit/config.toml

Read-if: Personnaliser th√®mes ou persistance settings.

Skip-if: Archive - utiliser composants actifs ou th√®mes standard.
"""
   
                                       

                                  ^
[1m.\ui\components\archive\themes.py[m[36m:[m195[36m:[m80[36m:[m [1m[31mE501[m line too long (90 > 79 characters)
    performance_settings: PerformanceSettings = field(default_factory=PerformanceSettings)
                                                                               ^
[1m.\ui\components\archive\themes.py[m[36m:[m233[36m:[m80[36m:[m [1m[31mE501[m line too long (93 > 79 characters)
            performance_settings=PerformanceSettings(**data.get("performance_settings", {})),
                                                                               ^
[1m.\ui\components\archive\themes.py[m[36m:[m417[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
def render_theme_settings(key: str = "theme_settings") -> Optional[UserPreferences]:
                                                                               ^
[1m.\ui\components\archive\themes.py[m[36m:[m471[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
    color_keys = ["primary", "secondary", "success", "warning", "error", "info"]
                                                                               ^
[1m.\ui\components\archive\themes.py[m[36m:[m477[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
            f"<small style='display:block;text-align:center'>{key_name}</small>",
                                                                               ^
[1m.\ui\components\archive\themes.py[m[36m:[m502[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
def render_chart_settings(key: str = "chart_settings") -> Optional[ChartSettings]:
                                                                               ^
[1m.\ui\components\archive\themes.py[m[36m:[m591[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
def render_default_params(key: str = "default_params") -> Optional[DefaultParams]:
                                                                               ^
[1m.\ui\components\archive\themes.py[m[36m:[m654[36m:[m80[36m:[m [1m[31mE501[m line too long (88 > 79 characters)
            index=["1m", "5m", "15m", "1h", "4h", "1d"].index(params.default_timeframe),
                                                                               ^
[1m.\ui\components\archive\thinking_viewer.py[m[36m:[m4[36m:[m80[36m:[m [1m[31mE501[m line too long (98 > 79 characters)
"""
Module-ID: ui.components.archive.thinking_viewer

Purpose: Afficheur pens√©es agents LLM temps r√©el - stream raisonnement, cat√©gorisation, timestamp.

Role in pipeline: visualization (archive)

Key components: ThinkingStreamViewer, ThoughtCategory, render()

Inputs: Flux pens√©es LLM (thinking, conclusion, decision, error)

Outputs: Interface Streamlit affichage stream live

Dependencies: streamlit, dataclasses

Conventions: Composant optionnel archive

Read-if: Afficher pens√©es agents LLM en direct.

Skip-if: Archive - utiliser composants actifs orchestration.
"""
   
                                                

                         ^
[1m.\ui\components\archive\thinking_viewer.py[m[36m:[m96[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
        """
        Ajoute une pens√©e au stream.

        Args:
            agent_name: Nom de l'agent (Analyst, Strategist, Critic, Validator)
            model: Mod√®le LLM utilis√©
            thought: Contenu de la pens√©e
            category: Type de pens√©e ('thinking', 'conclusion', 'decision', 'error')

        Example:
            >>> viewer.add_thought(
            ...     "Strategist",
            ...     "qwq:32b",
            ...     "Testing bb_period=25 with k_sl=2.0",
            ...     "thinking"
            ... )
        """
           
                                    

             
               ^
[1m.\ui\components\archive\thinking_viewer.py[m[36m:[m152[36m:[m80[36m:[m [1m[31mE501[m line too long (85 > 79 characters)
                "Les pens√©es des agents LLM s'afficheront ici pendant l'optimisation"
                                                                               ^
[1m.\ui\components\archive\thinking_viewer.py[m[36m:[m175[36m:[m80[36m:[m [1m[31mE501[m line too long (90 > 79 characters)
        config = category_config.get(entry.category, {"emoji": "üí¨", "alert_type": "info"})
                                                                               ^
[1m.\ui\components\archive\thinking_viewer.py[m[36m:[m185[36m:[m80[36m:[m [1m[31mE501[m line too long (89 > 79 characters)
                f"**{timestamp_str}** | {emoji} **{entry.agent_name}** (`{entry.model}`)"
                                                                               ^
[1m.\ui\components\archive\thinking_viewer.py[m[36m:[m221[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
    """
    Fonction helper pour cr√©er et afficher le viewer en une ligne.

    Args:
        container_key: Cl√© unique pour session state
        max_entries: Nombre maximum de pens√©es √† afficher
        show_header: Afficher le header

    Returns:
        ThinkingStreamViewer: Instance du viewer pour ajouter des pens√©es

    Example:
        >>> # Dans Streamlit:
        >>> viewer = render_thinking_stream()
        >>> # Plus tard, pour ajouter une pens√©e:
        >>> viewer.add_thought("Analyst", "qwq:32b", "Analyzing...", "thinking")
    """
       
                                                                  

   ^
[1m.\ui\components\archive\validation_viewer.py[m[36m:[m4[36m:[m80[36m:[m [1m[31mE501[m line too long (114 > 79 characters)
"""
Module-ID: ui.components.archive.validation_viewer

Purpose: Afficheur rapports walk-forward Phase 5.5 - visualiser r√©sultats validation anti-overfitting par fen√™tre.

Role in pipeline: visualization (archive)

Key components: ValidationStatus, render_validation_report(), fenetre details, m√©triques

Inputs: WalkForwardResult, metriques, overfitting ratio

Outputs: Interface Streamlit multi-onglets (overview, details, metrics)

Dependencies: streamlit, plotly, backtest.validation

Conventions: Composant optionnel archive

Read-if: Afficher rapports walk-forward d√©taill√©s.

Skip-if: Archive - utiliser composants actifs validation.
"""
   
                                                  

                       ^
[1m.\ui\components\archive\validation_viewer.py[m[36m:[m8[36m:[m80[36m:[m [1m[31mE501[m line too long (88 > 79 characters)
"""
Module-ID: ui.components.archive.validation_viewer

Purpose: Afficheur rapports walk-forward Phase 5.5 - visualiser r√©sultats validation anti-overfitting par fen√™tre.

Role in pipeline: visualization (archive)

Key components: ValidationStatus, render_validation_report(), fenetre details, m√©triques

Inputs: WalkForwardResult, metriques, overfitting ratio

Outputs: Interface Streamlit multi-onglets (overview, details, metrics)

Dependencies: streamlit, plotly, backtest.validation

Conventions: Composant optionnel archive

Read-if: Afficher rapports walk-forward d√©taill√©s.

Skip-if: Archive - utiliser composants actifs validation.
"""
   
                                                  

                       ^
[1m.\ui\components\archive\validation_viewer.py[m[36m:[m112[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
            "train_period": f"{self.train_start.date()} ‚Üí {self.train_end.date()}",
                                                                               ^
[1m.\ui\components\archive\validation_viewer.py[m[36m:[m113[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
            "test_period": f"{self.test_start.date()} ‚Üí {self.test_end.date()}",
                                                                               ^
[1m.\ui\components\archive\validation_viewer.py[m[36m:[m139[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
    _aggregate_metrics: Optional[Dict[str, float]] = field(default=None, repr=False)
                                                                               ^
[1m.\ui\components\archive\validation_viewer.py[m[36m:[m166[36m:[m80[36m:[m [1m[31mE501[m line too long (103 > 79 characters)
            "consistency_ratio": float(np.mean([1 if w.test_sharpe > 0 else 0 for w in self.windows])),
                                                                               ^
[1m.\ui\components\archive\validation_viewer.py[m[36m:[m167[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
            "overfitting_windows": sum(1 for w in self.windows if w.is_overfitting),
                                                                               ^
[1m.\ui\components\archive\validation_viewer.py[m[36m:[m324[36m:[m80[36m:[m [1m[31mE501[m line too long (96 > 79 characters)
    colors = ["#f44336" if d > 50 else "#ff9800" if d > 30 else "#4caf50" for d in degradations]
                                                                               ^
[1m.\ui\components\archive\validation_viewer.py[m[36m:[m411[36m:[m80[36m:[m [1m[31mE501[m line too long (85 > 79 characters)
        f"<span style='background-color:{status_color};color:white;padding:5px 15px;"
                                                                               ^
[1m.\ui\components\archive\validation_viewer.py[m[36m:[m489[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
        with st.expander(f"Fen√™tre {w.window_id} {status_icon}", expanded=False):
                                                                               ^
[1m.\ui\components\archive\validation_viewer.py[m[36m:[m494[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
                st.write(f"P√©riode: {w.train_start.date()} ‚Üí {w.train_end.date()}")
                                                                               ^
[1m.\ui\components\archive\validation_viewer.py[m[36m:[m502[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
                st.write(f"P√©riode: {w.test_start.date()} ‚Üí {w.test_end.date()}")
                                                                               ^
[1m.\ui\components\archive\validation_viewer.py[m[36m:[m517[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
            "‚úÖ **Strat√©gie valid√©e** - Les performances sont consistantes entre "
                                                                               ^
[1m.\ui\components\archive\validation_viewer.py[m[36m:[m518[36m:[m80[36m:[m [1m[31mE501[m line too long (87 > 79 characters)
            "l'entra√Ænement et le test. La strat√©gie peut √™tre utilis√©e en production."
                                                                               ^
[1m.\ui\components\archive\validation_viewer.py[m[36m:[m527[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
            "‚ö†Ô∏è **Attention** - D√©gradation significative entre train et test. "
                                                                               ^
[1m.\ui\components\archive\validation_viewer.py[m[36m:[m533[36m:[m80[36m:[m [1m[31mE501[m line too long (89 > 79 characters)
            "üìà‚ùå **Overfitting d√©tect√©** - Les performances train ne se g√©n√©ralisent pas "
                                                                               ^
[1m.\ui\components\archive\validation_viewer.py[m[36m:[m534[36m:[m80[36m:[m [1m[31mE501[m line too long (95 > 79 characters)
            "sur les donn√©es de test. Simplifiez la strat√©gie ou utilisez moins de param√®tres."
                                                                               ^
[1m.\ui\components\archive\validation_viewer.py[m[36m:[m539[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
            "‚ùå **√âchec de validation** - La strat√©gie ne performe pas de mani√®re "
                                                                               ^
[1m.\ui\components\archive\validation_viewer.py[m[36m:[m583[36m:[m80[36m:[m [1m[31mE501[m line too long (87 > 79 characters)
            f"<div style='border-left: 4px solid {status_color}; padding-left: 10px;'>"
                                                                               ^
[1m.\ui\components\charts.py[m[36m:[m4[36m:[m80[36m:[m [1m[31mE501[m line too long (92 > 79 characters)
"""
Module-ID: ui.components.charts

Purpose: Renderers Plotly/Seaborn pour UI - equity, OHLCV, comparaisons, strat√©gie diagrams.

Role in pipeline: visualization

Key components: render_equity_and_drawdown(), render_ohlcv_with_trades(), render_comparison_chart()

Inputs: Series/DataFrames (equity, OHLCV, metrics), trade results

Outputs: Plotly figures, Streamlit renderers

Dependencies: plotly, seaborn, pandas, streamlit (optionnel)

Conventions: Couleurs coh√©rentes; resampler pour performance; tooltips interactifs.

Read-if: Modification styling/layout graphiques ou ajout nouveau chart type.

Skip-if: Vous appelez render_equity_and_drawdown(equity, drawdown).
"""
   
                               

                                          ^
[1m.\ui\components\charts.py[m[36m:[m8[36m:[m80[36m:[m [1m[31mE501[m line too long (99 > 79 characters)
"""
Module-ID: ui.components.charts

Purpose: Renderers Plotly/Seaborn pour UI - equity, OHLCV, comparaisons, strat√©gie diagrams.

Role in pipeline: visualization

Key components: render_equity_and_drawdown(), render_ohlcv_with_trades(), render_comparison_chart()

Inputs: Series/DataFrames (equity, OHLCV, metrics), trade results

Outputs: Plotly figures, Streamlit renderers

Dependencies: plotly, seaborn, pandas, streamlit (optionnel)

Conventions: Couleurs coh√©rentes; resampler pour performance; tooltips interactifs.

Read-if: Modification styling/layout graphiques ou ajout nouveau chart type.

Skip-if: Vous appelez render_equity_and_drawdown(equity, drawdown).
"""
   
                               

                                          ^
[1m.\ui\components\charts.py[m[36m:[m16[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
"""
Module-ID: ui.components.charts

Purpose: Renderers Plotly/Seaborn pour UI - equity, OHLCV, comparaisons, strat√©gie diagrams.

Role in pipeline: visualization

Key components: render_equity_and_drawdown(), render_ohlcv_with_trades(), render_comparison_chart()

Inputs: Series/DataFrames (equity, OHLCV, metrics), trade results

Outputs: Plotly figures, Streamlit renderers

Dependencies: plotly, seaborn, pandas, streamlit (optionnel)

Conventions: Couleurs coh√©rentes; resampler pour performance; tooltips interactifs.

Read-if: Modification styling/layout graphiques ou ajout nouveau chart type.

Skip-if: Vous appelez render_equity_and_drawdown(equity, drawdown).
"""
   
                               

                                          ^
[1m.\ui\components\charts.py[m[36m:[m201[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
    if "entry_time" not in trades_df.columns and "entry_ts" in trades_df.columns:
                                                                               ^
[1m.\ui\components\charts.py[m[36m:[m205[36m:[m80[36m:[m [1m[31mE501[m line too long (85 > 79 characters)
    if "entry_price" not in trades_df.columns and "price_entry" in trades_df.columns:
                                                                               ^
[1m.\ui\components\charts.py[m[36m:[m207[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
    if "exit_price" not in trades_df.columns and "price_exit" in trades_df.columns:
                                                                               ^
[1m.\ui\components\charts.py[m[36m:[m308[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
    """
    Cr√©e un prix synth√©tique pour les diagrammes de strat√©gies.

    Args:
        n: Nombre de points
        volatility: Facteur de volatilit√© (d√©faut: 2.5 pour simulation r√©aliste)

    Returns:
        Tuple (x, price, price_series)
    """
       
                                                               

      ^
[1m.\ui\components\charts.py[m[36m:[m353[36m:[m80[36m:[m [1m[31mE501[m line too long (89 > 79 characters)
    sigma = price_series.rolling(window=bb_period, min_periods=1).std(ddof=0).fillna(0.5)
                                                                               ^
[1m.\ui\components\charts.py[m[36m:[m387[36m:[m80[36m:[m [1m[31mE501[m line too long (91 > 79 characters)
    atr_values = price_series.diff().abs().rolling(window=atr_period, min_periods=1).mean()
                                                                               ^
[1m.\ui\components\charts.py[m[36m:[m421[36m:[m80[36m:[m [1m[31mE501[m line too long (88 > 79 characters)
    atr_values, atr_threshold = _calculate_atr(price_series, atr_period, atr_percentile)
                                                                               ^
[1m.\ui\components\charts.py[m[36m:[m532[36m:[m80[36m:[m [1m[31mE501[m line too long (90 > 79 characters)
        f"Parametres: bb_period={bb_period}, bb_std={bb_std:.2f}, entry_z={entry_z:.2f}, "
                                                                               ^
[1m.\ui\components\charts.py[m[36m:[m533[36m:[m80[36m:[m [1m[31mE501[m line too long (89 > 79 characters)
        f"atr_period={atr_period}, atr_percentile={atr_percentile:.0f}%, k_sl={k_sl:.2f}"
                                                                               ^
[1m.\ui\components\charts.py[m[36m:[m551[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
    """
    Diagramme pour la strat√©gie Bollinger ATR v2 (stop-loss bas√© sur Bollinger).

    Args:
        params: Param√®tres de la strat√©gie
        key: Cl√© unique Streamlit
        n: Nombre de points de donn√©es (augment√© √† 300 pour p√©riodes √©lev√©es)
    """
       
                                                                       ^
[1m.\ui\components\charts.py[m[36m:[m570[36m:[m80[36m:[m [1m[31mE501[m line too long (88 > 79 characters)
    atr_values, atr_threshold = _calculate_atr(price_series, atr_period, atr_percentile)
                                                                               ^
[1m.\ui\components\charts.py[m[36m:[m633[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
            line=dict(color=COLOR_PALETTE["stop_long"], width=1.2, dash="dash"),
                                                                               ^
[1m.\ui\components\charts.py[m[36m:[m640[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
            line=dict(color=COLOR_PALETTE["stop_short"], width=1.2, dash="dash"),
                                                                               ^
[1m.\ui\components\charts.py[m[36m:[m702[36m:[m80[36m:[m [1m[31mE501[m line too long (90 > 79 characters)
        f"Parametres: bb_period={bb_period}, bb_std={bb_std:.2f}, entry_z={entry_z:.2f}, "
                                                                               ^
[1m.\ui\components\charts.py[m[36m:[m703[36m:[m80[36m:[m [1m[31mE501[m line too long (109 > 79 characters)
        f"atr_period={atr_period}, atr_percentile={atr_percentile:.0f}%, bb_stop_factor={bb_stop_factor:.2f}"
                                                                               ^
[1m.\ui\components\charts.py[m[36m:[m707[36m:[m80[36m:[m [1m[31mE501[m line too long (88 > 79 characters)
        "- bb_stop_factor: Distance du stop depuis les bandes (0.2=proche, 2.0=loin).\n"
                                                                               ^
[1m.\ui\components\charts.py[m[36m:[m720[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
    """
    Diagramme pour la strat√©gie Bollinger ATR v3 (entr√©es, stop et TP variables).

    Args:
        params: Param√®tres de la strat√©gie
        key: Cl√© unique Streamlit
        n: Nombre de points de donn√©es (augment√© √† 300 pour p√©riodes √©lev√©es)
    """
       
                                                                       ^
[1m.\ui\components\charts.py[m[36m:[m741[36m:[m80[36m:[m [1m[31mE501[m line too long (88 > 79 characters)
    atr_values, atr_threshold = _calculate_atr(price_series, atr_period, atr_percentile)
                                                                               ^
[1m.\ui\components\charts.py[m[36m:[m756[36m:[m80[36m:[m [1m[31mE501[m line too long (91 > 79 characters)
            f"Prix + Bandes de Bollinger (V3: {bb_std:.1f}œÉ) + Niveaux d'entr√©e variables",
                                                                               ^
[1m.\ui\components\charts.py[m[36m:[m790[36m:[m80[36m:[m [1m[31mE501[m line too long (86 > 79 characters)
            line=dict(color=COLOR_PALETTE["entry_level_long"], width=1.5, dash="dot"),
                                                                               ^
[1m.\ui\components\charts.py[m[36m:[m798[36m:[m80[36m:[m [1m[31mE501[m line too long (87 > 79 characters)
            line=dict(color=COLOR_PALETTE["entry_level_short"], width=1.5, dash="dot"),
                                                                               ^
[1m.\ui\components\charts.py[m[36m:[m879[36m:[m80[36m:[m [1m[31mE501[m line too long (89 > 79 characters)
        f"entry_long={entry_pct_long*100:.0f}%, entry_short={entry_pct_short*100:.0f}%, "
                                                                               ^
[1m.\ui\components\charts.py[m[36m:[m884[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
        "- **√âchelle**: 0% = lower_band, 50% = middle_band, 100% = upper_band\n"
                                                                               ^
[1m.\ui\components\charts.py[m[36m:[m887[36m:[m80[36m:[m [1m[31mE501[m line too long (95 > 79 characters)
        "- **stop_factor**: Distance stop depuis entry_price (10% √† 100% de distance totale)\n"
                                                                               ^
[1m.\ui\components\charts.py[m[36m:[m888[36m:[m80[36m:[m [1m[31mE501[m line too long (91 > 79 characters)
        "- **tp_factor**: Distance TP depuis entry_price (20% √† 150% de distance totale)\n"
                                                                               ^
[1m.\ui\components\charts.py[m[36m:[m959[36m:[m80[36m:[m [1m[31mE501[m line too long (85 > 79 characters)
        legend=dict(orientation="h", yanchor="bottom", y=1.02, xanchor="right", x=1),
                                                                               ^
[1m.\ui\components\charts.py[m[36m:[m967[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
    st.caption(f"Parametres: fast_period={fast_period}, slow_period={slow_period}")
                                                                               ^
[1m.\ui\components\charts.py[m[36m:[m1076[36m:[m80[36m:[m [1m[31mE501[m line too long (85 > 79 characters)
    avg_loss = losses.ewm(alpha=1 / rsi_period, adjust=False).mean().replace(0, 1e-6)
                                                                               ^
[1m.\ui\components\charts.py[m[36m:[m1126[36m:[m80[36m:[m [1m[31mE501[m line too long (100 > 79 characters)
        f"Parametres: rsi_period={rsi_period}, oversold={oversold:.0f}, overbought={overbought:.0f}"
                                                                               ^
[1m.\ui\components\charts.py[m[36m:[m1195[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
            line=dict(color=COLOR_PALETTE["ema_center"], width=1.4, dash="dot"),
                                                                               ^
[1m.\ui\components\charts.py[m[36m:[m1206[36m:[m80[36m:[m [1m[31mE501[m line too long (85 > 79 characters)
        legend=dict(orientation="h", yanchor="bottom", y=1.02, xanchor="right", x=1),
                                                                               ^
[1m.\ui\components\charts.py[m[36m:[m1324[36m:[m80[36m:[m [1m[31mE501[m line too long (85 > 79 characters)
        legend=dict(orientation="h", yanchor="bottom", y=1.02, xanchor="right", x=1),
                                                                               ^
[1m.\ui\components\charts.py[m[36m:[m1334[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
    fig.update_yaxes(title_text="$", gridcolor=DEFAULT_GRID_COLOR, row=1, col=1)
                                                                               ^
[1m.\ui\components\charts.py[m[36m:[m1335[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
    fig.update_yaxes(title_text="%", gridcolor=DEFAULT_GRID_COLOR, row=2, col=1)
                                                                               ^
[1m.\ui\components\charts.py[m[36m:[m1416[36m:[m80[36m:[m [1m[31mE501[m line too long (91 > 79 characters)
    """
    Affiche un graphique OHLCV avec marqueurs de trades.

    Args:
        df: DataFrame OHLCV avec colonnes open, high, low, close
        trades_df: DataFrame des trades avec entry_time, exit_time, entry_price, exit_price
        title: Titre du graphique
        key: Cl√© unique Streamlit
        height: Hauteur du graphique
    """
       
                                                        

         
   ^
[1m.\ui\components\charts.py[m[36m:[m1458[36m:[m80[36m:[m [1m[31mE501[m line too long (92 > 79 characters)
                {"LONG": COLOR_PALETTE["entry_long"], "SHORT": COLOR_PALETTE["entry_short"]}
                                                                               ^
[1m.\ui\components\charts.py[m[36m:[m1473[36m:[m80[36m:[m [1m[31mE501[m line too long (85 > 79 characters)
                    hovertemplate="<b>Entry</b><br>%{x}<br>$%{y:.2f}<extra></extra>",
                                                                               ^
[1m.\ui\components\charts.py[m[36m:[m1487[36m:[m80[36m:[m [1m[31mE501[m line too long (91 > 79 characters)
                    COLOR_PALETTE["exit_profit"] if pnl > 0 else COLOR_PALETTE["exit_loss"]
                                                                               ^
[1m.\ui\components\charts.py[m[36m:[m1503[36m:[m80[36m:[m [1m[31mE501[m line too long (117 > 79 characters)
                    hovertemplate="<b>Exit</b><br>%{x}<br>Prix: $%{y:.2f}<br>PNL: $%{customdata:.2f}<extra></extra>",
                                                                               ^
[1m.\ui\components\charts.py[m[36m:[m1600[36m:[m80[36m:[m [1m[31mE501[m line too long (85 > 79 characters)
                    line=dict(color=COLOR_PALETTE["bb_bands"], width=1, dash="dash"),
                                                                               ^
[1m.\ui\components\charts.py[m[36m:[m1610[36m:[m80[36m:[m [1m[31mE501[m line too long (85 > 79 characters)
                    line=dict(color=COLOR_PALETTE["bb_bands"], width=1, dash="dash"),
                                                                               ^
[1m.\ui\components\charts.py[m[36m:[m1668[36m:[m80[36m:[m [1m[31mE501[m line too long (88 > 79 characters)
                    line=dict(color=COLOR_PALETTE["ema_center"], width=1.4, dash="dot"),
                                                                               ^
[1m.\ui\components\charts.py[m[36m:[m1704[36m:[m80[36m:[m [1m[31mE501[m line too long (88 > 79 characters)
                    line=dict(color=COLOR_PALETTE["ema_center"], width=1.4, dash="dot"),
                                                                               ^
[1m.\ui\components\charts.py[m[36m:[m1720[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
                    line=dict(color=COLOR_PALETTE["atr_channel_upper"], width=1.2),
                                                                               ^
[1m.\ui\components\charts.py[m[36m:[m1730[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
                    line=dict(color=COLOR_PALETTE["atr_channel_lower"], width=1.2),
                                                                               ^
[1m.\ui\components\charts.py[m[36m:[m1740[36m:[m80[36m:[m [1m[31mE501[m line too long (88 > 79 characters)
                    line=dict(color=COLOR_PALETTE["ema_center"], width=1.2, dash="dot"),
                                                                               ^
[1m.\ui\components\charts.py[m[36m:[m1749[36m:[m80[36m:[m [1m[31mE501[m line too long (92 > 79 characters)
                {"LONG": COLOR_PALETTE["entry_long"], "SHORT": COLOR_PALETTE["entry_short"]}
                                                                               ^
[1m.\ui\components\charts.py[m[36m:[m1763[36m:[m80[36m:[m [1m[31mE501[m line too long (85 > 79 characters)
                    hovertemplate="<b>Entry</b><br>%{x}<br>$%{y:.2f}<extra></extra>",
                                                                               ^
[1m.\ui\components\charts.py[m[36m:[m1776[36m:[m80[36m:[m [1m[31mE501[m line too long (91 > 79 characters)
                    COLOR_PALETTE["exit_profit"] if pnl > 0 else COLOR_PALETTE["exit_loss"]
                                                                               ^
[1m.\ui\components\charts.py[m[36m:[m1792[36m:[m80[36m:[m [1m[31mE501[m line too long (117 > 79 characters)
                    hovertemplate="<b>Exit</b><br>%{x}<br>Prix: $%{y:.2f}<br>PNL: $%{customdata:.2f}<extra></extra>",
                                                                               ^
[1m.\ui\components\charts.py[m[36m:[m1973[36m:[m80[36m:[m [1m[31mE501[m line too long (94 > 79 characters)
    """
    Affiche un graphique OHLCV avec indicateurs techniques.

    Args:
        df: DataFrame OHLCV
        indicators: Dict d'indicateurs (ex: {'bollinger': {'upper': series, 'lower': series}})
        title: Titre du graphique
        key: Cl√© unique Streamlit
        height: Hauteur du graphique
    """
       
                                                           

         
^
[1m.\ui\components\charts.py[m[36m:[m2017[36m:[m80[36m:[m [1m[31mE501[m line too long (85 > 79 characters)
                    line=dict(color=COLOR_PALETTE["bb_bands"], width=1, dash="dash"),
                                                                               ^
[1m.\ui\components\charts.py[m[36m:[m2025[36m:[m80[36m:[m [1m[31mE501[m line too long (85 > 79 characters)
                    line=dict(color=COLOR_PALETTE["bb_bands"], width=1, dash="dash"),
                                                                               ^
[1m.\ui\components\charts.py[m[36m:[m2074[36m:[m80[36m:[m [1m[31mE501[m line too long (93 > 79 characters)
                    COLOR_PALETTE["equity_line"] if v > 0 else COLOR_PALETTE["drawdown_line"]
                                                                               ^
[1m.\ui\components\model_selector.py[m[36m:[m4[36m:[m80[36m:[m [1m[31mE501[m line too long (87 > 79 characters)
"""
Module-ID: ui.components.model_selector

Purpose: S√©lecteur mod√®les LLM - query Ollama, fallback list, recommendations par r√¥le.

Role in pipeline: configuration

Key components: get_available_models_for_ui(), FALLBACK_LLM_MODELS, role-based recommendations

Inputs: Ollama endpoint (optionnel), role (Analyst/Strategist/Critic/Validator)

Outputs: Model list [str] orden√©e (recommand√©s en premier), fallback si Ollama down

Dependencies: agents.ollama_manager (optionnel), log

Conventions: Fallback list actualis√©e (Dec 2025); Ollama pr√©f√©r√©; timeout 2s.

Read-if: Modification fallback list ou role mappings.

Skip-if: Vous appelez get_available_models_for_ui().
"""
   
                                       

                                  ^
[1m.\ui\components\model_selector.py[m[36m:[m8[36m:[m80[36m:[m [1m[31mE501[m line too long (94 > 79 characters)
"""
Module-ID: ui.components.model_selector

Purpose: S√©lecteur mod√®les LLM - query Ollama, fallback list, recommendations par r√¥le.

Role in pipeline: configuration

Key components: get_available_models_for_ui(), FALLBACK_LLM_MODELS, role-based recommendations

Inputs: Ollama endpoint (optionnel), role (Analyst/Strategist/Critic/Validator)

Outputs: Model list [str] orden√©e (recommand√©s en premier), fallback si Ollama down

Dependencies: agents.ollama_manager (optionnel), log

Conventions: Fallback list actualis√©e (Dec 2025); Ollama pr√©f√©r√©; timeout 2s.

Read-if: Modification fallback list ou role mappings.

Skip-if: Vous appelez get_available_models_for_ui().
"""
   
                                       

                                  ^
[1m.\ui\components\model_selector.py[m[36m:[m12[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
"""
Module-ID: ui.components.model_selector

Purpose: S√©lecteur mod√®les LLM - query Ollama, fallback list, recommendations par r√¥le.

Role in pipeline: configuration

Key components: get_available_models_for_ui(), FALLBACK_LLM_MODELS, role-based recommendations

Inputs: Ollama endpoint (optionnel), role (Analyst/Strategist/Critic/Validator)

Outputs: Model list [str] orden√©e (recommand√©s en premier), fallback si Ollama down

Dependencies: agents.ollama_manager (optionnel), log

Conventions: Fallback list actualis√©e (Dec 2025); Ollama pr√©f√©r√©; timeout 2s.

Read-if: Modification fallback list ou role mappings.

Skip-if: Vous appelez get_available_models_for_ui().
"""
   
                                       

                                  ^
[1m.\ui\components\model_selector.py[m[36m:[m199[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
        "deepseek-r1:70b": "Le plus puissant - Excellent pour strat√©gies complexes",
                                                                               ^
[1m.\ui\components\monitor.py[m[36m:[m4[36m:[m80[36m:[m [1m[31mE501[m line too long (85 > 79 characters)
"""
Module-ID: ui.components.monitor

Purpose: Renderer Streamlit pour monitoring syst√®me temps r√©el - CPU, RAM, GPU, Disk.

Role in pipeline: visualization/monitoring

Key components: SystemMonitor, render_system_monitor(), render_mini_monitor(), ResourceReading

Inputs: System snapshots via psutil

Outputs: Streamlit metric cards, rolling history charts

Dependencies: streamlit (optionnel), plotly (optionnel), psutil (optionnel)

Conventions: 1s interval; rolling window 100 points; color alerts (% thresholds).

Read-if: Modification metrics collection ou alert thresholds.

Skip-if: Vous appelez render_system_monitor().
"""
   
                                

                                         ^
[1m.\ui\components\monitor.py[m[36m:[m8[36m:[m80[36m:[m [1m[31mE501[m line too long (94 > 79 characters)
"""
Module-ID: ui.components.monitor

Purpose: Renderer Streamlit pour monitoring syst√®me temps r√©el - CPU, RAM, GPU, Disk.

Role in pipeline: visualization/monitoring

Key components: SystemMonitor, render_system_monitor(), render_mini_monitor(), ResourceReading

Inputs: System snapshots via psutil

Outputs: Streamlit metric cards, rolling history charts

Dependencies: streamlit (optionnel), plotly (optionnel), psutil (optionnel)

Conventions: 1s interval; rolling window 100 points; color alerts (% thresholds).

Read-if: Modification metrics collection ou alert thresholds.

Skip-if: Vous appelez render_system_monitor().
"""
   
                                

                                         ^
[1m.\ui\components\monitor.py[m[36m:[m16[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
"""
Module-ID: ui.components.monitor

Purpose: Renderer Streamlit pour monitoring syst√®me temps r√©el - CPU, RAM, GPU, Disk.

Role in pipeline: visualization/monitoring

Key components: SystemMonitor, render_system_monitor(), render_mini_monitor(), ResourceReading

Inputs: System snapshots via psutil

Outputs: Streamlit metric cards, rolling history charts

Dependencies: streamlit (optionnel), plotly (optionnel), psutil (optionnel)

Conventions: 1s interval; rolling window 100 points; color alerts (% thresholds).

Read-if: Modification metrics collection ou alert thresholds.

Skip-if: Vous appelez render_system_monitor().
"""
   
                                

                                         ^
[1m.\ui\components\monitor.py[m[36m:[m100[36m:[m80[36m:[m [1m[31mE501[m line too long (86 > 79 characters)
    """
    Collector responsible for polling and storing `ResourceReading` history.

    Lifecycle: instantiated at Streamlit startup, optionally scheduled to sample every
    `refresh_interval`, and queried by renderers to plot current values or sparkline.
    """
       
                                                                       ^
[1m.\ui\components\monitor.py[m[36m:[m101[36m:[m80[36m:[m [1m[31mE501[m line too long (85 > 79 characters)
    """
    Collector responsible for polling and storing `ResourceReading` history.

    Lifecycle: instantiated at Streamlit startup, optionally scheduled to sample every
    `refresh_interval`, and queried by renderers to plot current values or sparkline.
    """
       
                                                                       ^
[1m.\ui\components\monitor.py[m[36m:[m162[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
                reading.gpu_memory_percent = (mem_info.used / mem_info.total) * 100
                                                                               ^
[1m.\ui\components\monitor.py[m[36m:[m369[36m:[m80[36m:[m [1m[31mE501[m line too long (87 > 79 characters)
    """
    Streamlit panel that keeps system resource usage visible during a backtest.

    Uses the session-scoped `SystemMonitor` instance to poll ResourceReading snapshots,
    then draws alerts/gauges/history so the operator can stop a run before hitting limits.

    Args:
        key: Unique Streamlit key so reruns remain idempotent.
        show_history: Display the time-series history chart.
        show_gauges: Render gauge widgets for CPU/RAM/GPU/Disk.
        compact: Reduce the detail level for sidebar embedding.
    """
       
                                                                       ^
[1m.\ui\components\monitor.py[m[36m:[m370[36m:[m80[36m:[m [1m[31mE501[m line too long (90 > 79 characters)
    """
    Streamlit panel that keeps system resource usage visible during a backtest.

    Uses the session-scoped `SystemMonitor` instance to poll ResourceReading snapshots,
    then draws alerts/gauges/history so the operator can stop a run before hitting limits.

    Args:
        key: Unique Streamlit key so reruns remain idempotent.
        show_history: Display the time-series history chart.
        show_gauges: Render gauge widgets for CPU/RAM/GPU/Disk.
        compact: Reduce the detail level for sidebar embedding.
    """
       
                                                                       ^
[1m.\ui\components\monitor.py[m[36m:[m419[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
            fig = _create_gauge(reading.cpu_percent, "CPU", status.get('cpu', 'ok'))
                                                                               ^
[1m.\ui\components\monitor.py[m[36m:[m422[36m:[m80[36m:[m [1m[31mE501[m line too long (89 > 79 characters)
                st.caption(f"C≈ìurs: {psutil.cpu_count() if PSUTIL_AVAILABLE else 'N/A'}")
                                                                               ^
[1m.\ui\components\monitor.py[m[36m:[m425[36m:[m80[36m:[m [1m[31mE501[m line too long (90 > 79 characters)
            fig = _create_gauge(reading.memory_percent, "RAM", status.get('memory', 'ok'))
                                                                               ^
[1m.\ui\components\monitor.py[m[36m:[m428[36m:[m80[36m:[m [1m[31mE501[m line too long (94 > 79 characters)
                st.caption(f"{reading.memory_used_gb:.1f} / {reading.memory_total_gb:.1f} GB")
                                                                               ^
[1m.\ui\components\monitor.py[m[36m:[m432[36m:[m80[36m:[m [1m[31mE501[m line too long (96 > 79 characters)
                fig = _create_gauge(reading.gpu_memory_percent, "VRAM", status.get('gpu', 'ok'))
                                                                               ^
[1m.\ui\components\monitor.py[m[36m:[m435[36m:[m80[36m:[m [1m[31mE501[m line too long (106 > 79 characters)
                    st.caption(f"{reading.gpu_memory_used_gb:.1f} / {reading.gpu_memory_total_gb:.1f} GB")
                                                                               ^
[1m.\ui\components\monitor.py[m[36m:[m442[36m:[m80[36m:[m [1m[31mE501[m line too long (87 > 79 characters)
            fig = _create_gauge(reading.disk_percent, "Disk", status.get('disk', 'ok'))
                                                                               ^
[1m.\ui\components\monitor.py[m[36m:[m445[36m:[m80[36m:[m [1m[31mE501[m line too long (90 > 79 characters)
                st.caption(f"{reading.disk_used_gb:.1f} / {reading.disk_total_gb:.1f} GB")
                                                                               ^
[1m.\ui\components\monitor.py[m[36m:[m450[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
        fig = _create_history_chart(monitor.history, show_gpu=monitor.gpu_available)
                                                                               ^
[1m.\ui\components\monitor.py[m[36m:[m454[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
    st.caption(f"Derni√®re mise √† jour: {reading.timestamp.strftime('%H:%M:%S')}")
                                                                               ^
[1m.\ui\components\monitor.py[m[36m:[m483[36m:[m80[36m:[m [1m[31mE501[m line too long (88 > 79 characters)
    st.markdown(f"{mem_color} RAM: **{mem.percent:.0f}%** ({mem.used/(1024**3):.1f}GB)")
                                                                               ^
[1m.\ui\components\monitor.py[m[36m:[m493[36m:[m80[36m:[m [1m[31mE501[m line too long (93 > 79 characters)
        st.markdown(f"{gpu_color} GPU: **{gpu_pct:.0f}%** ({mem_info.used/(1024**3):.1f}GB)")
                                                                               ^
[1m.\ui\components\sweep_monitor.py[m[36m:[m4[36m:[m80[36m:[m [1m[31mE501[m line too long (85 > 79 characters)
"""
Module-ID: ui.components.sweep_monitor

Purpose: Monitor live pour sweeps/optimisation - progress, ETA, top results, ranking.

Role in pipeline: visualization/monitoring

Key components: SweepMonitor, render_sweep_progress(), render_sweep_summary(), SweepStats

Inputs: Sweep updates {completed, total, current_result}

Outputs: Progress bar, ETA estimate, top-N table, live chart updates

Dependencies: streamlit (optionnel), plotly (optionnel), numpy, dataclasses

Conventions: ETA based on rolling avg; refresh 100ms; top-5 constant display.

Read-if: Modification ETA algo ou layout progress.

Skip-if: Vous appelez render_sweep_progress(monitor).
"""
   
                                      

                                   ^
[1m.\ui\components\sweep_monitor.py[m[36m:[m8[36m:[m80[36m:[m [1m[31mE501[m line too long (89 > 79 characters)
"""
Module-ID: ui.components.sweep_monitor

Purpose: Monitor live pour sweeps/optimisation - progress, ETA, top results, ranking.

Role in pipeline: visualization/monitoring

Key components: SweepMonitor, render_sweep_progress(), render_sweep_summary(), SweepStats

Inputs: Sweep updates {completed, total, current_result}

Outputs: Progress bar, ETA estimate, top-N table, live chart updates

Dependencies: streamlit (optionnel), plotly (optionnel), numpy, dataclasses

Conventions: ETA based on rolling avg; refresh 100ms; top-5 constant display.

Read-if: Modification ETA algo ou layout progress.

Skip-if: Vous appelez render_sweep_progress(monitor).
"""
   
                                      

                                   ^
[1m.\ui\components\sweep_monitor.py[m[36m:[m160[36m:[m80[36m:[m [1m[31mE501[m line too long (92 > 79 characters)
        self.objectives = objectives or ['sharpe_ratio', 'total_return_pct', 'max_drawdown']
                                                                               ^
[1m.\ui\components\sweep_monitor.py[m[36m:[m315[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
            moving_avg = np.convolve(values, np.ones(window)/window, mode='valid')
                                                                               ^
[1m.\ui\components\sweep_monitor.py[m[36m:[m331[36m:[m80[36m:[m [1m[31mE501[m line too long (85 > 79 characters)
        legend=dict(orientation="h", yanchor="bottom", y=1.02, xanchor="right", x=1),
                                                                               ^
[1m.\ui\components\sweep_monitor.py[m[36m:[m447[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
        if show_evolution and monitor.get_metric_history(monitor.objectives[0]):
                                                                               ^
[1m.\ui\components\sweep_monitor.py[m[36m:[m460[36m:[m80[36m:[m [1m[31mE501[m line too long (85 > 79 characters)
        tabs = st.tabs([obj.replace('_', ' ').title() for obj in monitor.objectives])
                                                                               ^
[1m.\ui\components\sweep_monitor.py[m[36m:[m487[36m:[m80[36m:[m [1m[31mE501[m line too long (89 > 79 characters)
    """
    Summary view rendered once the sweep completes.

    Highlights total duration, rate, pruning ratio and best parameter sets per objective.

    Args:
        monitor: SweepMonitor that tracked the recently finished sweep.
        key: Widget key for the summary block.
    """
       
                                                   

                  ^
[1m.\ui\components\sweep_monitor.py[m[36m:[m510[36m:[m80[36m:[m [1m[31mE501[m line too long (91 > 79 characters)
        st.metric("Taux de pruning", f"{(stats.pruned/stats.total_combinations)*100:.1f}%")
                                                                               ^
[1m.\ui\components\sweep_monitor.py[m[36m:[m518[36m:[m80[36m:[m [1m[31mE501[m line too long (101 > 79 characters)
            with st.expander(f"**{obj.replace('_', ' ').title()}**: {best.metrics.get(obj, 0):.4f}"):
                                                                               ^
[1m.\ui\components\validation_viewer.py[m[36m:[m4[36m:[m80[36m:[m [1m[31mE501[m line too long (106 > 79 characters)
"""
Module-ID: ui.components.validation_viewer

Purpose: Renderer Streamlit pour rapports walk-forward validation - r√©sum√©, graphiques, overfitting flags.

Role in pipeline: visualization/analysis

Key components: render_validation_report(), render_validation_summary_card(), ValidationReport dataclass

Inputs: WalkForwardValidator results {train_metrics, test_metrics per window}

Outputs: Streamlit UI {tabs, cards, charts}, overfitting warnings

Dependencies: streamlit (optionnel), plotly (optionnel), pandas, dataclasses

Conventions: Train (bleu), Test (orange); overfitting flag si ratio > 1.2; TTL cache 1h.

Read-if: Modification validation rendering ou m√©trique selection.

Skip-if: Vous appelez render_validation_report(report).
"""
   
                                          

                               ^
[1m.\ui\components\validation_viewer.py[m[36m:[m8[36m:[m80[36m:[m [1m[31mE501[m line too long (104 > 79 characters)
"""
Module-ID: ui.components.validation_viewer

Purpose: Renderer Streamlit pour rapports walk-forward validation - r√©sum√©, graphiques, overfitting flags.

Role in pipeline: visualization/analysis

Key components: render_validation_report(), render_validation_summary_card(), ValidationReport dataclass

Inputs: WalkForwardValidator results {train_metrics, test_metrics per window}

Outputs: Streamlit UI {tabs, cards, charts}, overfitting warnings

Dependencies: streamlit (optionnel), plotly (optionnel), pandas, dataclasses

Conventions: Train (bleu), Test (orange); overfitting flag si ratio > 1.2; TTL cache 1h.

Read-if: Modification validation rendering ou m√©trique selection.

Skip-if: Vous appelez render_validation_report(report).
"""
   
                                          

                               ^
[1m.\ui\components\validation_viewer.py[m[36m:[m16[36m:[m80[36m:[m [1m[31mE501[m line too long (88 > 79 characters)
"""
Module-ID: ui.components.validation_viewer

Purpose: Renderer Streamlit pour rapports walk-forward validation - r√©sum√©, graphiques, overfitting flags.

Role in pipeline: visualization/analysis

Key components: render_validation_report(), render_validation_summary_card(), ValidationReport dataclass

Inputs: WalkForwardValidator results {train_metrics, test_metrics per window}

Outputs: Streamlit UI {tabs, cards, charts}, overfitting warnings

Dependencies: streamlit (optionnel), plotly (optionnel), pandas, dataclasses

Conventions: Train (bleu), Test (orange); overfitting flag si ratio > 1.2; TTL cache 1h.

Read-if: Modification validation rendering ou m√©trique selection.

Skip-if: Vous appelez render_validation_report(report).
"""
   
                                          

                               ^
[1m.\ui\components\validation_viewer.py[m[36m:[m52[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
    """
    Represents metrics and parameters for a single walk-forward fold.

    Captures train/test metrics/degradation to allow UI cards and charts to flag
    problematic windows while keeping the validation logic separated.
    """
       
                                                                     

^
[1m.\ui\components\validation_viewer.py[m[36m:[m117[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
            "train_period": f"{self.train_start.date()} ‚Üí {self.train_end.date()}",
                                                                               ^
[1m.\ui\components\validation_viewer.py[m[36m:[m118[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
            "test_period": f"{self.test_start.date()} ‚Üí {self.test_end.date()}",
                                                                               ^
[1m.\ui\components\validation_viewer.py[m[36m:[m136[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
    """
    Aggregated walk-forward validation report.

    Contains windows, aggregate metrics, and helpers to surface the best params.
    Lifespan: produced by the validation runner and consumed by UI renderers.
    """
       
                                              

                       ^
[1m.\ui\components\validation_viewer.py[m[36m:[m149[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
    _aggregate_metrics: Optional[Dict[str, float]] = field(default=None, repr=False)
                                                                               ^
[1m.\ui\components\validation_viewer.py[m[36m:[m176[36m:[m80[36m:[m [1m[31mE501[m line too long (103 > 79 characters)
            "consistency_ratio": float(np.mean([1 if w.test_sharpe > 0 else 0 for w in self.windows])),
                                                                               ^
[1m.\ui\components\validation_viewer.py[m[36m:[m177[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
            "overfitting_windows": sum(1 for w in self.windows if w.is_overfitting),
                                                                               ^
[1m.\ui\components\validation_viewer.py[m[36m:[m334[36m:[m80[36m:[m [1m[31mE501[m line too long (96 > 79 characters)
    colors = ["#f44336" if d > 50 else "#ff9800" if d > 30 else "#4caf50" for d in degradations]
                                                                               ^
[1m.\ui\components\validation_viewer.py[m[36m:[m403[36m:[m80[36m:[m [1m[31mE501[m line too long (88 > 79 characters)
    """
    Streamlit dashboard that surfaces a Walk-Forward validation report.

    Displays status badges, global metrics, per-window tables and the multi-panel figure
    so that users can judge strategy robustness during backtests.

    Args:
        report: ValidationReport produced by `validation_integration`.
        key: Widget key preventing Streamlit rerun collisions.
    """
       
                                                                       ^
[1m.\ui\components\validation_viewer.py[m[36m:[m424[36m:[m80[36m:[m [1m[31mE501[m line too long (85 > 79 characters)
        f"<span style='background-color:{status_color};color:white;padding:5px 15px;"
                                                                               ^
[1m.\ui\components\validation_viewer.py[m[36m:[m502[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
        with st.expander(f"Fen√™tre {w.window_id} {status_icon}", expanded=False):
                                                                               ^
[1m.\ui\components\validation_viewer.py[m[36m:[m507[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
                st.write(f"P√©riode: {w.train_start.date()} ‚Üí {w.train_end.date()}")
                                                                               ^
[1m.\ui\components\validation_viewer.py[m[36m:[m515[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
                st.write(f"P√©riode: {w.test_start.date()} ‚Üí {w.test_end.date()}")
                                                                               ^
[1m.\ui\components\validation_viewer.py[m[36m:[m530[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
            "‚úÖ **Strat√©gie valid√©e** - Les performances sont consistantes entre "
                                                                               ^
[1m.\ui\components\validation_viewer.py[m[36m:[m531[36m:[m80[36m:[m [1m[31mE501[m line too long (87 > 79 characters)
            "l'entra√Ænement et le test. La strat√©gie peut √™tre utilis√©e en production."
                                                                               ^
[1m.\ui\components\validation_viewer.py[m[36m:[m540[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
            "‚ö†Ô∏è **Attention** - D√©gradation significative entre train et test. "
                                                                               ^
[1m.\ui\components\validation_viewer.py[m[36m:[m546[36m:[m80[36m:[m [1m[31mE501[m line too long (89 > 79 characters)
            "üìà‚ùå **Overfitting d√©tect√©** - Les performances train ne se g√©n√©ralisent pas "
                                                                               ^
[1m.\ui\components\validation_viewer.py[m[36m:[m547[36m:[m80[36m:[m [1m[31mE501[m line too long (95 > 79 characters)
            "sur les donn√©es de test. Simplifiez la strat√©gie ou utilisez moins de param√®tres."
                                                                               ^
[1m.\ui\components\validation_viewer.py[m[36m:[m552[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
            "‚ùå **√âchec de validation** - La strat√©gie ne performe pas de mani√®re "
                                                                               ^
[1m.\ui\components\validation_viewer.py[m[36m:[m598[36m:[m80[36m:[m [1m[31mE501[m line too long (87 > 79 characters)
            f"<div style='border-left: 4px solid {status_color}; padding-left: 10px;'>"
                                                                               ^
[1m.\ui\constants.py[m[36m:[m4[36m:[m80[36m:[m [1m[31mE501[m line too long (92 > 79 characters)
"""
Module-ID: ui.constants

Purpose: Constantes UI - limites param√®tres, descriptions strat√©gies, options modes, styles.

Role in pipeline: configuration

Key components: PARAM_CONSTRAINTS dict, get_strategy_description(), MODE_OPTIONS, CSS

Inputs: None (static definitions)

Outputs: Constants exported

Dependencies: strategies.indicators_mapping

Conventions: Min/max/step pour chaque param; descriptions UI-friendly; CSS button inline.

Read-if: Modification ranges params ou descriptions strat√©gies.

Skip-if: Vous appelez get_strategy_description(strategy_name).
"""
   
                       

                                                  ^
[1m.\ui\constants.py[m[36m:[m8[36m:[m80[36m:[m [1m[31mE501[m line too long (85 > 79 characters)
"""
Module-ID: ui.constants

Purpose: Constantes UI - limites param√®tres, descriptions strat√©gies, options modes, styles.

Role in pipeline: configuration

Key components: PARAM_CONSTRAINTS dict, get_strategy_description(), MODE_OPTIONS, CSS

Inputs: None (static definitions)

Outputs: Constants exported

Dependencies: strategies.indicators_mapping

Conventions: Min/max/step pour chaque param; descriptions UI-friendly; CSS button inline.

Read-if: Modification ranges params ou descriptions strat√©gies.

Skip-if: Vous appelez get_strategy_description(strategy_name).
"""
   
                       

                                                  ^
[1m.\ui\constants.py[m[36m:[m16[36m:[m80[36m:[m [1m[31mE501[m line too long (89 > 79 characters)
"""
Module-ID: ui.constants

Purpose: Constantes UI - limites param√®tres, descriptions strat√©gies, options modes, styles.

Role in pipeline: configuration

Key components: PARAM_CONSTRAINTS dict, get_strategy_description(), MODE_OPTIONS, CSS

Inputs: None (static definitions)

Outputs: Constants exported

Dependencies: strategies.indicators_mapping

Conventions: Min/max/step pour chaque param; descriptions UI-friendly; CSS button inline.

Read-if: Modification ranges params ou descriptions strat√©gies.

Skip-if: Vous appelez get_strategy_description(strategy_name).
"""
   
                       

                                                  ^
[1m.\ui\constants.py[m[36m:[m28[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
from strategies.indicators_mapping import STRATEGY_INDICATORS_MAP, get_ui_indicators
                                                                               ^
[1m.\ui\context.py[m[36m:[m4[36m:[m80[36m:[m [1m[31mE501[m line too long (94 > 79 characters)
"""
Module-ID: ui.context

Purpose: Context loaders - chargement imports backend avec error handling, fallbacks gracieux.

Role in pipeline: configuration/initialization

Key components: BACKEND_AVAILABLE flag, lazy imports BacktestEngine/RunResult/data/strategies/agents

Inputs: None (dynamic imports)

Outputs: Modules import√©s (ou None + IMPORT_ERROR si echec)

Dependencies: backtest.*, data.*, indicators.*, strategies.*, agents.*

Conventions: sys.path injection; try/except gracieux; fallback lazy loading.

Read-if: Modification imports ou gestion errors.

Skip-if: Vous checked juste BACKEND_AVAILABLE flag.
"""
   
                     

                                                    ^
[1m.\ui\context.py[m[36m:[m8[36m:[m80[36m:[m [1m[31mE501[m line too long (100 > 79 characters)
"""
Module-ID: ui.context

Purpose: Context loaders - chargement imports backend avec error handling, fallbacks gracieux.

Role in pipeline: configuration/initialization

Key components: BACKEND_AVAILABLE flag, lazy imports BacktestEngine/RunResult/data/strategies/agents

Inputs: None (dynamic imports)

Outputs: Modules import√©s (ou None + IMPORT_ERROR si echec)

Dependencies: backtest.*, data.*, indicators.*, strategies.*, agents.*

Conventions: sys.path injection; try/except gracieux; fallback lazy loading.

Read-if: Modification imports ou gestion errors.

Skip-if: Vous checked juste BACKEND_AVAILABLE flag.
"""
   
                     

                                                    ^
[1m.\ui\context.py[m[36m:[m138[36m:[m80[36m:[m [1m[31mE501[m line too long (89 > 79 characters)
    from agents.llm_client import LLMConfig, LLMProvider, create_llm_client  # noqa: F401
                                                                               ^
[1m.\ui\context.py[m[36m:[m149[36m:[m80[36m:[m [1m[31mE501[m line too long (94 > 79 characters)
    from agents.ollama_manager import ensure_ollama_running, is_ollama_available  # noqa: F401
                                                                               ^
[1m.\ui\context.py[m[36m:[m150[36m:[m80[36m:[m [1m[31mE501[m line too long (98 > 79 characters)
    from agents.orchestration_logger import OrchestrationLogger, generate_session_id  # noqa: F401
                                                                               ^
[1m.\ui\deep_trace_viewer.py[m[36m:[m4[36m:[m80[36m:[m [1m[31mE501[m line too long (127 > 79 characters)
"""
Module-ID: ui.deep_trace_viewer

Purpose: Visualiseur Deep Trace d√©taill√© pour orchestration LLM - timeline, inspecteur, propositions, state machine, m√©triques.

Role in pipeline: visualization / debugging

Key components: render_deep_trace(), timeline, metrics, state inspector

Inputs: OrchestrationLogger instance

Outputs: Interface Streamlit multi-onglets (timeline, inspector, metrics, etc.)

Dependencies: streamlit, agents.orchestration_logger

Conventions: Onglets: Timeline, Inspector, Proposals, State Machine, Metrics

Read-if: Deep debugging orchestration LLM ou inspection √©tats.

Skip-if: Pas d'agents LLM ou monitoring minimal suffisant.
"""
   
                               

                                          ^
[1m.\ui\deep_trace_viewer.py[m[36m:[m42[36m:[m1[36m:[m [1m[31mE302[m expected 2 blank lines, found 1
def _format_float(value: Any, precision: int) -> Optional[str]:
^
[1m.\ui\deep_trace_viewer.py[m[36m:[m92[36m:[m80[36m:[m [1m[31mE501[m line too long (95 > 79 characters)
def _get_event_color(action_type: OrchestrationActionType, status: OrchestrationStatus) -> str:
                                                                               ^
[1m.\ui\deep_trace_viewer.py[m[36m:[m140[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
def render_timeline_panel(logger: OrchestrationLogger, filters: Dict[str, Any]):
                                                                               ^
[1m.\ui\deep_trace_viewer.py[m[36m:[m154[36m:[m80[36m:[m [1m[31mE501[m line too long (87 > 79 characters)
        iterations = [int(x.split()[1]) for x in filters["iteration"] if x != "Toutes"]
                                                                               ^
[1m.\ui\deep_trace_viewer.py[m[36m:[m155[36m:[m80[36m:[m [1m[31mE501[m line too long (85 > 79 characters)
        filtered_logs = [log for log in filtered_logs if log.iteration in iterations]
                                                                               ^
[1m.\ui\deep_trace_viewer.py[m[36m:[m158[36m:[m80[36m:[m [1m[31mE501[m line too long (87 > 79 characters)
        filtered_logs = [log for log in filtered_logs if log.agent in filters["agent"]]
                                                                               ^
[1m.\ui\deep_trace_viewer.py[m[36m:[m161[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
        event_types = [OrchestrationActionType(et) for et in filters["event_type"]]
                                                                               ^
[1m.\ui\deep_trace_viewer.py[m[36m:[m162[36m:[m80[36m:[m [1m[31mE501[m line too long (88 > 79 characters)
        filtered_logs = [log for log in filtered_logs if log.action_type in event_types]
                                                                               ^
[1m.\ui\deep_trace_viewer.py[m[36m:[m184[36m:[m80[36m:[m [1m[31mE501[m line too long (92 > 79 characters)
    st.caption(f"Affichage de {len(filtered_logs)} √©v√©nements sur {len(logger.logs)} total")
                                                                               ^
[1m.\ui\deep_trace_viewer.py[m[36m:[m216[36m:[m80[36m:[m [1m[31mE501[m line too long (202 > 79 characters)
        role_badge = f'<span style="background-color: {role_color}; color: white; padding: 2px 6px; border-radius: 3px; font-size: 0.75em; margin-left: 8px;"><strong>{log.agent.upper()}</strong></span>'
                                                                               ^
[1m.\ui\deep_trace_viewer.py[m[36m:[m223[36m:[m80[36m:[m [1m[31mE501[m line too long (127 > 79 characters)
    main_html = f"""
    <div style="background-color: {color}; padding: 8px 12px; border-radius: 5px; margin: 5px 0; border-left: 4px solid #666;">
        <span style="font-size: 1.2em;">{emoji}</span>
        <code style="background-color: rgba(0,0,0,0.1); padding: 2px 6px; border-radius: 3px; margin: 0 8px;">{timestamp}</code>
        <strong>{event_type}</strong>
        {role_badge}
    </div>
    """
                    
                                                          ^
[1m.\ui\deep_trace_viewer.py[m[36m:[m225[36m:[m80[36m:[m [1m[31mE501[m line too long (128 > 79 characters)
    main_html = f"""
    <div style="background-color: {color}; padding: 8px 12px; border-radius: 5px; margin: 5px 0; border-left: 4px solid #666;">
        <span style="font-size: 1.2em;">{emoji}</span>
        <code style="background-color: rgba(0,0,0,0.1); padding: 2px 6px; border-radius: 3px; margin: 0 8px;">{timestamp}</code>
        <strong>{event_type}</strong>
        {role_badge}
    </div>
    """
                    
                                                          ^
[1m.\ui\deep_trace_viewer.py[m[36m:[m347[36m:[m80[36m:[m [1m[31mE501[m line too long (104 > 79 characters)
    total_calls = len([e for e in events if e.action_type == OrchestrationActionType.AGENT_EXECUTE_END])
                                                                               ^
[1m.\ui\deep_trace_viewer.py[m[36m:[m348[36m:[m80[36m:[m [1m[31mE501[m line too long (132 > 79 characters)
    successful = len([e for e in events if e.action_type == OrchestrationActionType.AGENT_EXECUTE_END and e.details.get("success")])
                                                                               ^
[1m.\ui\deep_trace_viewer.py[m[36m:[m371[36m:[m80[36m:[m [1m[31mE501[m line too long (98 > 79 characters)
    end_events = [e for e in events if e.action_type == OrchestrationActionType.AGENT_EXECUTE_END]
                                                                               ^
[1m.\ui\deep_trace_viewer.py[m[36m:[m384[36m:[m80[36m:[m [1m[31mE501[m line too long (97 > 79 characters)
            f"{status_emoji} **Appel #{i}** - It√©ration {iteration} - {timestamp} ({latency}ms)",
                                                                               ^
[1m.\ui\deep_trace_viewer.py[m[36m:[m423[36m:[m80[36m:[m [1m[31mE501[m line too long (115 > 79 characters)
    generated_events = [e for e in proposal_events if e.action_type == OrchestrationActionType.PROPOSALS_GENERATED]
                                                                               ^
[1m.\ui\deep_trace_viewer.py[m[36m:[m424[36m:[m80[36m:[m [1m[31mE501[m line too long (116 > 79 characters)
    test_ended_events = [e for e in proposal_events if e.action_type == OrchestrationActionType.PROPOSAL_TEST_ENDED]
                                                                               ^
[1m.\ui\deep_trace_viewer.py[m[36m:[m426[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
    total_generated = sum([e.details.get("count", 0) for e in generated_events])
                                                                               ^
[1m.\ui\deep_trace_viewer.py[m[36m:[m428[36m:[m80[36m:[m [1m[31mE501[m line too long (93 > 79 characters)
    tested_successful = len([e for e in test_ended_events if e.details.get("tested", False)])
                                                                               ^
[1m.\ui\deep_trace_viewer.py[m[36m:[m447[36m:[m80[36m:[m [1m[31mE501[m line too long (86 > 79 characters)
            # R√©cup√©rer les valeurs (0.0 est une valeur valide, ne pas afficher "N/A")
                                                                               ^
[1m.\ui\deep_trace_viewer.py[m[36m:[m456[36m:[m80[36m:[m [1m[31mE501[m line too long (87 > 79 characters)
                "Return": f"{total_return:.2%}" if total_return is not None else "N/A",
                                                                               ^
[1m.\ui\deep_trace_viewer.py[m[36m:[m492[36m:[m80[36m:[m [1m[31mE501[m line too long (123 > 79 characters)
        last_enter = next((e for e in reversed(logger.logs) if e.action_type == OrchestrationActionType.STATE_ENTER), None)
                                                                               ^
[1m.\ui\deep_trace_viewer.py[m[36m:[m497[36m:[m80[36m:[m [1m[31mE501[m line too long (102 > 79 characters)
    state_changes = [e for e in state_events if e.action_type == OrchestrationActionType.STATE_CHANGE]
                                                                               ^
[1m.\ui\deep_trace_viewer.py[m[36m:[m567[36m:[m80[36m:[m [1m[31mE501[m line too long (94 > 79 characters)
    next((e for e in logger.logs if e.action_type == OrchestrationActionType.RUN_START), None)
                                                                               ^
[1m.\ui\deep_trace_viewer.py[m[36m:[m568[36m:[m80[36m:[m [1m[31mE501[m line too long (112 > 79 characters)
    run_end = next((e for e in reversed(logger.logs) if e.action_type == OrchestrationActionType.RUN_END), None)
                                                                               ^
[1m.\ui\deep_trace_viewer.py[m[36m:[m581[36m:[m80[36m:[m [1m[31mE501[m line too long (87 > 79 characters)
        st.metric("Temps Total", f"{total_time_s:.1f}s" if total_time_s > 0 else "N/A")
                                                                               ^
[1m.\ui\deep_trace_viewer.py[m[36m:[m599[36m:[m80[36m:[m [1m[31mE501[m line too long (137 > 79 characters)
        best_sharpe = max([e.details.get("sharpe", -999) for e in iteration_events if e.details.get("sharpe") is not None], default=None)
                                                                               ^
[1m.\ui\deep_trace_viewer.py[m[36m:[m602[36m:[m80[36m:[m [1m[31mE501[m line too long (108 > 79 characters)
            best_event = next((e for e in iteration_events if e.details.get("sharpe") == best_sharpe), None)
                                                                               ^
[1m.\ui\deep_trace_viewer.py[m[36m:[m690[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
        st.sidebar.info("Aucune session disponible (r√©pertoire runs/ inexistant)")
                                                                               ^
[1m.\ui\deep_trace_viewer.py[m[36m:[m762[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
            export_path = Path(f"orchestration_export_{logger.session_id}.json")
                                                                               ^
[1m.\ui\deep_trace_viewer.py[m[36m:[m768[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
            export_path = Path(f"orchestration_export_{logger.session_id}.jsonl")
                                                                               ^
[1m.\ui\deep_trace_viewer.py[m[36m:[m782[36m:[m80[36m:[m [1m[31mE501[m line too long (100 > 79 characters)
    """
    Point d'entr√©e principal pour le Deep Trace Viewer.

    Args:
        logger: Instance OrchestrationLogger (peut √™tre None, auquel cas on charge depuis s√©lecteur)
    """
       
                                                       

         
    ^
[1m.\ui\emergency_stop.py[m[36m:[m16[36m:[m80[36m:[m [1m[31mE501[m line too long (86 > 79 characters)
"""
Module-ID: ui.emergency_stop

Purpose: Syst√®me d'arr√™t d'urgence et nettoyage m√©moire complet.

Role in pipeline: ui / cleanup

Key components: EmergencyStopHandler, full_memory_cleanup

Inputs: Session state, logger

Outputs: RAM/VRAM lib√©r√©e, processus arr√™t√©s

Dependencies: gc, psutil, torch, cupy, MemoryManager, GPUMemoryManager

Conventions: Nettoyage agressif tous composants; logs d√©taill√©s; fallback sur erreurs.

Read-if: Modification logique arr√™t d'urgence

Skip-if: Utilisation normale du bouton stop
"""
   
                            

                                             ^
[1m.\ui\emergency_stop.py[m[36m:[m62[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
    def full_cleanup(self, session_state: Optional[Any] = None) -> Dict[str, Any]:
                                                                               ^
[1m.\ui\emergency_stop.py[m[36m:[m141[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
        """D√©charge tous les mod√®les LLM de la VRAM avec v√©rification compl√®te."""
                                                                               ^
[1m.\ui\emergency_stop.py[m[36m:[m149[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
                response = httpx.get("http://127.0.0.1:11434/api/ps", timeout=5.0)
                                                                               ^
[1m.\ui\emergency_stop.py[m[36m:[m168[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
                                    logger.info(f"üóëÔ∏è LLM d√©charg√©: {model_name}")
                                                                               ^
[1m.\ui\emergency_stop.py[m[36m:[m169[36m:[m80[36m:[m [1m[31mE501[m line too long (91 > 79 characters)
                                    stats["components_cleaned"].append(f"llm_{model_name}")
                                                                               ^
[1m.\ui\emergency_stop.py[m[36m:[m171[36m:[m80[36m:[m [1m[31mE501[m line too long (90 > 79 characters)
                                    logger.warning(f"‚ö†Ô∏è √âchec d√©chargement: {model_name}")
                                                                               ^
[1m.\ui\emergency_stop.py[m[36m:[m172[36m:[m80[36m:[m [1m[31mE501[m line too long (93 > 79 characters)
                                    stats["errors"].append(f"llm_unload_{model_name}_failed")
                                                                               ^
[1m.\ui\emergency_stop.py[m[36m:[m174[36m:[m80[36m:[m [1m[31mE501[m line too long (91 > 79 characters)
                                logger.warning(f"‚ö†Ô∏è Erreur d√©chargement {model_name}: {e}")
                                                                               ^
[1m.\ui\emergency_stop.py[m[36m:[m175[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
                                stats["errors"].append(f"llm_{model_name}: {e}")
                                                                               ^
[1m.\ui\emergency_stop.py[m[36m:[m178[36m:[m80[36m:[m [1m[31mE501[m line too long (92 > 79 characters)
                    response_check = httpx.get("http://127.0.0.1:11434/api/ps", timeout=3.0)
                                                                               ^
[1m.\ui\emergency_stop.py[m[36m:[m182[36m:[m80[36m:[m [1m[31mE501[m line too long (108 > 79 characters)
                            logger.warning(f"‚ö†Ô∏è {len(remaining)} mod√®le(s) encore en m√©moire apr√®s cleanup")
                                                                               ^
[1m.\ui\emergency_stop.py[m[36m:[m183[36m:[m80[36m:[m [1m[31mE501[m line too long (92 > 79 characters)
                            stats["errors"].append(f"llm_remaining_{len(remaining)}_models")
                                                                               ^
[1m.\ui\emergency_stop.py[m[36m:[m185[36m:[m80[36m:[m [1m[31mE501[m line too long (91 > 79 characters)
                            logger.info(f"‚úÖ Tous les LLM d√©charg√©s ({n_unloaded} mod√®les)")
                                                                               ^
[1m.\ui\emergency_stop.py[m[36m:[m188[36m:[m80[36m:[m [1m[31mE501[m line too long (94 > 79 characters)
                    logger.debug(f"Ollama API non accessible (status {response.status_code})")
                                                                               ^
[1m.\ui\emergency_stop.py[m[36m:[m189[36m:[m80[36m:[m [1m[31mE501[m line too long (87 > 79 characters)
                    stats["errors"].append(f"ollama_api_status_{response.status_code}")
                                                                               ^
[1m.\ui\emergency_stop.py[m[36m:[m214[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
                stats["components_cleaned"].append(f"indicator_expired_{n_expired}")
                                                                               ^
[1m.\ui\emergency_stop.py[m[36m:[m294[36m:[m80[36m:[m [1m[31mE501[m line too long (85 > 79 characters)
                stats["components_cleaned"].append(f"memory_manager_{n_freed}_bytes")
                                                                               ^
[1m.\ui\emergency_stop.py[m[36m:[m302[36m:[m80[36m:[m [1m[31mE501[m line too long (85 > 79 characters)
                    stats["components_cleaned"].append(f"managed_cache_{cache_name}")
                                                                               ^
[1m.\ui\emergency_stop.py[m[36m:[m319[36m:[m80[36m:[m [1m[31mE501[m line too long (90 > 79 characters)
            logger.info(f"üóëÔ∏è GC: {stats.get('gc_collected_objects', 0)} objets collect√©s")
                                                                               ^
[1m.\ui\emergency_stop.py[m[36m:[m329[36m:[m80[36m:[m [1m[31mE501[m line too long (85 > 79 characters)
        """R√©initialise les √©tats Streamlit pertinents et nettoie le contexte LLM."""
                                                                               ^
[1m.\ui\emergency_stop.py[m[36m:[m357[36m:[m80[36m:[m [1m[31mE501[m line too long (91 > 79 characters)
                stats["components_cleaned"].append(f"session_llm_context_{n_cleaned}_keys")
                                                                               ^
[1m.\ui\emergency_stop.py[m[36m:[m401[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
def execute_emergency_stop(session_state: Optional[Any] = None) -> Dict[str, Any]:
                                                                               ^
[1m.\ui\emergency_stop.py[m[36m:[m413[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
    """
    Raccourci pour ex√©cuter un arr√™t d'urgence complet.

    Args:
        session_state: √âtat de session Streamlit

    Returns:
        Dict avec statistiques de nettoyage

    Example:
        >>> stats = execute_emergency_stop(st.session_state)
        >>> st.success(f"‚úÖ {len(stats['components_cleaned'])} composants nettoy√©s")
    """
       
                                                       

         
    ^
[1m.\ui\helpers.py[m[36m:[m4[36m:[m80[36m:[m [1m[31mE501[m line too long (90 > 79 characters)
"""
Module-ID: ui.helpers

Purpose: Utilitaires UI - tables strat√©gies markdown, stat calcs, cache streamlit helpers.

Role in pipeline: user interface utilities

Key components: generate_strategies_table(), format_metric(), st_cache wrappers

Inputs: Strategies registry, metric values

Outputs: Markdown tables, formatted strings, cached dataframes

Dependencies: streamlit, pandas, ui.constants, ui.context

Conventions: Cache streamlit TTL; markdown tables sync auto; metric formatting pr√©cision.

Read-if: Modification format output ou stat calculations.

Skip-if: Vous appelez generate_strategies_table().
"""
   
                     

                                                    ^
[1m.\ui\helpers.py[m[36m:[m16[36m:[m80[36m:[m [1m[31mE501[m line too long (89 > 79 characters)
"""
Module-ID: ui.helpers

Purpose: Utilitaires UI - tables strat√©gies markdown, stat calcs, cache streamlit helpers.

Role in pipeline: user interface utilities

Key components: generate_strategies_table(), format_metric(), st_cache wrappers

Inputs: Strategies registry, metric values

Outputs: Markdown tables, formatted strings, cached dataframes

Dependencies: streamlit, pandas, ui.constants, ui.context

Conventions: Cache streamlit TTL; markdown tables sync auto; metric formatting pr√©cision.

Read-if: Modification format output ou stat calculations.

Skip-if: Vous appelez generate_strategies_table().
"""
   
                     

                                                    ^
[1m.\ui\helpers.py[m[36m:[m122[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
        progress = runs_completed / self.total_runs if self.total_runs > 0 else 0
                                                                               ^
[1m.\ui\helpers.py[m[36m:[m335[36m:[m80[36m:[m [1m[31mE501[m line too long (91 > 79 characters)
                max_value=max(1, (int(constraints["max"]) - int(constraints["min"])) // 2),
                                                                               ^
[1m.\ui\helpers.py[m[36m:[m364[36m:[m80[36m:[m [1m[31mE501[m line too long (96 > 79 characters)
                max_value=max(0.1, (float(constraints["max"]) - float(constraints["min"])) / 2),
                                                                               ^
[1m.\ui\helpers.py[m[36m:[m386[36m:[m80[36m:[m [1m[31mE501[m line too long (90 > 79 characters)
def create_constrained_slider(name: str, granularity: float, key_prefix: str = "") -> Any:
                                                                               ^
[1m.\ui\helpers.py[m[36m:[m492[36m:[m80[36m:[m [1m[31mE501[m line too long (86 > 79 characters)
        f"{meta.strategy} | {meta.symbol}/{meta.timeframe} | {period} | {meta.run_id}"
                                                                               ^
[1m.\ui\helpers.py[m[36m:[m496[36m:[m80[36m:[m [1m[31mE501[m line too long (85 > 79 characters)
def _save_result_to_storage(storage: Any, result: Optional[Any]) -> Tuple[bool, str]:
                                                                               ^
[1m.\ui\helpers.py[m[36m:[m608[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
    selected_meta = next((r for r in runs if r.run_id == selected_run_id), None)
                                                                               ^
[1m.\ui\helpers.py[m[36m:[m622[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
            f"Sharpe: {sharpe:.2f} | Return: {ret_pct:.1f}% | MaxDD: {max_dd:.1f}%"
                                                                               ^
[1m.\ui\helpers.py[m[36m:[m651[36m:[m80[36m:[m [1m[31mE501[m line too long (86 > 79 characters)
    logger = get_obs_logger("ui.app", run_id=run_id, strategy=strategy, symbol=symbol)
                                                                               ^
[1m.\ui\helpers.py[m[36m:[m707[36m:[m80[36m:[m [1m[31mE501[m line too long (87 > 79 characters)
def _aggregate_metric(values: List[Any], method: str, higher_is_better: bool) -> float:
                                                                               ^
[1m.\ui\indicators_panel.py[m[36m:[m4[36m:[m80[36m:[m [1m[31mE501[m line too long (130 > 79 characters)
"""
Module-ID: ui.indicators_panel

Purpose: Panel d'indicateurs dynamique Streamlit - grouper et afficher indicateurs par cat√©gorie (tendance, momentum, volatilite).

Role in pipeline: visualization / input

Key components: group_indicators_by_category(), render_indicator_panel(), selecteur interactif

Inputs: Registry indicateurs

Outputs: Interface s√©lection indicateurs avec cat√©gories

Dependencies: streamlit, indicators.registry

Conventions: Cat√©gories: üìà Tendance, üìç Momentum, üéä Volatilit√©, üíà Volume

Read-if: Modification UI s√©lection indicateurs ou cat√©gorisation.

Skip-if: Interface indicateurs d√©j√† d√©finie.
"""
   
                              

                                           ^
[1m.\ui\indicators_panel.py[m[36m:[m8[36m:[m80[36m:[m [1m[31mE501[m line too long (94 > 79 characters)
"""
Module-ID: ui.indicators_panel

Purpose: Panel d'indicateurs dynamique Streamlit - grouper et afficher indicateurs par cat√©gorie (tendance, momentum, volatilite).

Role in pipeline: visualization / input

Key components: group_indicators_by_category(), render_indicator_panel(), selecteur interactif

Inputs: Registry indicateurs

Outputs: Interface s√©lection indicateurs avec cat√©gories

Dependencies: streamlit, indicators.registry

Conventions: Cat√©gories: üìà Tendance, üìç Momentum, üéä Volatilit√©, üíà Volume

Read-if: Modification UI s√©lection indicateurs ou cat√©gorisation.

Skip-if: Interface indicateurs d√©j√† d√©finie.
"""
   
                              

                                           ^
[1m.\ui\indicators_panel.py[m[36m:[m104[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
    st.caption(f"**{total_indicators} indicateurs techniques** pr√™ts √† l'emploi")
                                                                               ^
[1m.\ui\indicators_panel.py[m[36m:[m108[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
        with st.expander(f"{category} ({len(indicator_names)})", expanded=expanded):
                                                                               ^
[1m.\ui\indicators_panel.py[m[36m:[m112[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
                    st.markdown(f"- **{ind_name.upper()}** : {info.description}")
                                                                               ^
[1m.\ui\indicators_panel.py[m[36m:[m127[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
    st.markdown(f"""
    ### üìä Indicateurs Int√©gr√©s

    **{total} indicateurs techniques** r√©partis en {len(categories)} cat√©gories :
    """)
                    
                              

                          ^
[1m.\ui\indicators_panel.py[m[36m:[m135[36m:[m80[36m:[m [1m[31mE501[m line too long (97 > 79 characters)
    st.info("üí° Les indicateurs sont charg√©s **automatiquement** selon la strat√©gie s√©lectionn√©e")
                                                                               ^
[1m.\ui\indicators_panel.py[m[36m:[m184[36m:[m80[36m:[m [1m[31mE501[m line too long (85 > 79 characters)
def format_indicator_name(indicator_name: str, with_description: bool = True) -> str:
                                                                               ^
[1m.\ui\main.py[m[36m:[m64[36m:[m80[36m:[m [1m[31mE501[m line too long (102 > 79 characters)
    """
    Wrapper picklable pour ProcessPoolExecutor.

    Args:
        args: tuple (param_combo, initial_capital, df, strategy_key, symbol, timeframe, debug_enabled)

    Returns:
        Dict avec r√©sultats du backtest ou erreur
    """
       
                                               

         
            ^
[1m.\ui\main.py[m[36m:[m69[36m:[m80[36m:[m [1m[31mE501[m line too long (91 > 79 characters)
    param_combo, initial_capital, df, strategy_key, symbol, timeframe, debug_enabled = args
                                                                               ^
[1m.\ui\main.py[m[36m:[m72[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
        # Cr√©er l'engine localement (pas picklable donc recr√©√© dans chaque process)
                                                                               ^
[1m.\ui\main.py[m[36m:[m86[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
            k: float(v) if hasattr(v, "item") else v for k, v in param_combo.items()
                                                                               ^
[1m.\ui\main.py[m[36m:[m170[36m:[m80[36m:[m [1m[31mE501[m line too long (86 > 79 characters)
            st.success(f"‚úÖ Arr√™t d'urgence complet : {n_cleaned} composants nettoy√©s")
                                                                               ^
[1m.\ui\main.py[m[36m:[m172[36m:[m80[36m:[m [1m[31mE501[m line too long (93 > 79 characters)
            st.warning(f"‚ö†Ô∏è Arr√™t avec {n_errors} erreurs : {n_cleaned} composants nettoy√©s")
                                                                               ^
[1m.\ui\main.py[m[36m:[m352[36m:[m80[36m:[m [1m[31mE501[m line too long (89 > 79 characters)
                                values = list(range(int(pmin), int(pmax) + 1, int(step)))
                                                                               ^
[1m.\ui\main.py[m[36m:[m355[36m:[m80[36m:[m [1m[31mE501[m line too long (102 > 79 characters)
                                    np.arange(float(pmin), float(pmax) + float(step) / 2, float(step))
                                                                               ^
[1m.\ui\main.py[m[36m:[m357[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
                                values = [round(v, 2) for v in values if v <= pmax]
                                                                               ^
[1m.\ui\main.py[m[36m:[m362[36m:[m80[36m:[m [1m[31mE501[m line too long (87 > 79 characters)
                            # Fusionner params fixes (UI) avec params variants (grille)
                                                                               ^
[1m.\ui\main.py[m[36m:[m363[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
                            param_dict = {**params, **dict(zip(param_names, combo))}
                                                                               ^
[1m.\ui\main.py[m[36m:[m370[36m:[m80[36m:[m [1m[31mE501[m line too long (86 > 79 characters)
                            f"‚ö†Ô∏è Grille limit√©e: {len(param_grid):,} ‚Üí {max_combos:,}"
                                                                               ^
[1m.\ui\main.py[m[36m:[m374[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
                    show_status("info", f"Grille: {len(param_grid):,} combinaisons")
                                                                               ^
[1m.\ui\main.py[m[36m:[m389[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
                objectives=["sharpe_ratio", "total_return_pct", "max_drawdown"],
                                                                               ^
[1m.\ui\main.py[m[36m:[m411[36m:[m80[36m:[m [1m[31mE501[m line too long (96 > 79 characters)
                        k: float(v) if hasattr(v, "item") else v for k, v in param_combo.items()
                                                                               ^
[1m.\ui\main.py[m[36m:[m440[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
                from concurrent.futures import ProcessPoolExecutor, as_completed
                                                                               ^
[1m.\ui\main.py[m[36m:[m446[36m:[m80[36m:[m [1m[31mE501[m line too long (110 > 79 characters)
                            (combo, state.initial_capital, df, strategy_key, symbol, timeframe, debug_enabled)
                                                                               ^
[1m.\ui\main.py[m[36m:[m457[36m:[m29[36m:[m [1m[31mF821[m undefined name 'logger'
                            logger.warning("üõë Arr√™t demand√© - interruption du sweep parall√®le")
                            ^
[1m.\ui\main.py[m[36m:[m457[36m:[m80[36m:[m [1m[31mE501[m line too long (95 > 79 characters)
                            logger.warning("üõë Arr√™t demand√© - interruption du sweep parall√®le")
                                                                               ^
[1m.\ui\main.py[m[36m:[m461[36m:[m80[36m:[m [1m[31mE501[m line too long (102 > 79 characters)
                            show_status("warning", f"Arr√™t√© apr√®s {completed}/{len(param_grid)} runs")
                                                                               ^
[1m.\ui\main.py[m[36m:[m475[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
                                "total_return_pct": result.get("total_pnl", 0.0),
                                                                               ^
[1m.\ui\main.py[m[36m:[m479[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
                                "profit_factor": result.get("profit_factor", 0.0),
                                                                               ^
[1m.\ui\main.py[m[36m:[m481[36m:[m80[36m:[m [1m[31mE501[m line too long (85 > 79 characters)
                            sweep_monitor.update(params=param_combo, metrics=metrics)
                                                                               ^
[1m.\ui\main.py[m[36m:[m483[36m:[m80[36m:[m [1m[31mE501[m line too long (92 > 79 characters)
                            sweep_monitor.update(params=param_combo, metrics={}, error=True)
                                                                               ^
[1m.\ui\main.py[m[36m:[m486[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
                            k: v for k, v in result.items() if k != "params_dict"
                                                                               ^
[1m.\ui\main.py[m[36m:[m491[36m:[m80[36m:[m [1m[31mE501[m line too long (88 > 79 characters)
                        if completed % 5 == 0 or current_time - last_render_time >= 0.5:
                                                                               ^
[1m.\ui\main.py[m[36m:[m492[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
                            render_progress_monitor(monitor, monitor_placeholder)
                                                                               ^
[1m.\ui\main.py[m[36m:[m517[36m:[m25[36m:[m [1m[31mF821[m undefined name 'logger'
                        logger.warning("üõë Arr√™t demand√© - interruption du sweep")
                        ^
[1m.\ui\main.py[m[36m:[m517[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
                        logger.warning("üõë Arr√™t demand√© - interruption du sweep")
                                                                               ^
[1m.\ui\main.py[m[36m:[m518[36m:[m80[36m:[m [1m[31mE501[m line too long (90 > 79 characters)
                        show_status("warning", f"Arr√™t√© apr√®s {i}/{len(param_grid)} runs")
                                                                               ^
[1m.\ui\main.py[m[36m:[m537[36m:[m80[36m:[m [1m[31mE501[m line too long (88 > 79 characters)
                        sweep_monitor.update(params=param_combo_result, metrics=metrics)
                                                                               ^
[1m.\ui\main.py[m[36m:[m539[36m:[m80[36m:[m [1m[31mE501[m line too long (95 > 79 characters)
                        sweep_monitor.update(params=param_combo_result, metrics={}, error=True)
                                                                               ^
[1m.\ui\main.py[m[36m:[m547[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
                    if (i + 1) % 5 == 0 or current_time - last_render_time >= 0.5:
                                                                               ^
[1m.\ui\main.py[m[36m:[m576[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
                show_status("success", f"Optimisation: {len(results_list)} tests")
                                                                               ^
[1m.\ui\main.py[m[36m:[m583[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
                logger.info("üîç DEBUG GRID SEARCH - Analyse de la colonne 'trades'")
                                                                               ^
[1m.\ui\main.py[m[36m:[m599[36m:[m80[36m:[m [1m[31mE501[m line too long (91 > 79 characters)
                    x for x in trades_values if isinstance(x, float) and not x.is_integer()
                                                                               ^
[1m.\ui\main.py[m[36m:[m618[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
                valid_results = valid_results.sort_values("sharpe", ascending=False)
                                                                               ^
[1m.\ui\main.py[m[36m:[m699[36m:[m80[36m:[m [1m[31mE501[m line too long (92 > 79 characters)
                full_param_space = get_strategy_param_space(strategy_key, include_step=True)
                                                                               ^
[1m.\ui\main.py[m[36m:[m708[36m:[m80[36m:[m [1m[31mE501[m line too long (90 > 79 characters)
                llm_compare_auto_run or st.session_state.get("llm_compare_run_now", False)
                                                                               ^
[1m.\ui\main.py[m[36m:[m713[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
                    st.warning("Aucune strategie selectionnee pour la comparaison.")
                                                                               ^
[1m.\ui\main.py[m[36m:[m715[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
                    st.warning("Selectionnez au moins un token et un timeframe.")
                                                                               ^
[1m.\ui\main.py[m[36m:[m717[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
                    start_str = str(state.start_date) if state.start_date else None
                                                                               ^
[1m.\ui\main.py[m[36m:[m726[36m:[m80[36m:[m [1m[31mE501[m line too long (87 > 79 characters)
                            df_cmp, msg = safe_load_data(token, tf, start_str, end_str)
                                                                               ^
[1m.\ui\main.py[m[36m:[m728[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
                                comparison_errors.append(f"{token}/{tf}: {msg}")
                                                                               ^
[1m.\ui\main.py[m[36m:[m758[36m:[m80[36m:[m [1m[31mE501[m line too long (85 > 79 characters)
                                        f"{strategy_name_cmp} {token}/{tf}: {status}"
                                                                               ^
[1m.\ui\main.py[m[36m:[m772[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
                                    progress_bar.progress(run_index / total_runs)
                                                                               ^
[1m.\ui\main.py[m[36m:[m791[36m:[m80[36m:[m [1m[31mE501[m line too long (87 > 79 characters)
                            f"Runs effectues: {len(comparison_results)} / {total_runs}"
                                                                               ^
[1m.\ui\main.py[m[36m:[m793[36m:[m80[36m:[m [1m[31mE501[m line too long (87 > 79 characters)
                        st.dataframe(pd.DataFrame(comparison_summary), width="stretch")
                                                                               ^
[1m.\ui\main.py[m[36m:[m801[36m:[m80[36m:[m [1m[31mE501[m line too long (87 > 79 characters)
                                        llm_compare_metric: row.get(llm_compare_metric)
                                                                               ^
[1m.\ui\main.py[m[36m:[m816[36m:[m80[36m:[m [1m[31mE501[m line too long (89 > 79 characters)
                                    st.warning("LLM indisponible pour la justification.")
                                                                               ^
[1m.\ui\main.py[m[36m:[m819[36m:[m80[36m:[m [1m[31mE501[m line too long (105 > 79 characters)
                                        "strategy | runs | sharpe | return_pct | max_drawdown | win_rate"
                                                                               ^
[1m.\ui\main.py[m[36m:[m825[36m:[m80[36m:[m [1m[31mE501[m line too long (93 > 79 characters)
                                            f"{row.get('sharpe_ratio', float('nan')):.2f} | "
                                                                               ^
[1m.\ui\main.py[m[36m:[m826[36m:[m80[36m:[m [1m[31mE501[m line too long (97 > 79 characters)
                                            f"{row.get('total_return_pct', float('nan')):.2f} | "
                                                                               ^
[1m.\ui\main.py[m[36m:[m827[36m:[m80[36m:[m [1m[31mE501[m line too long (93 > 79 characters)
                                            f"{row.get('max_drawdown', float('nan')):.2f} | "
                                                                               ^
[1m.\ui\main.py[m[36m:[m828[36m:[m80[36m:[m [1m[31mE501[m line too long (86 > 79 characters)
                                            f"{row.get('win_rate', float('nan')):.1f}"
                                                                               ^
[1m.\ui\main.py[m[36m:[m832[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
                                        "You are a senior quantitative strategist. "
                                                                               ^
[1m.\ui\main.py[m[36m:[m833[36m:[m80[36m:[m [1m[31mE501[m line too long (99 > 79 characters)
                                        "Compare strategy robustness across assets and timeframes."
                                                                               ^
[1m.\ui\main.py[m[36m:[m837[36m:[m80[36m:[m [1m[31mE501[m line too long (86 > 79 characters)
                                        f"- tokens: {', '.join(llm_compare_tokens)}\n"
                                                                               ^
[1m.\ui\main.py[m[36m:[m838[36m:[m80[36m:[m [1m[31mE501[m line too long (94 > 79 characters)
                                        f"- timeframes: {', '.join(llm_compare_timeframes)}\n"
                                                                               ^
[1m.\ui\main.py[m[36m:[m839[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
                                        f"- aggregation: {llm_compare_aggregate}\n"
                                                                               ^
[1m.\ui\main.py[m[36m:[m840[36m:[m80[36m:[m [1m[31mE501[m line too long (85 > 79 characters)
                                        f"- primary metric: {llm_compare_metric}\n\n"
                                                                               ^
[1m.\ui\main.py[m[36m:[m841[36m:[m80[36m:[m [1m[31mE501[m line too long (97 > 79 characters)
                                        "Summary table (metrics are percent where applicable):\n"
                                                                               ^
[1m.\ui\main.py[m[36m:[m845[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
                                        "1) Ranking with short justification.\n"
                                                                               ^
[1m.\ui\main.py[m[36m:[m847[36m:[m80[36m:[m [1m[31mE501[m line too long (91 > 79 characters)
                                        "3) Which strategies deserve further optimization."
                                                                               ^
[1m.\ui\main.py[m[36m:[m858[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
                                st.warning(f"Justification LLM indisponible: {exc}")
                                                                               ^
[1m.\ui\main.py[m[36m:[m882[36m:[m80[36m:[m [1m[31mE501[m line too long (89 > 79 characters)
                        st.info("‚ÑπÔ∏è **Espace continu** : exploration adaptative par LLM")
                                                                               ^
[1m.\ui\main.py[m[36m:[m886[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
                            f"~{llm_space_stats.total_combinations:,} combinaisons"
                                                                               ^
[1m.\ui\main.py[m[36m:[m888[36m:[m80[36m:[m [1m[31mE501[m line too long (92 > 79 characters)
                        st.caption("_(Le LLM explore de fa√ßon intelligente sans √©num√©rer)_")
                                                                               ^
[1m.\ui\main.py[m[36m:[m912[36m:[m80[36m:[m [1m[31mE501[m line too long (101 > 79 characters)
            # Note: Le tracking des duplications durant la session est g√©r√© par session_param_tracker
                                                                               ^
[1m.\ui\main.py[m[36m:[m925[36m:[m80[36m:[m [1m[31mE501[m line too long (89 > 79 characters)
                            live_viewer.render(live_events_placeholder, show_header=True)
                                                                               ^
[1m.\ui\main.py[m[36m:[m927[36m:[m80[36m:[m [1m[31mE501[m line too long (90 > 79 characters)
                        orchestration_logger.set_on_event_callback(on_orchestration_event)
                                                                               ^
[1m.\ui\main.py[m[36m:[m957[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
                            unload_llm_during_backtest=llm_unload_during_backtest,
                                                                               ^
[1m.\ui\main.py[m[36m:[m991[36m:[m80[36m:[m [1m[31mE501[m line too long (86 > 79 characters)
                            f"Orchestration errors: {len(orchestrator_result.errors)}"
                                                                               ^
[1m.\ui\main.py[m[36m:[m995[36m:[m80[36m:[m [1m[31mE501[m line too long (90 > 79 characters)
                            f"Orchestration warnings: {len(orchestrator_result.warnings)}"
                                                                               ^
[1m.\ui\main.py[m[36m:[m1020[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
                            st.metric("Max Drawdown", f"{metrics.max_drawdown:.2%}")
                                                                               ^
[1m.\ui\main.py[m[36m:[m1025[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
                            pd.DataFrame(orchestrator_result.iteration_history),
                                                                               ^
[1m.\ui\main.py[m[36m:[m1046[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
                            st.session_state["last_winner_params"] = winner_params
                                                                               ^
[1m.\ui\main.py[m[36m:[m1047[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
                            st.session_state["last_winner_metrics"] = winner_metrics
                                                                               ^
[1m.\ui\main.py[m[36m:[m1048[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
                            st.session_state["last_winner_origin"] = winner_origin
                                                                               ^
[1m.\ui\main.py[m[36m:[m1052[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
                    show_status("error", f"Erreur optimisation multi-agents: {exc}")
                                                                               ^
[1m.\ui\main.py[m[36m:[m1075[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
                    live_viewer.render(live_events_placeholder, show_header=True)
                                                                               ^
[1m.\ui\main.py[m[36m:[m1077[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
                orchestration_logger.set_on_event_callback(on_orchestration_event)
                                                                               ^
[1m.\ui\main.py[m[36m:[m1087[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
                        st.write("ü§ñ **Agent LLM actif** - Optimisation autonome")
                                                                               ^
[1m.\ui\main.py[m[36m:[m1089[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
                            f"üìä Strat√©gie: `{strategy_key}` | Mod√®le: `{llm_model}`"
                                                                               ^
[1m.\ui\main.py[m[36m:[m1111[36m:[m80[36m:[m [1m[31mE501[m line too long (92 > 79 characters)
                        f"‚úÖ Optimisation termin√©e en {session.current_iteration} it√©rations"
                                                                               ^
[1m.\ui\main.py[m[36m:[m1114[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
                    with st.expander("üìù Historique des it√©rations", expanded=True):
                                                                               ^
[1m.\ui\main.py[m[36m:[m1153[36m:[m80[36m:[m [1m[31mE501[m line too long (86 > 79 characters)
                                    "Module LLM non disponible pour Deep Trace avanc√©"
                                                                               ^
[1m.\ui\main.py[m[36m:[m1176[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
                            initial_sharpe = session.all_results[0].sharpe_ratio
                                                                               ^
[1m.\ui\main.py[m[36m:[m1179[36m:[m80[36m:[m [1m[31mE501[m line too long (90 > 79 characters)
                                (best_sharpe - initial_sharpe) / abs(initial_sharpe) * 100
                                                                               ^
[1m.\ui\main.py[m[36m:[m1187[36m:[m80[36m:[m [1m[31mE501[m line too long (88 > 79 characters)
                            st.metric("It√©rations utilis√©es", session.current_iteration)
                                                                               ^
[1m.\ui\main.py[m[36m:[m1209[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
                        st.session_state["last_winner_metrics"] = winner_metrics
                                                                               ^
[1m.\ui\model_presets.py[m[36m:[m16[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
"""
Module-ID: ui.model_presets

Purpose: Gestion des presets de configuration de mod√®les LLM pour les agents.

Role in pipeline: configuration UI

Key components: BUILTIN_PRESETS, save/load/delete presets, apply preset

Inputs: Nom de preset, RoleModelConfig

Outputs: Presets JSON, config modifi√©e

Dependencies: pathlib, json, datetime, agents.model_config

Conventions: Presets builtin non modifiables, fichiers JSON dans data/model_presets/

Read-if: Modification des presets builtin ou logique de sauvegarde

Skip-if: Vous utilisez juste list_model_presets() ou load_model_preset()
"""
   
                           

                                              ^
[1m.\ui\model_presets.py[m[36m:[m64[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
        "description": "Mix light/medium/heavy pour compromis performance/vitesse",
                                                                               ^
[1m.\ui\model_presets.py[m[36m:[m75[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
        "description": "Heavy models pour analyses complexes et ajustements fins",
                                                                               ^
[1m.\ui\orchestration_viewer.py[m[36m:[m4[36m:[m80[36m:[m [1m[31mE501[m line too long (100 > 79 characters)
"""
Module-ID: ui.orchestration_viewer

Purpose: Affiche les logs d'orchestration des agents LLM de mani√®re interactive dans l'UI Streamlit.

Role in pipeline: reporting / orchestration

Key components: render_orchestration_logs

Inputs: OrchestrationLogger instance

Outputs: Interface Streamlit avec logs et m√©triques

Dependencies: agents.orchestration_logger, streamlit

Conventions: Logs structur√©s avec timestamps et actions

Read-if: Besoin d'afficher les logs d'orchestration LLM

Skip-if: Pas d'utilisation d'agents LLM ou pas besoin de visualisation des logs
"""
   
                                  

                                       ^
[1m.\ui\orchestration_viewer.py[m[36m:[m84[36m:[m80[36m:[m [1m[31mE501[m line too long (91 > 79 characters)
            agents = list(set(log.agent for log in orchestration_logger.logs if log.agent))
                                                                               ^
[1m.\ui\orchestration_viewer.py[m[36m:[m93[36m:[m80[36m:[m [1m[31mE501[m line too long (90 > 79 characters)
            action_types = list(set(log.action_type for log in orchestration_logger.logs))
                                                                               ^
[1m.\ui\orchestration_viewer.py[m[36m:[m102[36m:[m80[36m:[m [1m[31mE501[m line too long (86 > 79 characters)
            iterations = list(set(log.iteration for log in orchestration_logger.logs))
                                                                               ^
[1m.\ui\orchestration_viewer.py[m[36m:[m113[36m:[m80[36m:[m [1m[31mE501[m line too long (88 > 79 characters)
            filtered_logs = [log for log in filtered_logs if log.agent in agents_filter]
                                                                               ^
[1m.\ui\orchestration_viewer.py[m[36m:[m116[36m:[m80[36m:[m [1m[31mE501[m line too long (90 > 79 characters)
            action_values = [at.value for at in action_types if at.value in action_filter]
                                                                               ^
[1m.\ui\orchestration_viewer.py[m[36m:[m117[36m:[m80[36m:[m [1m[31mE501[m line too long (100 > 79 characters)
            filtered_logs = [log for log in filtered_logs if log.action_type.value in action_values]
                                                                               ^
[1m.\ui\orchestration_viewer.py[m[36m:[m121[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
                int(it.split(" ")[1]) for it in iteration_filter if it != "Toutes"
                                                                               ^
[1m.\ui\orchestration_viewer.py[m[36m:[m123[36m:[m80[36m:[m [1m[31mE501[m line too long (98 > 79 characters)
            filtered_logs = [log for log in filtered_logs if log.iteration in selected_iterations]
                                                                               ^
[1m.\ui\orchestration_viewer.py[m[36m:[m142[36m:[m80[36m:[m [1m[31mE501[m line too long (86 > 79 characters)
        st.caption(f"Affichage des {max_entries} derniers logs sur {len(logs)} total")
                                                                               ^
[1m.\ui\orchestration_viewer.py[m[36m:[m156[36m:[m80[36m:[m [1m[31mE501[m line too long (144 > 79 characters)
        with st.expander(f"üîÑ **It√©ration {iteration}** ({len(iteration_logs)} actions)", expanded=(iteration == max(logs_by_iteration.keys()))):
                                                                               ^
[1m.\ui\orchestration_viewer.py[m[36m:[m180[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
        agent_label = f"{agent_label} ¬∑ {model_name}" if agent_label else model_name
                                                                               ^
[1m.\ui\orchestration_viewer.py[m[36m:[m182[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
        f"<strong style='color: {text_color};'>[{escape(agent_label)}]</strong>"
                                                                               ^
[1m.\ui\orchestration_viewer.py[m[36m:[m233[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
        st.caption(f"   `{details['old_strategy']}` ‚Üí `{details['new_strategy']}`")
                                                                               ^
[1m.\ui\orchestration_viewer.py[m[36m:[m247[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
            param_str = ", ".join([f"{k}={v}" for k, v in list(params.items())[:3]])
                                                                               ^
[1m.\ui\orchestration_viewer.py[m[36m:[m306[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
def render_orchestration_summary_table(orchestration_logger: OrchestrationLogger):
                                                                               ^
[1m.\ui\orchestration_viewer.py[m[36m:[m348[36m:[m80[36m:[m [1m[31mE501[m line too long (86 > 79 characters)
        orchestration_logger.get_logs_by_type(OrchestrationActionType.BACKTEST_LAUNCH)
                                                                               ^
[1m.\ui\orchestration_viewer.py[m[36m:[m351[36m:[m80[36m:[m [1m[31mE501[m line too long (88 > 79 characters)
        orchestration_logger.get_logs_by_type(OrchestrationActionType.BACKTEST_COMPLETE)
                                                                               ^
[1m.\ui\orchestration_viewer.py[m[36m:[m354[36m:[m80[36m:[m [1m[31mE501[m line too long (86 > 79 characters)
        orchestration_logger.get_logs_by_type(OrchestrationActionType.BACKTEST_FAILED)
                                                                               ^
[1m.\ui\orchestration_viewer.py[m[36m:[m359[36m:[m80[36m:[m [1m[31mE501[m line too long (92 > 79 characters)
        orchestration_logger.get_logs_by_type(OrchestrationActionType.STRATEGY_MODIFICATION)
                                                                               ^
[1m.\ui\orchestration_viewer.py[m[36m:[m364[36m:[m80[36m:[m [1m[31mE501[m line too long (94 > 79 characters)
        orchestration_logger.get_logs_by_type(OrchestrationActionType.INDICATOR_VALUES_CHANGE)
                                                                               ^
[1m.\ui\orchestration_viewer.py[m[36m:[m367[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
        orchestration_logger.get_logs_by_type(OrchestrationActionType.INDICATOR_ADD)
                                                                               ^
[1m.\ui\orchestration_viewer.py[m[36m:[m386[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
        st.metric("Modifications Indicateurs", indicator_changes + indicator_adds)
                                                                               ^
[1m.\ui\orchestration_viewer.py[m[36m:[m462[36m:[m80[36m:[m [1m[31mE501[m line too long (93 > 79 characters)
        completed = sum(1 for e in self._events if e.status == OrchestrationStatus.COMPLETED)
                                                                               ^
[1m.\ui\orchestration_viewer.py[m[36m:[m494[36m:[m80[36m:[m [1m[31mE501[m line too long (92 > 79 characters)
            timestamp = datetime.fromisoformat(event.timestamp).strftime("%H:%M:%S.%f")[:-3]
                                                                               ^
[1m.\ui\orchestration_viewer.py[m[36m:[m514[36m:[m80[36m:[m [1m[31mE501[m line too long (96 > 79 characters)
                    detail_summary = " | ".join(f"{k}={v}" for k, v in list(params.items())[:3])
                                                                               ^
[1m.\ui\orchestration_viewer.py[m[36m:[m521[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
                        detail_summary = f"Sharpe: {results['sharpe_ratio']:.3f}"
                                                                               ^
[1m.\ui\orchestration_viewer.py[m[36m:[m537[36m:[m80[36m:[m [1m[31mE501[m line too long (136 > 79 characters)
        html = f"""
        <div style="background: {status_color}; color: {text_color};
                    padding: 8px 12px; border-radius: 6px; margin: 4px 0;
                    border-left: 4px solid rgba(0,0,0,0.2);">
            <div style="display: flex; justify-content: space-between; align-items: center;">
                <span>
                    {emoji} <code style="color: {text_color}; background: {timestamp_bg}; border: 1px solid {timestamp_border}; padding: 2px 5px; border-radius: 4px;">{escape(timestamp)}</code>
                    <strong>[{escape(agent_info)}]</strong> {escape(action)}
                </span>
                <span style="font-size: 0.85em; opacity: 0.8;">Iter {event.iteration}</span>
            </div>
            {f'<div style="font-size: 0.85em; margin-top: 4px; opacity: 0.9;">{escape(detail_summary)}</div>' if detail_summary else ''}
        </div>
        """
                   
                                                           ^
[1m.\ui\results.py[m[36m:[m4[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
"""
Module-ID: ui.results

Purpose: Affiche les r√©sultats d√©taill√©s des backtests avec m√©triques et graphiques.

Role in pipeline: reporting

Key components: render_results, m√©triques, graphiques

Inputs: SidebarState, r√©sultats de backtest

Outputs: Interface Streamlit avec m√©triques et visualisations

Dependencies: ui.state, ui.components.charts

Conventions: M√©triques financi√®res standardis√©es

Read-if: Affichage des r√©sultats de backtest

Skip-if: Pas de r√©sultats √† afficher
"""
   
                     

                                                    ^
[1m.\ui\results.py[m[36m:[m43[36m:[m80[36m:[m [1m[31mE501[m line too long (92 > 79 characters)
def render_results(state: SidebarState, best_pnl_tracker: Optional[BestPnlTracker]) -> None:
                                                                               ^
[1m.\ui\results.py[m[36m:[m114[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
                    f"{state.strategy_key} winner {state.symbol}/{state.timeframe}"
                                                                               ^
[1m.\ui\results.py[m[36m:[m155[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
                    st.session_state["versioned_preset_last_saved"] = saved.name
                                                                               ^
[1m.\ui\results.py[m[36m:[m162[36m:[m80[36m:[m [1m[31mE501[m line too long (90 > 79 characters)
        if result is not None and hasattr(result, "equity") and result.equity is not None:
                                                                               ^
[1m.\ui\results.py[m[36m:[m205[36m:[m80[36m:[m [1m[31mE501[m line too long (88 > 79 characters)
                        "Aucun trade execute, affichage du graphique de prix uniquement"
                                                                               ^
[1m.\ui\results.py[m[36m:[m223[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
                st.text(f"Rendement: {result.metrics['total_return_pct']:.2f}%")
                                                                               ^
[1m.\ui\results.py[m[36m:[m224[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
                st.text(f"Ann. Return: {result.metrics['annualized_return']:.2f}%")
                                                                               ^
[1m.\ui\results.py[m[36m:[m225[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
                st.text(f"Volatilit√©: {result.metrics['volatility_annual']:.2f}%")
                                                                               ^
[1m.\ui\results.py[m[36m:[m238[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
                st.text(f"Profit Factor: {result.metrics['profit_factor']:.2f}")
                                                                               ^
[1m.\ui\results.py[m[36m:[m242[36m:[m80[36m:[m [1m[31mE501[m line too long (87 > 79 characters)
            with st.expander("üìä Analyse Statistique Avanc√©e (Seaborn)", expanded=True):
                                                                               ^
[1m.\ui\results.py[m[36m:[m254[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
                    if hasattr(result, "returns") and result.returns is not None:
                                                                               ^
[1m.\ui\results.py[m[36m:[m262[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
                        st.info("Rendements non disponibles pour cette analyse")
                                                                               ^
[1m.\ui\results.py[m[36m:[m300[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
            display_cols = [c for c in cols_to_show if c in trades_display.columns]
                                                                               ^
[1m.\ui\results.py[m[36m:[m308[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
                f"Total: {total_trades} | Gagnants: {winners} | Perdants: {losers}"
                                                                               ^
[1m.\ui\results.py[m[36m:[m318[36m:[m80[36m:[m [1m[31mE501[m line too long (85 > 79 characters)
    st.info("üëÜ Configurez dans la sidebar puis cliquez sur **üöÄ Lancer le Backtest**")
                                                                               ^
[1m.\ui\results.py[m[36m:[m401[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
            """
        ### Questions Fr√©quentes

        **Q: Comment tester plus de combinaisons?**
        R: En mode Grille, d√©finissez Min/Max/Step pour chaque param√®tre.
        Augmentez la limite de combinaisons si n√©cessaire.

        **Q: Que signifie le Sharpe Ratio?**
        R: Rendement ajust√© au risque. > 1 = bon, > 2 = excellent.

        **Q: Pourquoi le mode Grille est lent?**
        R: Il teste toutes les combinaisons. Augmentez le Step ou r√©duisez la plage.
        """
               
                                

                             ^
[1m.\ui\sidebar.py[m[36m:[m4[36m:[m80[36m:[m [1m[31mE501[m line too long (108 > 79 characters)
"""
Module-ID: ui.sidebar

Purpose: G√®re la configuration et les contr√¥les de la sidebar pour la s√©lection de strat√©gies et param√®tres.

Role in pipeline: configuration / inputs

Key components: render_sidebar, gestion des param√®tres

Inputs: Donn√©es disponibles, strat√©gies

Outputs: SidebarState configur√©

Dependencies: ui.context, ui.constants

Conventions: Param√®tres valid√©s selon contraintes

Read-if: Configuration de l'interface utilisateur

Skip-if: Logique backend pure
"""
   
                     

                                                    ^
[1m.\ui\sidebar.py[m[36m:[m100[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
            data_status.warning("Aucune donn√©e trouv√©e, utilisation des d√©fauts")
                                                                               ^
[1m.\ui\sidebar.py[m[36m:[m102[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
            data_status.success(f"‚úÖ {len(available_tokens)} symboles disponibles")
                                                                               ^
[1m.\ui\sidebar.py[m[36m:[m119[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
            st.session_state["saved_runs_status"] = f"Pending load failed: {exc}"
                                                                               ^
[1m.\ui\sidebar.py[m[36m:[m125[36m:[m80[36m:[m [1m[31mE501[m line too long (89 > 79 characters)
        if pending_meta.timeframe and pending_meta.timeframe not in available_timeframes:
                                                                               ^
[1m.\ui\sidebar.py[m[36m:[m126[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
            available_timeframes = [pending_meta.timeframe] + available_timeframes
                                                                               ^
[1m.\ui\sidebar.py[m[36m:[m139[36m:[m80[36m:[m [1m[31mE501[m line too long (87 > 79 characters)
    btc_idx = available_tokens.index("BTCUSDC") if "BTCUSDC" in available_tokens else 0
                                                                               ^
[1m.\ui\sidebar.py[m[36m:[m147[36m:[m80[36m:[m [1m[31mE501[m line too long (86 > 79 characters)
    tf_idx = available_timeframes.index("30m") if "30m" in available_timeframes else 0
                                                                               ^
[1m.\ui\sidebar.py[m[36m:[m183[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
        # FIX 04/01/2026: NE PAS effacer les r√©sultats quand les donn√©es changent
                                                                               ^
[1m.\ui\sidebar.py[m[36m:[m184[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
        # Les r√©sultats d'un backtest/grid peuvent √™tre visualis√©s ind√©pendamment
                                                                               ^
[1m.\ui\sidebar.py[m[36m:[m185[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
        # des donn√©es OHLCV actuellement charg√©es. Effacer les r√©sultats causait
                                                                               ^
[1m.\ui\sidebar.py[m[36m:[m186[36m:[m80[36m:[m [1m[31mE501[m line too long (85 > 79 characters)
        # la perte de tous les r√©sultats apr√®s un grid search lors du prochain rerun.
                                                                               ^
[1m.\ui\sidebar.py[m[36m:[m199[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
            st.session_state["last_winner_params"] = result.meta.get("params", {})
                                                                               ^
[1m.\ui\sidebar.py[m[36m:[m211[36m:[m80[36m:[m [1m[31mE501[m line too long (86 > 79 characters)
                    st.session_state["saved_runs_status"] = f"Data load failed: {msg}"
                                                                               ^
[1m.\ui\sidebar.py[m[36m:[m213[36m:[m80[36m:[m [1m[31mE501[m line too long (90 > 79 characters)
                    st.session_state["saved_runs_status"] = f"Run loaded with data: {msg}"
                                                                               ^
[1m.\ui\sidebar.py[m[36m:[m215[36m:[m80[36m:[m [1m[31mE501[m line too long (87 > 79 characters)
                st.session_state["saved_runs_status"] = f"Run loaded: {pending_run_id}"
                                                                               ^
[1m.\ui\sidebar.py[m[36m:[m222[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
        df_loaded, msg = load_selected_data(symbol, timeframe, start_date, end_date)
                                                                               ^
[1m.\ui\sidebar.py[m[36m:[m253[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
                [f"**{ind.upper()}**" for ind in strategy_info.required_indicators]
                                                                               ^
[1m.\ui\sidebar.py[m[36m:[m329[36m:[m80[36m:[m [1m[31mE501[m line too long (97 > 79 characters)
            p for p in versioned_presets if (p.metadata or {}).get("version") == selected_version
                                                                               ^
[1m.\ui\sidebar.py[m[36m:[m375[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
        if st.sidebar.button("Load versioned preset", key="load_versioned_preset"):
                                                                               ^
[1m.\ui\sidebar.py[m[36m:[m383[36m:[m80[36m:[m [1m[31mE501[m line too long (85 > 79 characters)
                st.session_state["loaded_versioned_preset"] = loaded_preset.to_dict()
                                                                               ^
[1m.\ui\sidebar.py[m[36m:[m429[36m:[m80[36m:[m [1m[31mE501[m line too long (116 > 79 characters)
            help="Limite de combinaisons (10 - 100,000,000). Attention aux temps d'ex√©cution pour valeurs √©lev√©es.",
                                                                               ^
[1m.\ui\sidebar.py[m[36m:[m437[36m:[m80[36m:[m [1m[31mE501[m line too long (86 > 79 characters)
            help="Nombre de processus parall√®les pour l'optimisation (30 recommand√©)",
                                                                               ^
[1m.\ui\sidebar.py[m[36m:[m473[36m:[m80[36m:[m [1m[31mE501[m line too long (89 > 79 characters)
            help="Nombre maximum de backtests que le LLM peut lancer (10 - 100,000,000)",
                                                                               ^
[1m.\ui\sidebar.py[m[36m:[m546[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
                        help="Assigner differents modeles a chaque role d'agent",
                                                                               ^
[1m.\ui\sidebar.py[m[36m:[m551[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
                    available_model_names = [m.name for m in available_models_list]
                                                                               ^
[1m.\ui\sidebar.py[m[36m:[m557[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
                        help="Filtre la liste par taille et exclut deepseek-r1:70b",
                                                                               ^
[1m.\ui\sidebar.py[m[36m:[m579[36m:[m80[36m:[m [1m[31mE501[m line too long (88 > 79 characters)
                            m for m in available_model_names if m not in excluded_models
                                                                               ^
[1m.\ui\sidebar.py[m[36m:[m584[36m:[m80[36m:[m [1m[31mE501[m line too long (92 > 79 characters)
                            m for m in available_model_names if _is_model_under_limit(m, 20)
                                                                               ^
[1m.\ui\sidebar.py[m[36m:[m595[36m:[m80[36m:[m [1m[31mE501[m line too long (91 > 79 characters)
                            m for m in available_model_names if _is_model_over_limit(m, 20)
                                                                               ^
[1m.\ui\sidebar.py[m[36m:[m604[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
                            "Selection >=20B activee mais aucun modele compatible."
                                                                               ^
[1m.\ui\sidebar.py[m[36m:[m631[36m:[m80[36m:[m [1m[31mE501[m line too long (85 > 79 characters)
                            help="Charge une configuration pr√©d√©finie de mod√®les LLM"
                                                                               ^
[1m.\ui\sidebar.py[m[36m:[m637[36m:[m80[36m:[m [1m[31mE501[m line too long (94 > 79 characters)
                            if st.button("‚ö°", key="apply_preset", help="Appliquer ce preset"):
                                                                               ^
[1m.\ui\sidebar.py[m[36m:[m639[36m:[m80[36m:[m [1m[31mE501[m line too long (89 > 79 characters)
                                apply_preset_to_config(preset, get_global_model_config())
                                                                               ^
[1m.\ui\sidebar.py[m[36m:[m644[36m:[m80[36m:[m [1m[31mE501[m line too long (94 > 79 characters)
                        user_presets = [p for p in all_presets if not p.get("builtin", False)]
                                                                               ^
[1m.\ui\sidebar.py[m[36m:[m649[36m:[m80[36m:[m [1m[31mE501[m line too long (88 > 79 characters)
                            ["‚ûï Cr√©er nouveau", "‚úèÔ∏è Modifier existant", "üóëÔ∏è Supprimer"],
                                                                               ^
[1m.\ui\sidebar.py[m[36m:[m661[36m:[m80[36m:[m [1m[31mE501[m line too long (95 > 79 characters)
                            st.caption("üí° Ajustez les mod√®les ci-dessous avant de sauvegarder")
                                                                               ^
[1m.\ui\sidebar.py[m[36m:[m666[36m:[m80[36m:[m [1m[31mE501[m line too long (110 > 79 characters)
                                        current_config = get_current_config_as_dict(get_global_model_config())
                                                                               ^
[1m.\ui\sidebar.py[m[36m:[m667[36m:[m80[36m:[m [1m[31mE501[m line too long (108 > 79 characters)
                                        save_model_preset(new_preset_name.strip(), current_config["models"])
                                                                               ^
[1m.\ui\sidebar.py[m[36m:[m668[36m:[m80[36m:[m [1m[31mE501[m line too long (88 > 79 characters)
                                        st.success(f"‚úÖ Preset '{new_preset_name}' cr√©√©")
                                                                               ^
[1m.\ui\sidebar.py[m[36m:[m683[36m:[m80[36m:[m [1m[31mE501[m line too long (114 > 79 characters)
                                st.caption("üí° Chargez le preset ci-dessus, ajustez les mod√®les, puis sauvegardez")
                                                                               ^
[1m.\ui\sidebar.py[m[36m:[m685[36m:[m80[36m:[m [1m[31mE501[m line too long (97 > 79 characters)
                                if st.button("üíæ Sauvegarder modifications", key="update_preset"):
                                                                               ^
[1m.\ui\sidebar.py[m[36m:[m687[36m:[m80[36m:[m [1m[31mE501[m line too long (110 > 79 characters)
                                        current_config = get_current_config_as_dict(get_global_model_config())
                                                                               ^
[1m.\ui\sidebar.py[m[36m:[m688[36m:[m80[36m:[m [1m[31mE501[m line too long (101 > 79 characters)
                                        save_model_preset(preset_to_modify, current_config["models"])
                                                                               ^
[1m.\ui\sidebar.py[m[36m:[m689[36m:[m80[36m:[m [1m[31mE501[m line too long (95 > 79 characters)
                                        st.success(f"‚úÖ Preset '{preset_to_modify}' mis √† jour")
                                                                               ^
[1m.\ui\sidebar.py[m[36m:[m704[36m:[m80[36m:[m [1m[31mE501[m line too long (97 > 79 characters)
                                st.warning(f"‚ö†Ô∏è Supprimer '{preset_to_delete}' d√©finitivement ?")
                                                                               ^
[1m.\ui\sidebar.py[m[36m:[m706[36m:[m80[36m:[m [1m[31mE501[m line too long (94 > 79 characters)
                                if st.button("üóëÔ∏è Confirmer suppression", key="delete_preset"):
                                                                               ^
[1m.\ui\sidebar.py[m[36m:[m708[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
                                        if delete_model_preset(preset_to_delete):
                                                                               ^
[1m.\ui\sidebar.py[m[36m:[m709[36m:[m80[36m:[m [1m[31mE501[m line too long (97 > 79 characters)
                                            st.success(f"‚úÖ Preset '{preset_to_delete}' supprim√©")
                                                                               ^
[1m.\ui\sidebar.py[m[36m:[m726[36m:[m80[36m:[m [1m[31mE501[m line too long (93 > 79 characters)
                            "Active la configuration recommand√©e bas√©e sur les benchmarks:\n"
                                                                               ^
[1m.\ui\sidebar.py[m[36m:[m737[36m:[m80[36m:[m [1m[31mE501[m line too long (89 > 79 characters)
                            "Vous pouvez ajuster manuellement les s√©lections ci-dessous."
                                                                               ^
[1m.\ui\sidebar.py[m[36m:[m758[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
                    display_to_name = {v: k for k, v in name_to_display.items()}
                                                                               ^
[1m.\ui\sidebar.py[m[36m:[m764[36m:[m80[36m:[m [1m[31mE501[m line too long (94 > 79 characters)
                        help="Applique un seul mod√®le √† Analyst/Strategist/Critic/Validator.",
                                                                               ^
[1m.\ui\sidebar.py[m[36m:[m773[36m:[m80[36m:[m [1m[31mE501[m line too long (98 > 79 characters)
                                else (available_model_names[0] if available_model_names else None)
                                                                               ^
[1m.\ui\sidebar.py[m[36m:[m788[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
                                help="Ce mod√®le sera utilis√© pour tous les r√¥les.",
                                                                               ^
[1m.\ui\sidebar.py[m[36m:[m792[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
                                "Aucun mod√®le disponible pour unifier les r√¥les."
                                                                               ^
[1m.\ui\sidebar.py[m[36m:[m808[36m:[m80[36m:[m [1m[31mE501[m line too long (92 > 79 characters)
                        from ui.components.model_selector import get_optimal_config_for_role
                                                                               ^
[1m.\ui\sidebar.py[m[36m:[m809[36m:[m80[36m:[m [1m[31mE501[m line too long (103 > 79 characters)
                        optimal_analyst = get_optimal_config_for_role("analyst", available_model_names)
                                                                               ^
[1m.\ui\sidebar.py[m[36m:[m821[36m:[m80[36m:[m [1m[31mE501[m line too long (99 > 79 characters)
                            analyst_defaults[:3] if analyst_defaults else model_options_display[:2]
                                                                               ^
[1m.\ui\sidebar.py[m[36m:[m848[36m:[m80[36m:[m [1m[31mE501[m line too long (109 > 79 characters)
                        optimal_strategist = get_optimal_config_for_role("strategist", available_model_names)
                                                                               ^
[1m.\ui\sidebar.py[m[36m:[m850[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
                            name_to_display.get(m, m) for m in optimal_strategist
                                                                               ^
[1m.\ui\sidebar.py[m[36m:[m889[36m:[m80[36m:[m [1m[31mE501[m line too long (101 > 79 characters)
                        optimal_critic = get_optimal_config_for_role("critic", available_model_names)
                                                                               ^
[1m.\ui\sidebar.py[m[36m:[m901[36m:[m80[36m:[m [1m[31mE501[m line too long (97 > 79 characters)
                            critic_defaults[:3] if critic_defaults else model_options_display[:2]
                                                                               ^
[1m.\ui\sidebar.py[m[36m:[m928[36m:[m80[36m:[m [1m[31mE501[m line too long (107 > 79 characters)
                        optimal_validator = get_optimal_config_for_role("validator", available_model_names)
                                                                               ^
[1m.\ui\sidebar.py[m[36m:[m930[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
                            name_to_display.get(m, m) for m in optimal_validator
                                                                               ^
[1m.\ui\sidebar.py[m[36m:[m969[36m:[m80[36m:[m [1m[31mE501[m line too long (94 > 79 characters)
                        help="Les modeles lourds ne seront utilises qu'apres cette iteration",
                                                                               ^
[1m.\ui\sidebar.py[m[36m:[m972[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
                    def _normalize_selection(selection: List[str]) -> List[str]:
                                                                               ^
[1m.\ui\sidebar.py[m[36m:[m976[36m:[m80[36m:[m [1m[31mE501[m line too long (94 > 79 characters)
                    role_model_config.analyst.models = _normalize_selection(analyst_selection)
                                                                               ^
[1m.\ui\sidebar.py[m[36m:[m977[36m:[m80[36m:[m [1m[31mE501[m line too long (100 > 79 characters)
                    role_model_config.strategist.models = _normalize_selection(strategist_selection)
                                                                               ^
[1m.\ui\sidebar.py[m[36m:[m978[36m:[m80[36m:[m [1m[31mE501[m line too long (92 > 79 characters)
                    role_model_config.critic.models = _normalize_selection(critic_selection)
                                                                               ^
[1m.\ui\sidebar.py[m[36m:[m979[36m:[m80[36m:[m [1m[31mE501[m line too long (98 > 79 characters)
                    role_model_config.validator.models = _normalize_selection(validator_selection)
                                                                               ^
[1m.\ui\sidebar.py[m[36m:[m987[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
                        assignment.allow_heavy_after_iteration = heavy_after_iter
                                                                               ^
[1m.\ui\sidebar.py[m[36m:[m1062[36m:[m80[36m:[m [1m[31mE501[m line too long (91 > 79 characters)
                help="Lance l'optimisation sans limite d'it√©rations (arr√™t manuel requis)",
                                                                               ^
[1m.\ui\sidebar.py[m[36m:[m1082[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
                data_duration_days = (df_cached.index[-1] - df_cached.index[0]).days
                                                                               ^
[1m.\ui\sidebar.py[m[36m:[m1089[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
                        f"(dur√©e: {data_duration_months:.1f} mois < 6 mois requis)"
                                                                               ^
[1m.\ui\sidebar.py[m[36m:[m1093[36m:[m80[36m:[m [1m[31mE501[m line too long (93 > 79 characters)
                        f"‚úÖ Walk-Forward disponible (dur√©e: {data_duration_months:.1f} mois)"
                                                                               ^
[1m.\ui\sidebar.py[m[36m:[m1116[36m:[m80[36m:[m [1m[31mE501[m line too long (96 > 79 characters)
                    "Lib√®re la VRAM GPU pendant les backtests pour am√©liorer les performances. "
                                                                               ^
[1m.\ui\sidebar.py[m[36m:[m1117[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
                    "Recommand√© si vous utilisez CuPy/GPU pour les indicateurs. "
                                                                               ^
[1m.\ui\sidebar.py[m[36m:[m1123[36m:[m80[36m:[m [1m[31mE501[m line too long (85 > 79 characters)
            with st.sidebar.expander("Comparaison multi-strategies", expanded=False):
                                                                               ^
[1m.\ui\sidebar.py[m[36m:[m1208[36m:[m80[36m:[m [1m[31mE501[m line too long (86 > 79 characters)
                            f"Estime: {total_runs} runs (cap {llm_compare_max_runs})."
                                                                               ^
[1m.\ui\sidebar.py[m[36m:[m1214[36m:[m80[36m:[m [1m[31mE501[m line too long (89 > 79 characters)
                        if st.button("Lancer comparaison", key="llm_compare_run_button"):
                                                                               ^
[1m.\ui\sidebar.py[m[36m:[m1221[36m:[m80[36m:[m [1m[31mE501[m line too long (92 > 79 characters)
                max_iter_label = "‚àû" if llm_max_iterations <= 0 else str(llm_max_iterations)
                                                                               ^
[1m.\ui\sidebar.py[m[36m:[m1227[36m:[m80[36m:[m [1m[31mE501[m line too long (92 > 79 characters)
                max_iter_label = "‚àû" if llm_max_iterations <= 0 else str(llm_max_iterations)
                                                                               ^
[1m.\ui\sidebar.py[m[36m:[m1234[36m:[m80[36m:[m [1m[31mE501[m line too long (85 > 79 characters)
    param_mode = "range" if optimization_mode == "Grille de Param√®tres" else "single"
                                                                               ^
[1m.\ui\sidebar.py[m[36m:[m1273[36m:[m80[36m:[m [1m[31mE501[m line too long (89 > 79 characters)
                            params[param_name] = PARAM_CONSTRAINTS[param_name]["default"]
                                                                               ^
[1m.\ui\sidebar.py[m[36m:[m1290[36m:[m80[36m:[m [1m[31mE501[m line too long (96 > 79 characters)
                        f"‚ö†Ô∏è {stats.total_combinations:,} combinaisons (limite: {max_combos:,})"
                                                                               ^
[1m.\ui\sidebar.py[m[36m:[m1292[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
                    st.sidebar.caption("R√©duisez les plages ou augmentez le step")
                                                                               ^
[1m.\ui\sidebar.py[m[36m:[m1308[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
    leverage = create_param_range_selector("leverage", "trading", mode="single")
                                                                               ^
[1m.\ui\state.py[m[36m:[m4[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
"""
Module-ID: ui.state

Purpose: D√©finit les structures de donn√©es pour l'√©tat de l'interface utilisateur.

Role in pipeline: state management

Key components: SidebarState

Inputs: Param√®tres utilisateur

Outputs: √âtat structur√©

Dependencies: dataclasses

Conventions: √âtat immutable via dataclass

Read-if: Gestion d'√©tat UI

Skip-if: Logique m√©tier pure
"""
   
                   

                                                      ^
[1m.\ui\validation_integration.py[m[36m:[m63[36m:[m80[36m:[m [1m[31mE501[m line too long (95 > 79 characters)
        train_return=train_metrics.get("total_return_pct", 0.0) / 100.0,  # Convertir % ‚Üí ratio
                                                                               ^
[1m.\ui\validation_integration.py[m[36m:[m82[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
    """
    Cr√©e un ValidationReport √† partir des r√©sultats de run_walk_forward_for_agent().

    Args:
        strategy_name: Nom de la strat√©gie test√©e
        validation_results: R√©sultats retourn√©s par run_walk_forward_for_agent()
            Structure attendue:
            {
                'folds': List[Dict] avec keys: 'fold_id', 'train_metrics', 'test_metrics', 'params'
                'n_folds': int
                'train_pct': float (ex: 0.75)
                ... autres champs possibles
            }
        created_at: Timestamp du rapport (optionnel, d√©faut=maintenant)

    Returns:
        ValidationReport pr√™t pour render_validation_report()

    Example:
        >>> from agents.integration import run_walk_forward_for_agent
        >>> results = run_walk_forward_for_agent(strategy_name, params, data)
        >>> report = create_validation_report_from_results("ema_cross", results)
        >>> render_validation_report(report)
    """
       
                                                                       ^
[1m.\ui\validation_integration.py[m[36m:[m86[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
    """
    Cr√©e un ValidationReport √† partir des r√©sultats de run_walk_forward_for_agent().

    Args:
        strategy_name: Nom de la strat√©gie test√©e
        validation_results: R√©sultats retourn√©s par run_walk_forward_for_agent()
            Structure attendue:
            {
                'folds': List[Dict] avec keys: 'fold_id', 'train_metrics', 'test_metrics', 'params'
                'n_folds': int
                'train_pct': float (ex: 0.75)
                ... autres champs possibles
            }
        created_at: Timestamp du rapport (optionnel, d√©faut=maintenant)

    Returns:
        ValidationReport pr√™t pour render_validation_report()

    Example:
        >>> from agents.integration import run_walk_forward_for_agent
        >>> results = run_walk_forward_for_agent(strategy_name, params, data)
        >>> report = create_validation_report_from_results("ema_cross", results)
        >>> render_validation_report(report)
    """
       
                                                                       ^
[1m.\ui\validation_integration.py[m[36m:[m89[36m:[m80[36m:[m [1m[31mE501[m line too long (99 > 79 characters)
    """
    Cr√©e un ValidationReport √† partir des r√©sultats de run_walk_forward_for_agent().

    Args:
        strategy_name: Nom de la strat√©gie test√©e
        validation_results: R√©sultats retourn√©s par run_walk_forward_for_agent()
            Structure attendue:
            {
                'folds': List[Dict] avec keys: 'fold_id', 'train_metrics', 'test_metrics', 'params'
                'n_folds': int
                'train_pct': float (ex: 0.75)
                ... autres champs possibles
            }
        created_at: Timestamp du rapport (optionnel, d√©faut=maintenant)

    Returns:
        ValidationReport pr√™t pour render_validation_report()

    Example:
        >>> from agents.integration import run_walk_forward_for_agent
        >>> results = run_walk_forward_for_agent(strategy_name, params, data)
        >>> report = create_validation_report_from_results("ema_cross", results)
        >>> render_validation_report(report)
    """
       
                                                                       ^
[1m.\ui\validation_integration.py[m[36m:[m102[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
    """
    Cr√©e un ValidationReport √† partir des r√©sultats de run_walk_forward_for_agent().

    Args:
        strategy_name: Nom de la strat√©gie test√©e
        validation_results: R√©sultats retourn√©s par run_walk_forward_for_agent()
            Structure attendue:
            {
                'folds': List[Dict] avec keys: 'fold_id', 'train_metrics', 'test_metrics', 'params'
                'n_folds': int
                'train_pct': float (ex: 0.75)
                ... autres champs possibles
            }
        created_at: Timestamp du rapport (optionnel, d√©faut=maintenant)

    Returns:
        ValidationReport pr√™t pour render_validation_report()

    Example:
        >>> from agents.integration import run_walk_forward_for_agent
        >>> results = run_walk_forward_for_agent(strategy_name, params, data)
        >>> report = create_validation_report_from_results("ema_cross", results)
        >>> render_validation_report(report)
    """
       
                                                                       ^
[1m.\ui\validation_integration.py[m[36m:[m116[36m:[m80[36m:[m [1m[31mE501[m line too long (85 > 79 characters)
        # Le fold peut contenir directement les timestamps ou un objet ValidationFold
                                                                               ^
[1m.\ui\validation_integration.py[m[36m:[m141[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
                train_return=train_metrics.get("total_return_pct", 0.0) / 100.0,
                                                                               ^
[1m.\ui\validation_integration.py[m[36m:[m142[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
                train_drawdown=abs(train_metrics.get("max_drawdown", 0.0)) / 100.0,
                                                                               ^
[1m.\ui\validation_integration.py[m[36m:[m147[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
                test_drawdown=abs(test_metrics.get("max_drawdown", 0.0)) / 100.0,
                                                                               ^
[1m.\ui\validation_integration.py[m[36m:[m203[36m:[m80[36m:[m [1m[31mE501[m line too long (89 > 79 characters)
        with st.spinner(f"üîÑ Walk-Forward Validation en cours ({n_windows} fen√™tres)..."):
                                                                               ^
[1m.\use_profitable_configs.py[m[36m:[m23[36m:[m80[36m:[m [1m[31mE501[m line too long (86 > 79 characters)
        raise FileNotFoundError(f"Fichier de configuration non trouv√©: {config_file}")
                                                                               ^
[1m.\use_profitable_configs.py[m[36m:[m40[36m:[m80[36m:[m [1m[31mE501[m line too long (93 > 79 characters)
    print(f"   P√©riode: {meta.get('period_start', 'N/A')} ‚Üí {meta.get('period_end', 'N/A')}")
                                                                               ^
[1m.\use_profitable_configs.py[m[36m:[m47[36m:[m80[36m:[m [1m[31mE501[m line too long (95 > 79 characters)
    champions = [k for k in presets.keys() if k.endswith("_champion") or k.endswith("_bronze")]
                                                                               ^
[1m.\use_profitable_configs.py[m[36m:[m57[36m:[m80[36m:[m [1m[31mE501[m line too long (105 > 79 characters)
        print(f"      Performance: ${perf.get('pnl', 0):,.2f} ({perf.get('total_return_pct', 0):+.2f}%)")
                                                                               ^
[1m.\use_profitable_configs.py[m[36m:[m58[36m:[m80[36m:[m [1m[31mE501[m line too long (107 > 79 characters)
        print(f"      Trades: {perf.get('total_trades', 0)}, Win Rate: {perf.get('win_rate_pct', 0):.1f}%")
                                                                               ^
[1m.\use_profitable_configs.py[m[36m:[m70[36m:[m80[36m:[m [1m[31mE501[m line too long (109 > 79 characters)
            print(f"      Performance: ${perf.get('pnl', 0):,.2f} ({perf.get('total_return_pct', 0):+.2f}%)")
                                                                               ^
[1m.\use_profitable_configs.py[m[36m:[m82[36m:[m80[36m:[m [1m[31mE501[m line too long (88 > 79 characters)
        available = [k for k in presets.keys() if not k.startswith("_") and k != "meta"]
                                                                               ^
[1m.\use_profitable_configs.py[m[36m:[m83[36m:[m80[36m:[m [1m[31mE501[m line too long (88 > 79 characters)
        raise ValueError(f"Preset '{preset_name}' non trouv√©. Disponibles: {available}")
                                                                               ^
[1m.\use_profitable_configs.py[m[36m:[m111[36m:[m80[36m:[m [1m[31mE501[m line too long (95 > 79 characters)
        sample_file = Path(__file__).parent / "data" / "sample_data" / "BTCUSDT_1h_6months.csv"
                                                                               ^
[1m.\use_profitable_configs.py[m[36m:[m151[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
    print(f"PnL attendu: ${expected_perf.get('pnl', 0):,.2f} | Obtenu: ${pnl:,.2f}")
                                                                               ^
[1m.\use_profitable_configs.py[m[36m:[m152[36m:[m80[36m:[m [1m[31mE501[m line too long (131 > 79 characters)
    print(f"Return attendu: {expected_perf.get('total_return_pct', 0):+.2f}% | Obtenu: {metrics.get('total_return_pct', 0):+.2f}%")
                                                                               ^
[1m.\use_profitable_configs.py[m[36m:[m153[36m:[m80[36m:[m [1m[31mE501[m line too long (112 > 79 characters)
    print(f"Trades attendus: {expected_perf.get('total_trades', 0)} | Obtenu: {metrics.get('total_trades', 0)}")
                                                                               ^
[1m.\use_profitable_configs.py[m[36m:[m168[36m:[m80[36m:[m [1m[31mE501[m line too long (98 > 79 characters)
    parser = argparse.ArgumentParser(description="Utiliser les configurations rentables valid√©es")
                                                                               ^
[1m.\use_profitable_configs.py[m[36m:[m169[36m:[m80[36m:[m [1m[31mE501[m line too long (98 > 79 characters)
    parser.add_argument("--list", action="store_true", help="Lister tous les presets disponibles")
                                                                               ^
[1m.\use_profitable_configs.py[m[36m:[m171[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
    parser.add_argument("--backtest", type=str, help="Nom du preset √† backtester")
                                                                               ^
[1m.\use_profitable_configs.py[m[36m:[m172[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
    parser.add_argument("--data", type=str, help="Fichier de donn√©es personnalis√©")
                                                                               ^
[1m.\use_profitable_configs.py[m[36m:[m195[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
        print("  python use_profitable_configs.py --backtest ema_cross_champion")
                                                                               ^
[1m.\use_profitable_configs.py[m[36m:[m196[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
        print("  python use_profitable_configs.py --preset rsi_reversal_champion")
                                                                               ^
[1m.\utils\__init__.py[m[36m:[m16[36m:[m80[36m:[m [1m[31mE501[m line too long (86 > 79 characters)
"""
Module-ID: utils.__init__

Purpose: Package utils - exports config, log, visualization, observability.

Role in pipeline: core infrastructure

Key components: Re-exports Config, get_logger, visualization functions

Inputs: None (module imports only)

Outputs: Public API via __all__

Dependencies: Internal (config, log, visualization modules)

Conventions: __all__ d√©finit API publique; imports conditionnels si deps optionnelles.

Read-if: Modification exports ou ordre imports.

Skip-if: Vous importez directement depuis utils.config ou utils.log.
"""
   
                         

                                                ^
[1m.\utils\checkpoint.py[m[36m:[m4[36m:[m80[36m:[m [1m[31mE501[m line too long (118 > 79 characters)
"""
Module-ID: utils.checkpoint

Purpose: Gestionnaire de checkpoints pour sauvegarde/reprise automatique d'op√©rations longues (sweeps, optimisations).

Role in pipeline: resilience / state management

Key components: CheckpointManager, CheckpointMetadata, checkpoint_context (context manager)

Inputs: operation_type (str), state (dict), checkpoint_dir (Path optionnel)

Outputs: Fichiers JSON checkpoint (state + metadata), resume capability apr√®s crash/interruption

Dependencies: json, pathlib, dataclasses, utils.log, hashlib

Conventions: Checkpoints JSON pour portabilit√©/lisibilit√©; checkpoint_id unique (hash params); progress 0.0-1.0; auto-save p√©riodique; resume transparente via checkpoint_context(); nettoyage automatique anciens checkpoints.

Read-if: Gestion checkpoints pour sweeps, recovery apr√®s crash, ou state persistence long-running ops.

Skip-if: Op√©rations courtes sans besoin de resume/recovery.
"""
   
                           

                                              ^
[1m.\utils\checkpoint.py[m[36m:[m8[36m:[m80[36m:[m [1m[31mE501[m line too long (91 > 79 characters)
"""
Module-ID: utils.checkpoint

Purpose: Gestionnaire de checkpoints pour sauvegarde/reprise automatique d'op√©rations longues (sweeps, optimisations).

Role in pipeline: resilience / state management

Key components: CheckpointManager, CheckpointMetadata, checkpoint_context (context manager)

Inputs: operation_type (str), state (dict), checkpoint_dir (Path optionnel)

Outputs: Fichiers JSON checkpoint (state + metadata), resume capability apr√®s crash/interruption

Dependencies: json, pathlib, dataclasses, utils.log, hashlib

Conventions: Checkpoints JSON pour portabilit√©/lisibilit√©; checkpoint_id unique (hash params); progress 0.0-1.0; auto-save p√©riodique; resume transparente via checkpoint_context(); nettoyage automatique anciens checkpoints.

Read-if: Gestion checkpoints pour sweeps, recovery apr√®s crash, ou state persistence long-running ops.

Skip-if: Op√©rations courtes sans besoin de resume/recovery.
"""
   
                           

                                              ^
[1m.\utils\checkpoint.py[m[36m:[m12[36m:[m80[36m:[m [1m[31mE501[m line too long (96 > 79 characters)
"""
Module-ID: utils.checkpoint

Purpose: Gestionnaire de checkpoints pour sauvegarde/reprise automatique d'op√©rations longues (sweeps, optimisations).

Role in pipeline: resilience / state management

Key components: CheckpointManager, CheckpointMetadata, checkpoint_context (context manager)

Inputs: operation_type (str), state (dict), checkpoint_dir (Path optionnel)

Outputs: Fichiers JSON checkpoint (state + metadata), resume capability apr√®s crash/interruption

Dependencies: json, pathlib, dataclasses, utils.log, hashlib

Conventions: Checkpoints JSON pour portabilit√©/lisibilit√©; checkpoint_id unique (hash params); progress 0.0-1.0; auto-save p√©riodique; resume transparente via checkpoint_context(); nettoyage automatique anciens checkpoints.

Read-if: Gestion checkpoints pour sweeps, recovery apr√®s crash, ou state persistence long-running ops.

Skip-if: Op√©rations courtes sans besoin de resume/recovery.
"""
   
                           

                                              ^
[1m.\utils\checkpoint.py[m[36m:[m16[36m:[m80[36m:[m [1m[31mE501[m line too long (223 > 79 characters)
"""
Module-ID: utils.checkpoint

Purpose: Gestionnaire de checkpoints pour sauvegarde/reprise automatique d'op√©rations longues (sweeps, optimisations).

Role in pipeline: resilience / state management

Key components: CheckpointManager, CheckpointMetadata, checkpoint_context (context manager)

Inputs: operation_type (str), state (dict), checkpoint_dir (Path optionnel)

Outputs: Fichiers JSON checkpoint (state + metadata), resume capability apr√®s crash/interruption

Dependencies: json, pathlib, dataclasses, utils.log, hashlib

Conventions: Checkpoints JSON pour portabilit√©/lisibilit√©; checkpoint_id unique (hash params); progress 0.0-1.0; auto-save p√©riodique; resume transparente via checkpoint_context(); nettoyage automatique anciens checkpoints.

Read-if: Gestion checkpoints pour sweeps, recovery apr√®s crash, ou state persistence long-running ops.

Skip-if: Op√©rations courtes sans besoin de resume/recovery.
"""
   
                           

                                              ^
[1m.\utils\checkpoint.py[m[36m:[m18[36m:[m80[36m:[m [1m[31mE501[m line too long (102 > 79 characters)
"""
Module-ID: utils.checkpoint

Purpose: Gestionnaire de checkpoints pour sauvegarde/reprise automatique d'op√©rations longues (sweeps, optimisations).

Role in pipeline: resilience / state management

Key components: CheckpointManager, CheckpointMetadata, checkpoint_context (context manager)

Inputs: operation_type (str), state (dict), checkpoint_dir (Path optionnel)

Outputs: Fichiers JSON checkpoint (state + metadata), resume capability apr√®s crash/interruption

Dependencies: json, pathlib, dataclasses, utils.log, hashlib

Conventions: Checkpoints JSON pour portabilit√©/lisibilit√©; checkpoint_id unique (hash params); progress 0.0-1.0; auto-save p√©riodique; resume transparente via checkpoint_context(); nettoyage automatique anciens checkpoints.

Read-if: Gestion checkpoints pour sweeps, recovery apr√®s crash, ou state persistence long-running ops.

Skip-if: Op√©rations courtes sans besoin de resume/recovery.
"""
   
                           

                                              ^
[1m.\utils\checkpoint.py[m[36m:[m109[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
            self.metadata.progress = len(self.results) / self.metadata.total_items
                                                                               ^
[1m.\utils\checkpoint.py[m[36m:[m226[36m:[m80[36m:[m [1m[31mE501[m line too long (88 > 79 characters)
            f"({checkpoint.metadata.completed_items}/{checkpoint.metadata.total_items})"
                                                                               ^
[1m.\utils\checkpoint.py[m[36m:[m373[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
        logger.info(f"Checkpoint en pause: {checkpoint.metadata.checkpoint_id}")
                                                                               ^
[1m.\utils\circuit_breaker.py[m[36m:[m16[36m:[m80[36m:[m [1m[31mE501[m line too long (85 > 79 characters)
"""
Module-ID: utils.circuit_breaker

Purpose: Circuit Breaker - protection contre cascades d'erreurs r√©p√©t√©es.

Role in pipeline: resilience

Key components: CircuitBreaker, CircuitBreakerState, CircuitBreakerError

Inputs: √âchecs threshold, success threshold, timeout

Outputs: Autorisation/blocage appels, notifications √©tat

Dependencies: threading, time, dataclasses, Enum

Conventions: √âtats CLOSED/OPEN/HALF_OPEN; exponential backoff; async-safe avec locks.

Read-if: Modification seuils d'erreur/succ√®s, timeouts.

Skip-if: Vous utilisez juste CircuitBreaker.call().
"""
   
                                

                                         ^
[1m.\utils\circuit_breaker.py[m[36m:[m109[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
    def record_state_change(self, from_state: CircuitState, to_state: CircuitState):
                                                                               ^
[1m.\utils\circuit_breaker.py[m[36m:[m185[36m:[m80[36m:[m [1m[31mE501[m line too long (85 > 79 characters)
        logger.debug(f"CircuitBreaker '{name}' cr√©√© (threshold={failure_threshold})")
                                                                               ^
[1m.\utils\circuit_breaker.py[m[36m:[m233[36m:[m80[36m:[m [1m[31mE501[m line too long (89 > 79 characters)
            logger.info(f"CircuitBreaker '{self.name}' en HALF_OPEN (test r√©cup√©ration)")
                                                                               ^
[1m.\utils\circuit_breaker.py[m[36m:[m236[36m:[m80[36m:[m [1m[31mE501[m line too long (85 > 79 characters)
            logger.info(f"CircuitBreaker '{self.name}' FERM√â (r√©cup√©ration r√©ussie)")
                                                                               ^
[1m.\utils\config.py[m[36m:[m16[36m:[m80[36m:[m [1m[31mE501[m line too long (90 > 79 characters)
"""
Module-ID: utils.config

Purpose: Configuration centralis√©e du moteur (data_dir, frais, slippage, etc.).

Role in pipeline: core

Key components: Config (dataclass), singleton pattern, env var override

Inputs: Fichier config, variables d'environnement

Outputs: Config dict accessible globalement

Dependencies: dataclasses, pathlib, json

Conventions: BPS pour frais/slippage; data_dir obligatoire; env vars override config file.

Read-if: Modification params config, defaults, ou env var parsing.

Skip-if: Vous appelez juste Config.get_instance().
"""
   
                       

                                                  ^
[1m.\utils\config.py[m[36m:[m44[36m:[m80[36m:[m [1m[31mE501[m line too long (105 > 79 characters)
    data_dir: Path = field(default_factory=lambda: Path(r"D:\ThreadX_big\data\crypto\processed\parquet"))
                                                                               ^
[1m.\utils\config.py[m[36m:[m45[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
    # Mod√®les LLM: configur√©s via D:\models\models.json (voir utils.model_loader)
                                                                               ^
[1m.\utils\data.py[m[36m:[m32[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
    """
    D√©tecte les gaps temporels dans un DataFrame OHLCV.

    Les gaps sont des p√©riodes manquantes dans la s√©rie temporelle qui devraient
    normalement √™tre pr√©sentes selon la fr√©quence attendue.

    Args:
        df: DataFrame avec DatetimeIndex contenant les donn√©es OHLCV
        expected_freq: Fr√©quence attendue ('1h', '4h', '1d', etc.). Si None, sera inf√©r√©e.

    Returns:
        Dict avec:
            - gaps_count: Nombre total de gaps d√©tect√©s
            - gaps_pct: Pourcentage de donn√©es manquantes
            - gaps_sample: √âchantillon (max 5) des timestamps manquants
            - note: Information suppl√©mentaire si d√©tection impossible

    Examples:
        >>> df = load_ohlcv_data()
        >>> gaps = detect_gaps(df, expected_freq='1h')
        >>> print(f"Gaps trouv√©s : {gaps['gaps_count']} ({gaps['gaps_pct']:.2f}%)")
    """
       
                                                       

              ^
[1m.\utils\data.py[m[36m:[m37[36m:[m80[36m:[m [1m[31mE501[m line too long (90 > 79 characters)
    """
    D√©tecte les gaps temporels dans un DataFrame OHLCV.

    Les gaps sont des p√©riodes manquantes dans la s√©rie temporelle qui devraient
    normalement √™tre pr√©sentes selon la fr√©quence attendue.

    Args:
        df: DataFrame avec DatetimeIndex contenant les donn√©es OHLCV
        expected_freq: Fr√©quence attendue ('1h', '4h', '1d', etc.). Si None, sera inf√©r√©e.

    Returns:
        Dict avec:
            - gaps_count: Nombre total de gaps d√©tect√©s
            - gaps_pct: Pourcentage de donn√©es manquantes
            - gaps_sample: √âchantillon (max 5) des timestamps manquants
            - note: Information suppl√©mentaire si d√©tection impossible

    Examples:
        >>> df = load_ohlcv_data()
        >>> gaps = detect_gaps(df, expected_freq='1h')
        >>> print(f"Gaps trouv√©s : {gaps['gaps_count']} ({gaps['gaps_pct']:.2f}%)")
    """
       
                                                       

              ^
[1m.\utils\data.py[m[36m:[m49[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
    """
    D√©tecte les gaps temporels dans un DataFrame OHLCV.

    Les gaps sont des p√©riodes manquantes dans la s√©rie temporelle qui devraient
    normalement √™tre pr√©sentes selon la fr√©quence attendue.

    Args:
        df: DataFrame avec DatetimeIndex contenant les donn√©es OHLCV
        expected_freq: Fr√©quence attendue ('1h', '4h', '1d', etc.). Si None, sera inf√©r√©e.

    Returns:
        Dict avec:
            - gaps_count: Nombre total de gaps d√©tect√©s
            - gaps_pct: Pourcentage de donn√©es manquantes
            - gaps_sample: √âchantillon (max 5) des timestamps manquants
            - note: Information suppl√©mentaire si d√©tection impossible

    Examples:
        >>> df = load_ohlcv_data()
        >>> gaps = detect_gaps(df, expected_freq='1h')
        >>> print(f"Gaps trouv√©s : {gaps['gaps_count']} ({gaps['gaps_pct']:.2f}%)")
    """
       
                                                       

              ^
[1m.\utils\data.py[m[36m:[m91[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
    gaps_pct = (gaps_count / len(full_index) * 100) if len(full_index) > 0 else 0.0
                                                                               ^
[1m.\utils\error_recovery.py[m[36m:[m4[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
"""
Module-ID: utils.error_recovery

Purpose: Error Recovery - retry avec backoff exponentiel et classification erreurs.

Role in pipeline: resilience

Key components: RetryHandler, ErrorClassifier, RetryStrategy, TransientError

Inputs: Exception, max_retries, backoff_factor

Outputs: Succ√®s apr√®s retry, ou final ErrorExhausted apr√®s N tentatives

Dependencies: functools, logging, time, traceback

Conventions: Backoff exponentiel optionnel; classification transitoire/permanent; callbacks setup/cleanup.

Read-if: Modification strat√©gies retry, classification erreurs.

Skip-if: Vous utilisez juste @retry_on_error decorator.
"""
   
                               

                                          ^
[1m.\utils\error_recovery.py[m[36m:[m16[36m:[m80[36m:[m [1m[31mE501[m line too long (106 > 79 characters)
"""
Module-ID: utils.error_recovery

Purpose: Error Recovery - retry avec backoff exponentiel et classification erreurs.

Role in pipeline: resilience

Key components: RetryHandler, ErrorClassifier, RetryStrategy, TransientError

Inputs: Exception, max_retries, backoff_factor

Outputs: Succ√®s apr√®s retry, ou final ErrorExhausted apr√®s N tentatives

Dependencies: functools, logging, time, traceback

Conventions: Backoff exponentiel optionnel; classification transitoire/permanent; callbacks setup/cleanup.

Read-if: Modification strat√©gies retry, classification erreurs.

Skip-if: Vous utilisez juste @retry_on_error decorator.
"""
   
                               

                                          ^
[1m.\utils\error_recovery.py[m[36m:[m101[36m:[m80[36m:[m [1m[31mE501[m line too long (94 > 79 characters)
    def __init__(self, custom_mapping: Optional[Dict[Type[Exception], ErrorCategory]] = None):
                                                                               ^
[1m.\utils\error_recovery.py[m[36m:[m133[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
        if any(w in msg for w in ["timeout", "connection", "network", "refused"]):
                                                                               ^
[1m.\utils\error_recovery.py[m[36m:[m136[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
        if any(w in msg for w in ["memory", "oom", "allocation", "out of memory"]):
                                                                               ^
[1m.\utils\error_recovery.py[m[36m:[m147[36m:[m80[36m:[m [1m[31mE501[m line too long (99 > 79 characters)
        return category in (ErrorCategory.TRANSIENT, ErrorCategory.NETWORK, ErrorCategory.RESOURCE)
                                                                               ^
[1m.\utils\error_recovery.py[m[36m:[m188[36m:[m80[36m:[m [1m[31mE501[m line too long (91 > 79 characters)
        delay = self.config.initial_delay * (self.config.exponential_base ** (attempt - 1))
                                                                               ^
[1m.\utils\error_recovery.py[m[36m:[m258[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
                    f"Attempt {attempt}/{self.config.max_attempts} failed: {exc}"
                                                                               ^
[1m.\utils\error_recovery.py[m[36m:[m281[36m:[m80[36m:[m [1m[31mE501[m line too long (86 > 79 characters)
        raise last_error.exception if last_error else RuntimeError("No attempts made")
                                                                               ^
[1m.\utils\gpu_oom.py[m[36m:[m4[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
"""
Module-ID: utils.gpu_oom

Purpose: GPU OOM Handler - fallback automatique CPU si m√©moire GPU insuffisante.

Role in pipeline: performance / resilience

Key components: GPUOOMHandler, gpu_memory_available, fallback_to_cpu context manager

Inputs: M√©moire estim√©e requise, device

Outputs: Calculs GPU ou fallback CPU, notifications

Dependencies: cupy (optionnel), numpy, logging, contextlib

Conventions: Estimation proactive m√©moire; nettoyage cache GPU avant fallback; transparent pour caller.

Read-if: Modification estimation m√©moire, logique fallback.

Skip-if: Vous utilisez juste @gpu_safe decorator.
"""
   
                        

                                                 ^
[1m.\utils\gpu_oom.py[m[36m:[m8[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
"""
Module-ID: utils.gpu_oom

Purpose: GPU OOM Handler - fallback automatique CPU si m√©moire GPU insuffisante.

Role in pipeline: performance / resilience

Key components: GPUOOMHandler, gpu_memory_available, fallback_to_cpu context manager

Inputs: M√©moire estim√©e requise, device

Outputs: Calculs GPU ou fallback CPU, notifications

Dependencies: cupy (optionnel), numpy, logging, contextlib

Conventions: Estimation proactive m√©moire; nettoyage cache GPU avant fallback; transparent pour caller.

Read-if: Modification estimation m√©moire, logique fallback.

Skip-if: Vous utilisez juste @gpu_safe decorator.
"""
   
                        

                                                 ^
[1m.\utils\gpu_oom.py[m[36m:[m16[36m:[m80[36m:[m [1m[31mE501[m line too long (103 > 79 characters)
"""
Module-ID: utils.gpu_oom

Purpose: GPU OOM Handler - fallback automatique CPU si m√©moire GPU insuffisante.

Role in pipeline: performance / resilience

Key components: GPUOOMHandler, gpu_memory_available, fallback_to_cpu context manager

Inputs: M√©moire estim√©e requise, device

Outputs: Calculs GPU ou fallback CPU, notifications

Dependencies: cupy (optionnel), numpy, logging, contextlib

Conventions: Estimation proactive m√©moire; nettoyage cache GPU avant fallback; transparent pour caller.

Read-if: Modification estimation m√©moire, logique fallback.

Skip-if: Vous utilisez juste @gpu_safe decorator.
"""
   
                        

                                                 ^
[1m.\utils\gpu_oom.py[m[36m:[m192[36m:[m80[36m:[m [1m[31mE501[m line too long (93 > 79 characters)
    def estimate_memory_required(self, data_shape: Tuple[int, ...], dtype=np.float64) -> int:
                                                                               ^
[1m.\utils\gpu_utils.py[m[36m:[m4[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
"""
Module-ID: utils.gpu_utils

Purpose: Utilitaires GPU - conversions CuPy‚ÜîNumPy, d√©tection GPU, interop CPU/GPU.

Role in pipeline: performance

Key components: ensure_numpy_array, ensure_cupy_array, is_gpu_available, ArrayBackend

Inputs: Array NumPy ou CuPy, flag force_cpu

Outputs: Converted array (NumPy ou CuPy), device info

Dependencies: numpy, cupy (optionnel), importlib

Conventions: D√©tection CuPy runtime; conversions transparentes; fallback NumPy si pas GPU.

Read-if: Modification conversions, d√©tection GPU.

Skip-if: Vous utilisez juste ensure_numpy_array().
"""
   
                          

                                               ^
[1m.\utils\gpu_utils.py[m[36m:[m8[36m:[m80[36m:[m [1m[31mE501[m line too long (85 > 79 characters)
"""
Module-ID: utils.gpu_utils

Purpose: Utilitaires GPU - conversions CuPy‚ÜîNumPy, d√©tection GPU, interop CPU/GPU.

Role in pipeline: performance

Key components: ensure_numpy_array, ensure_cupy_array, is_gpu_available, ArrayBackend

Inputs: Array NumPy ou CuPy, flag force_cpu

Outputs: Converted array (NumPy ou CuPy), device info

Dependencies: numpy, cupy (optionnel), importlib

Conventions: D√©tection CuPy runtime; conversions transparentes; fallback NumPy si pas GPU.

Read-if: Modification conversions, d√©tection GPU.

Skip-if: Vous utilisez juste ensure_numpy_array().
"""
   
                          

                                               ^
[1m.\utils\gpu_utils.py[m[36m:[m16[36m:[m80[36m:[m [1m[31mE501[m line too long (90 > 79 characters)
"""
Module-ID: utils.gpu_utils

Purpose: Utilitaires GPU - conversions CuPy‚ÜîNumPy, d√©tection GPU, interop CPU/GPU.

Role in pipeline: performance

Key components: ensure_numpy_array, ensure_cupy_array, is_gpu_available, ArrayBackend

Inputs: Array NumPy ou CuPy, flag force_cpu

Outputs: Converted array (NumPy ou CuPy), device info

Dependencies: numpy, cupy (optionnel), importlib

Conventions: D√©tection CuPy runtime; conversions transparentes; fallback NumPy si pas GPU.

Read-if: Modification conversions, d√©tection GPU.

Skip-if: Vous utilisez juste ensure_numpy_array().
"""
   
                          

                                               ^
[1m.\utils\gpu_utils.py[m[36m:[m113[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
    # Ref: https://numba.readthedocs.io/en/stable/cuda/cuda_array_interface.html
                                                                               ^
[1m.\utils\gpu_utils.py[m[36m:[m248[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
    assert all(isinstance(a, np.ndarray) for a in result), "‚ùå √âl√©ments pas NumPy"
                                                                               ^
[1m.\utils\gpu_utils.py[m[36m:[m265[36m:[m80[36m:[m [1m[31mE501[m line too long (88 > 79 characters)
        assert all(isinstance(a, np.ndarray) for a in cpu_tuple), "‚ùå √âl√©ments pas NumPy"
                                                                               ^
[1m.\utils\health.py[m[36m:[m16[36m:[m80[36m:[m [1m[31mE501[m line too long (91 > 79 characters)
"""
Module-ID: utils.health

Purpose: Health Monitor - surveillance CPU/RAM/GPU/Disk avec alertes et seuils.

Role in pipeline: performance / monitoring

Key components: HealthMonitor, HealthMetrics, HealthAlert, Severity enum

Inputs: Seuils (%), polling intervals

Outputs: M√©triques sant√©, alertes, d√©clenchement actions

Dependencies: psutil, threading, dataclasses, cpu_percent, memory_percent

Conventions: Seuils configurables; alertes s√©v√©rit√© (CRITICAL/WARNING); polling asynchrone.

Read-if: Modification seuils, m√©triques collect√©es, ou actions alertes.

Skip-if: Vous utilisez juste HealthMonitor.check().
"""
   
                       

                                                  ^
[1m.\utils\health.py[m[36m:[m181[36m:[m80[36m:[m [1m[31mE501[m line too long (98 > 79 characters)
        logger.debug(f"HealthMonitor initialis√© (psutil={self._has_psutil}, gpu={self._has_gpu})")
                                                                               ^
[1m.\utils\health.py[m[36m:[m189[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
            logger.warning("psutil non disponible - m√©triques CPU/RAM limit√©es")
                                                                               ^
[1m.\utils\health.py[m[36m:[m261[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
                    "cached_gb": round(getattr(mem, 'cached', 0) / (1024**3), 2),
                                                                               ^
[1m.\utils\health.py[m[36m:[m343[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
                mem_total = mempool.total_bytes() or (8 * 1024**3)  # D√©faut 8GB
                                                                               ^
[1m.\utils\health.py[m[36m:[m448[36m:[m80[36m:[m [1m[31mE501[m line too long (91 > 79 characters)
        statuses = [m.status for m in metrics.values() if m.status != HealthStatus.UNKNOWN]
                                                                               ^
[1m.\utils\health.py[m[36m:[m463[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
                alert = f"CRITICAL: {resource.value} √† {metric.usage_percent:.1f}%"
                                                                               ^
[1m.\utils\health.py[m[36m:[m468[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
                alert = f"WARNING: {resource.value} √† {metric.usage_percent:.1f}%"
                                                                               ^
[1m.\utils\health.py[m[36m:[m535[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
        self._monitor_thread = threading.Thread(target=monitor_loop, daemon=True)
                                                                               ^
[1m.\utils\health.py[m[36m:[m605[36m:[m80[36m:[m [1m[31mE501[m line too long (96 > 79 characters)
            lines.append(f"{status_icon} {resource.value.upper()}: {metric.usage_percent:.1f}%")
                                                                               ^
[1m.\utils\indicator_ranges.py[m[36m:[m4[36m:[m80[36m:[m [1m[31mE501[m line too long (87 > 79 characters)
"""
Module-ID: utils.indicator_ranges

Purpose: Charge plages param√©triques d'indicateurs depuis config/indicator_ranges.toml.

Role in pipeline: configuration

Key components: load_indicator_ranges(), _INDICATOR_RANGES_CACHE, tomllib wrapper

Inputs: TOML file config/indicator_ranges.toml

Outputs: Dict nested {indicator ‚Üí param ‚Üí spec} (cached)

Dependencies: tomllib/tomli, pathlib

Conventions: Cache global; None path ‚Üí r√©pertoire par d√©faut.

Read-if: Modification chargement config indicateurs.

Skip-if: Vous appelez load_indicator_ranges() en tant qu'utilisateur.
"""
   
                                 

                                        ^
[1m.\utils\indicator_ranges.py[m[36m:[m8[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
"""
Module-ID: utils.indicator_ranges

Purpose: Charge plages param√©triques d'indicateurs depuis config/indicator_ranges.toml.

Role in pipeline: configuration

Key components: load_indicator_ranges(), _INDICATOR_RANGES_CACHE, tomllib wrapper

Inputs: TOML file config/indicator_ranges.toml

Outputs: Dict nested {indicator ‚Üí param ‚Üí spec} (cached)

Dependencies: tomllib/tomli, pathlib

Conventions: Cache global; None path ‚Üí r√©pertoire par d√©faut.

Read-if: Modification chargement config indicateurs.

Skip-if: Vous appelez load_indicator_ranges() en tant qu'utilisateur.
"""
   
                                 

                                        ^
[1m.\utils\indicator_ranges.py[m[36m:[m59[36m:[m80[36m:[m [1m[31mE501[m line too long (90 > 79 characters)
def load_indicator_ranges(path: Optional[Path] = None) -> Dict[str, Dict[str, ParamSpec]]:
                                                                               ^
[1m.\utils\indicator_ranges.py[m[36m:[m84[36m:[m80[36m:[m [1m[31mE501[m line too long (87 > 79 characters)
        path = Path(__file__).resolve().parents[1] / "config" / "indicator_ranges.toml"
                                                                               ^
[1m.\utils\indicator_ranges.py[m[36m:[m89[36m:[m80[36m:[m [1m[31mE501[m line too long (91 > 79 characters)
            f"Cr√©ez le fichier config/indicator_ranges.toml ou sp√©cifiez un chemin valide."
                                                                               ^
[1m.\utils\indicator_ranges.py[m[36m:[m100[36m:[m80[36m:[m [1m[31mE501[m line too long (96 > 79 characters)
    except (tomllib.TOMLDecodeError if hasattr(tomllib, 'TOMLDecodeError') else Exception) as e:
                                                                               ^
[1m.\utils\indicator_ranges.py[m[36m:[m125[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
    """
    Return parameter specs for a single indicator.

    Args:
        indicator_name: Nom de l'indicateur (case-insensitive).
        ranges: Optional pre-loaded ranges dict. If None, loads from default path.

    Returns:
        Dict mapping parameter names to their specifications.
        Example: {"period": {"min": 7, "max": 21, "default": 14, ...}}

    Example:
        >>> specs = get_indicator_param_specs("rsi")
        >>> specs["period"]["default"]
        14
    """
       
                                                  

         
         ^
[1m.\utils\llm_memory.py[m[36m:[m4[36m:[m80[36m:[m [1m[31mE501[m line too long (90 > 79 characters)
"""
Module-ID: utils.llm_memory

Purpose: Lightweight memory pour runs LLM - session ephemeral + history JSONL append-only.

Role in pipeline: orchestration / data

Key components: SessionMemory, HistoryStorage, LLMMemoryTracker, approved-only persistence

Inputs: Session id, strategy/symbol/timeframe, propositions + √©valuations

Outputs: Fichiers JSON session (mutable), JSONL history (append-only)

Dependencies: json, pathlib, datetime, collections

Conventions: Session mutable par run; history immuable (approved results); dirs runs/llm_memory/session et history.

Read-if: Modification format fichiers, logique session/history.

Skip-if: Vous utilisez juste LLMMemoryTracker.save().
"""
   
                           

                                              ^
[1m.\utils\llm_memory.py[m[36m:[m8[36m:[m80[36m:[m [1m[31mE501[m line too long (90 > 79 characters)
"""
Module-ID: utils.llm_memory

Purpose: Lightweight memory pour runs LLM - session ephemeral + history JSONL append-only.

Role in pipeline: orchestration / data

Key components: SessionMemory, HistoryStorage, LLMMemoryTracker, approved-only persistence

Inputs: Session id, strategy/symbol/timeframe, propositions + √©valuations

Outputs: Fichiers JSON session (mutable), JSONL history (append-only)

Dependencies: json, pathlib, datetime, collections

Conventions: Session mutable par run; history immuable (approved results); dirs runs/llm_memory/session et history.

Read-if: Modification format fichiers, logique session/history.

Skip-if: Vous utilisez juste LLMMemoryTracker.save().
"""
   
                           

                                              ^
[1m.\utils\llm_memory.py[m[36m:[m16[36m:[m80[36m:[m [1m[31mE501[m line too long (115 > 79 characters)
"""
Module-ID: utils.llm_memory

Purpose: Lightweight memory pour runs LLM - session ephemeral + history JSONL append-only.

Role in pipeline: orchestration / data

Key components: SessionMemory, HistoryStorage, LLMMemoryTracker, approved-only persistence

Inputs: Session id, strategy/symbol/timeframe, propositions + √©valuations

Outputs: Fichiers JSON session (mutable), JSONL history (append-only)

Dependencies: json, pathlib, datetime, collections

Conventions: Session mutable par run; history immuable (approved results); dirs runs/llm_memory/session et history.

Read-if: Modification format fichiers, logique session/history.

Skip-if: Vous utilisez juste LLMMemoryTracker.save().
"""
   
                           

                                              ^
[1m.\utils\llm_memory.py[m[36m:[m59[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
def get_session_path(session_id: str, base_dir: Path = DEFAULT_BASE_DIR) -> Path:
                                                                               ^
[1m.\utils\llm_memory.py[m[36m:[m262[36m:[m80[36m:[m [1m[31mE501[m line too long (88 > 79 characters)
    metrics = entry.get("metrics", {}) if isinstance(entry.get("metrics"), dict) else {}
                                                                               ^
[1m.\utils\llm_memory.py[m[36m:[m281[36m:[m80[36m:[m [1m[31mE501[m line too long (85 > 79 characters)
    params = entry.get("params", {}) if isinstance(entry.get("params"), dict) else {}
                                                                               ^
[1m.\utils\log.py[m[36m:[m63[36m:[m80[36m:[m [1m[31mE501[m line too long (86 > 79 characters)
            record.levelname = f"{levelname_color}{record.levelname}{Style.RESET_ALL}"
                                                                               ^
[1m.\utils\memory.py[m[36m:[m4[36m:[m80[36m:[m [1m[31mE501[m line too long (86 > 79 characters)
"""
Module-ID: utils.memory

Purpose: Gestion m√©moire intelligente (nettoyage auto, cache LRU, thresholds Windows).

Role in pipeline: performance / resilience

Key components: MemoryManager, ManagedCache, memory_pressure, cleanup_callback

Inputs: Thresholds (%, MB), objects √† tracker

Outputs: Notifications pression m√©moire, cache evictions

Dependencies: gc, psutil, threading, weakref, dataclasses

Conventions: Seuils configurables; thread-safe; integration Health Monitor; Windows-optimized.

Read-if: Modification thresholds, logique LRU, ou callbacks cleanup.

Skip-if: Vous utilisez juste MemoryManager.check().
"""
   
                       

                                                  ^
[1m.\utils\memory.py[m[36m:[m16[36m:[m80[36m:[m [1m[31mE501[m line too long (94 > 79 characters)
"""
Module-ID: utils.memory

Purpose: Gestion m√©moire intelligente (nettoyage auto, cache LRU, thresholds Windows).

Role in pipeline: performance / resilience

Key components: MemoryManager, ManagedCache, memory_pressure, cleanup_callback

Inputs: Thresholds (%, MB), objects √† tracker

Outputs: Notifications pression m√©moire, cache evictions

Dependencies: gc, psutil, threading, weakref, dataclasses

Conventions: Seuils configurables; thread-safe; integration Health Monitor; Windows-optimized.

Read-if: Modification thresholds, logique LRU, ou callbacks cleanup.

Skip-if: Vous utilisez juste MemoryManager.check().
"""
   
                       

                                                  ^
[1m.\utils\memory.py[m[36m:[m130[36m:[m80[36m:[m [1m[31mE501[m line too long (95 > 79 characters)
                return obj.memory_usage(deep=True).sum() if hasattr(obj, 'memory_usage') else 0
                                                                               ^
[1m.\utils\memory.py[m[36m:[m163[36m:[m80[36m:[m [1m[31mE501[m line too long (96 > 79 characters)
            logger.warning(f"Objet trop gros pour cache {self.name}: {size / (1024**2):.1f} MB")
                                                                               ^
[1m.\utils\memory.py[m[36m:[m168[36m:[m80[36m:[m [1m[31mE501[m line too long (89 > 79 characters)
            while self._current_size + size > self.max_size_bytes and self._access_order:
                                                                               ^
[1m.\utils\memory.py[m[36m:[m175[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
                    logger.debug(f"Cache {self.name}: √©viction de {oldest_key}")
                                                                               ^
[1m.\utils\memory.py[m[36m:[m301[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
    def create_cache(self, name: str, max_size_mb: float = 512.0) -> ManagedCache:
                                                                               ^
[1m.\utils\memory.py[m[36m:[m356[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
                    logger.debug(f"Cache {name} vid√©: {freed / (1024**2):.1f} MB")
                                                                               ^
[1m.\utils\memory.py[m[36m:[m390[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
        logger.debug(f"Cleanup effectu√©: ~{bytes_freed / (1024**2):.1f} MB lib√©r√©s")
                                                                               ^
[1m.\utils\memory.py[m[36m:[m407[36m:[m80[36m:[m [1m[31mE501[m line too long (94 > 79 characters)
                        logger.warning(f"M√©moire critique ({usage:.1f}%), nettoyage agressif")
                                                                               ^
[1m.\utils\memory.py[m[36m:[m410[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
                        logger.debug(f"M√©moire haute ({usage:.1f}%), nettoyage")
                                                                               ^
[1m.\utils\memory.py[m[36m:[m418[36m:[m80[36m:[m [1m[31mE501[m line too long (86 > 79 characters)
        self._auto_cleanup_thread = threading.Thread(target=cleanup_loop, daemon=True)
                                                                               ^
[1m.\utils\memory.py[m[36m:[m512[36m:[m80[36m:[m [1m[31mE501[m line too long (117 > 79 characters)
            lines.append(f"  {name}: {info['size_mb']:.1f}/{info['max_size_mb']:.0f} MB ({info['entries']} entries)")
                                                                               ^
[1m.\utils\model_loader.py[m[36m:[m16[36m:[m80[36m:[m [1m[31mE501[m line too long (87 > 79 characters)
"""
Module-ID: utils.model_loader

Purpose: Chargement et acc√®s aux mod√®les depuis D:\\models\\models.json

Role in pipeline: configuration

Key components: load_models_json(), get_model_by_id(), get_models_by_category()

Inputs: models.json path (default: D:\\models\\models.json)

Outputs: Dict de mod√®les avec infos (path, size, use_case, etc.)

Dependencies: json, pathlib

Conventions: Fallback si fichier absent; cache en m√©moire; mod√®les Ollama prioritaires.

Read-if: Modification de la logique de chargement des mod√®les.

Skip-if: Vous utilisez directement get_available_models().
"""
   
                             

                                            ^
[1m.\utils\model_loader.py[m[36m:[m103[36m:[m80[36m:[m [1m[31mE501[m line too long (88 > 79 characters)
            "Fichier models.json introuvable √† %s, utilisation de la config par d√©faut",
                                                                               ^
[1m.\utils\model_loader.py[m[36m:[m119[36m:[m80[36m:[m [1m[31mE501[m line too long (101 > 79 characters)
        logger.info("‚úÖ Charg√© %d mod√®les depuis %s", _count_total_models(_models_cache), models_path)
                                                                               ^
[1m.\utils\model_loader.py[m[36m:[m240[36m:[m80[36m:[m [1m[31mE501[m line too long (87 > 79 characters)
    """
    R√©cup√®re tous les mod√®les d'une cat√©gorie.

    Args:
        category: Cat√©gorie (ex: "general", "reasoning", "finance", "image_generation")

    Returns:
        List[Dict]: Liste des mod√®les de cette cat√©gorie

    Example:
        >>> reasoning_models = get_models_by_category("reasoning")
        >>> for m in reasoning_models:
        ...     print(m['name'])
    """
       
                                              

         
             ^
[1m.\utils\model_loader.py[m[36m:[m272[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
    """
    R√©cup√®re tous les mod√®les pour un cas d'usage.

    Args:
        use_case: Cas d'usage (ex: "general", "reasoning", "finance", "instruction")

    Returns:
        List[Dict]: Liste des mod√®les

    Example:
        >>> finance_models = get_models_by_use_case("reasoning_finance")
        >>> for m in finance_models:
        ...     print(f"{m['name']}: {m['description']}")
    """
       
                                                  

         
         ^
[1m.\utils\model_loader.py[m[36m:[m291[36m:[m80[36m:[m [1m[31mE501[m line too long (87 > 79 characters)
    """
    Retourne le mod√®le recommand√© pour une t√¢che.

    Args:
        task: Nom de la t√¢che (ex: "backtest_strategy_generation", "backtest_analysis")

    Returns:
        str: ID du mod√®le recommand√© ou None

    Example:
        >>> model_id = get_recommended_model_for_task("backtest_strategy_generation")
        >>> if model_id:
        ...     model = get_model_by_id(model_id)
        ...     print(f"Recommand√©: {model['name']}")
    """
       
                                                 

         
          ^
[1m.\utils\model_loader.py[m[36m:[m297[36m:[m80[36m:[m [1m[31mE501[m line too long (85 > 79 characters)
    """
    Retourne le mod√®le recommand√© pour une t√¢che.

    Args:
        task: Nom de la t√¢che (ex: "backtest_strategy_generation", "backtest_analysis")

    Returns:
        str: ID du mod√®le recommand√© ou None

    Example:
        >>> model_id = get_recommended_model_for_task("backtest_strategy_generation")
        >>> if model_id:
        ...     model = get_model_by_id(model_id)
        ...     print(f"Recommand√©: {model['name']}")
    """
       
                                                 

         
          ^
[1m.\utils\model_loader.py[m[36m:[m338[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
    """
    Retourne la liste des noms de mod√®les Ollama (pour compatibilit√© avec Ollama).

    Returns:
        List[str]: Liste des noms Ollama (model_name:tag, latest -> model_name)

    Example:
        >>> names = get_ollama_model_names()
        >>> print(names)
        ['llama3.1:8b', 'llama3.3-70b-optimized', 'mistral:7b-instruct', ...]
    """
       
                                                                       ^
[1m.\utils\observability.py[m[36m:[m4[36m:[m80[36m:[m [1m[31mE501[m line too long (87 > 79 characters)
"""
Module-ID: utils.observability

Purpose: Observabilit√© debug intelligent (lazy formatting, traces corr√©l√©es, sampling).

Role in pipeline: core / monitoring

Key components: get_obs_logger, trace_span, PerfCounters, DiagnosticPack, generate_run_id

Inputs: Module name, run_id, log level (env vars)

Outputs: Logs JSON structur√©s, traces span avec timing, pack diagnostique

Dependencies: logging, json, dataclasses, functools

Conventions: DEBUG mode lazy-evaluated; sampling configurable; run_id corr√©l√©; zero overhead prod.

Read-if: Modification logging structure, sampling, ou diagnostic export.

Skip-if: Vous utilisez juste get_obs_logger().
"""
   
                              

                                           ^
[1m.\utils\observability.py[m[36m:[m8[36m:[m80[36m:[m [1m[31mE501[m line too long (89 > 79 characters)
"""
Module-ID: utils.observability

Purpose: Observabilit√© debug intelligent (lazy formatting, traces corr√©l√©es, sampling).

Role in pipeline: core / monitoring

Key components: get_obs_logger, trace_span, PerfCounters, DiagnosticPack, generate_run_id

Inputs: Module name, run_id, log level (env vars)

Outputs: Logs JSON structur√©s, traces span avec timing, pack diagnostique

Dependencies: logging, json, dataclasses, functools

Conventions: DEBUG mode lazy-evaluated; sampling configurable; run_id corr√©l√©; zero overhead prod.

Read-if: Modification logging structure, sampling, ou diagnostic export.

Skip-if: Vous utilisez juste get_obs_logger().
"""
   
                              

                                           ^
[1m.\utils\observability.py[m[36m:[m16[36m:[m80[36m:[m [1m[31mE501[m line too long (98 > 79 characters)
"""
Module-ID: utils.observability

Purpose: Observabilit√© debug intelligent (lazy formatting, traces corr√©l√©es, sampling).

Role in pipeline: core / monitoring

Key components: get_obs_logger, trace_span, PerfCounters, DiagnosticPack, generate_run_id

Inputs: Module name, run_id, log level (env vars)

Outputs: Logs JSON structur√©s, traces span avec timing, pack diagnostique

Dependencies: logging, json, dataclasses, functools

Conventions: DEBUG mode lazy-evaluated; sampling configurable; run_id corr√©l√©; zero overhead prod.

Read-if: Modification logging structure, sampling, ou diagnostic export.

Skip-if: Vous utilisez juste get_obs_logger().
"""
   
                              

                                           ^
[1m.\utils\observability.py[m[36m:[m247[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
    """
    Obtient un logger avec contexte d'observabilit√©.

    Args:
        name: Nom du module (utiliser __name__)
        run_id: Identifiant unique du run (g√©n√©r√© si None)
        **context: Champs additionnels (strategy, symbol, timeframe)

    Returns:
        ObsLoggerAdapter configur√©

    Usage:
        logger = get_obs_logger(__name__, run_id="abc123", strategy="ema_cross")
        logger.info("Pipeline started")  # [abc123] Pipeline started
    """
       
                                                    

         
       ^
[1m.\utils\observability.py[m[36m:[m276[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
    """
    G√©n√®re un run_id unique et lisible pour tra√ßabilit√© compl√®te.

    Format court (si pas de param√®tres): 8 caract√®res UUID
    Format complet: {strategy}_{symbol}_{timeframe}_{timestamp}_{unique}[_s{seed}]

    Args:
        strategy: Nom de la strat√©gie (ex: "ema_cross"). Si None, format court.
        symbol: Actif trad√© (ex: "BTCUSDT")
        timeframe: Timeframe (ex: "1h", "4h", "1d")
        seed: Seed optionnel pour reproductibilit√©

    Returns:
        run_id unique et lisible

    Examples:
        >>> generate_run_id()  # Format court
        'a3f7b2c1'
        >>> generate_run_id("ema_cross", "BTCUSDT", "1h", 42)  # Format complet
        'ema_cross_BTCUSDT_1h_20250228_143052_a3f7b2c1_s42'
    """
       
                                                                 

    ^
[1m.\utils\observability.py[m[36m:[m363[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
        all_fields = {**fields, **span_data, "duration_ms": round(duration_ms, 2)}
                                                                               ^
[1m.\utils\observability.py[m[36m:[m500[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
            "durations_ms": {k: round(v, 2) for k, v in self._durations.items()},
                                                                               ^
[1m.\utils\observability.py[m[36m:[m571[36m:[m80[36m:[m [1m[31mE501[m line too long (89 > 79 characters)
                for k in ["sharpe_ratio", "total_return", "max_drawdown", "total_trades"]
                                                                               ^
[1m.\utils\parameters.py[m[36m:[m4[36m:[m80[36m:[m [1m[31mE501[m line too long (86 > 79 characters)
"""
Module-ID: utils.parameters

Purpose: Gestion granularit√© param√®tres, presets, contraintes (contr√¥le combinatoire).

Role in pipeline: configuration

Key components: ParameterSpec, Preset, ConstraintValidator, SearchSpaceStats, versioned presets

Inputs: Strategy parameter_specs, constraint rules, TOML presets

Outputs: Param grids, SearchSpaceStats, validated presets, versioned snapshots

Dependencies: dataclasses, pathlib, tomllib, typing

Conventions: Granularit√© 0.0=fin‚Üí1.0=grossier; BPS unit√©s; presets source plages optim.

Read-if: Modification presets, contraintes, ou gestion versioning.

Skip-if: Vous appelez juste generate_param_grid() ou list_presets().

TABLE DES MATI√àRES (r√©f√©rence architecture)
==============================================

I.   INFRASTRUCTURE & CONFIGURATION (lignes ~35-250)
     1.1. Imports
     1.2. Logger et constantes
     1.3. Helpers priv√©s de normalisation et conversion
          - _normalize_slug()
          - _to_builtin()
          - _semver_key(), _parse_created_at(), _preset_sort_key()
          - _parse_versioned_id(), _apply_versioned_defaults()
     1.4. Helpers priv√©s de construction
          - _build_fixed_parameter_specs()
          - _compute_param_count() [D√âPLAC√â depuis ancienne ligne 355]
          - _get_repo_root(), _migrate_legacy_presets()

II.  TYPES & STRUCTURES DE DONN√âES (lignes ~250-410)
     2.1. ParameterSpec (dataclass)
     2.2. SearchSpaceStats (dataclass)
     2.3. Preset (dataclass)
     2.4. ParameterConstraint (dataclass)

III. G√âN√âRATION D'ESPACES DE RECHERCHE (lignes ~410-600)
     3.1. parameter_values() - G√©n√©ration de valeurs selon granularit√©
     3.2. calculate_combinations() - Calcul du nombre de combinaisons
     3.3. generate_param_grid() - Grille cart√©sienne de param√®tres
     3.4. compute_search_space_stats() - Statistiques unifi√©es

IV.  SYST√àME DE CONTRAINTES (lignes ~600-850)
     4.1. ConstraintValidator (classe)
     4.2. COMMON_CONSTRAINTS (registre)
     4.3. get_common_constraints()
     4.4. generate_constrained_param_grid()

V.   PRESETS SIMPLES (IN-MEMORY) (lignes ~850-1070)
     5.1. D√©finitions des presets
          - SAFE_RANGES_PRESET
          - MINIMAL_PRESET
          - EMA_CROSS_PRESET
          - MACD_CROSS_PRESET
          - RSI_REVERSAL_PRESET
          - ATR_CHANNEL_PRESET
     5.2. Registre PRESETS
     5.3. Fonctions d'acc√®s
          - get_preset()
          - list_presets()

VI.  PRESETS I/O (DISQUE) (lignes ~1070-1120)
     6.1. save_preset()
     6.2. load_preset()

VII. PRESETS VERSIONN√âS (SYST√àME AVANC√â) (lignes ~1120-1400)
     7.1. Configuration et gestion du r√©pertoire
          - get_versioned_presets_dir()
     7.2. Sauvegarde et chargement
          - save_versioned_preset()
          - load_strategy_version()
     7.3. Listage et r√©solution
          - list_strategy_versions()
          - resolve_latest_version()
     7.4. Validation
          - validate_before_use()

VIII. EXPORTS (lignes ~1400-1450)
     8.1. __all__

---

NOTES IMPORTANTES
=================

SOURCE OF TRUTH pour les valeurs par d√©faut:
--------------------------------------------
Les valeurs par d√©faut (default) sont d√©finies dans les classes de strat√©gies
(strategies/*.py) via la propri√©t√© `parameter_specs`.

Les PRESETS dans ce fichier d√©finissent les PLAGES D'OPTIMISATION (min/max)
et peuvent avoir des defaults DIFF√âRENTS des strat√©gies pour certains cas d'usage
(ex: MINIMAL_PRESET avec granularit√©=1.0 pour tests rapides).

R√®gle: Les strat√©gies sont la source de v√©rit√©. Les presets sont des configurations
d'optimisation qui peuvent d√©river de ces valeurs.

Architecture des responsabilit√©s:
---------------------------------
- Chapitre I-II: Fondations (types, helpers)
- Chapitre III: Moteur de g√©n√©ration d'espaces de recherche
- Chapitre IV: Filtrage et contraintes
- Chapitre V-VI: Presets simples (configs pr√©d√©finies)
- Chapitre VII: Syst√®me avanc√© de versioning (snapshot de r√©sultats)

Concepts cl√©s:
-------------
- Granularit√© 0% = tr√®s fin (beaucoup de valeurs)
- Granularit√© 100% = tr√®s grossier (peu de valeurs, souvent juste la m√©diane)
- Maximum 4 valeurs par param√®tre (r√®gle de plafonnement)
- Contraintes inter-param√®tres (ex: slow > fast)
"""
   
                           

                                              ^
[1m.\utils\parameters.py[m[36m:[m8[36m:[m80[36m:[m [1m[31mE501[m line too long (95 > 79 characters)
"""
Module-ID: utils.parameters

Purpose: Gestion granularit√© param√®tres, presets, contraintes (contr√¥le combinatoire).

Role in pipeline: configuration

Key components: ParameterSpec, Preset, ConstraintValidator, SearchSpaceStats, versioned presets

Inputs: Strategy parameter_specs, constraint rules, TOML presets

Outputs: Param grids, SearchSpaceStats, validated presets, versioned snapshots

Dependencies: dataclasses, pathlib, tomllib, typing

Conventions: Granularit√© 0.0=fin‚Üí1.0=grossier; BPS unit√©s; presets source plages optim.

Read-if: Modification presets, contraintes, ou gestion versioning.

Skip-if: Vous appelez juste generate_param_grid() ou list_presets().

TABLE DES MATI√àRES (r√©f√©rence architecture)
==============================================

I.   INFRASTRUCTURE & CONFIGURATION (lignes ~35-250)
     1.1. Imports
     1.2. Logger et constantes
     1.3. Helpers priv√©s de normalisation et conversion
          - _normalize_slug()
          - _to_builtin()
          - _semver_key(), _parse_created_at(), _preset_sort_key()
          - _parse_versioned_id(), _apply_versioned_defaults()
     1.4. Helpers priv√©s de construction
          - _build_fixed_parameter_specs()
          - _compute_param_count() [D√âPLAC√â depuis ancienne ligne 355]
          - _get_repo_root(), _migrate_legacy_presets()

II.  TYPES & STRUCTURES DE DONN√âES (lignes ~250-410)
     2.1. ParameterSpec (dataclass)
     2.2. SearchSpaceStats (dataclass)
     2.3. Preset (dataclass)
     2.4. ParameterConstraint (dataclass)

III. G√âN√âRATION D'ESPACES DE RECHERCHE (lignes ~410-600)
     3.1. parameter_values() - G√©n√©ration de valeurs selon granularit√©
     3.2. calculate_combinations() - Calcul du nombre de combinaisons
     3.3. generate_param_grid() - Grille cart√©sienne de param√®tres
     3.4. compute_search_space_stats() - Statistiques unifi√©es

IV.  SYST√àME DE CONTRAINTES (lignes ~600-850)
     4.1. ConstraintValidator (classe)
     4.2. COMMON_CONSTRAINTS (registre)
     4.3. get_common_constraints()
     4.4. generate_constrained_param_grid()

V.   PRESETS SIMPLES (IN-MEMORY) (lignes ~850-1070)
     5.1. D√©finitions des presets
          - SAFE_RANGES_PRESET
          - MINIMAL_PRESET
          - EMA_CROSS_PRESET
          - MACD_CROSS_PRESET
          - RSI_REVERSAL_PRESET
          - ATR_CHANNEL_PRESET
     5.2. Registre PRESETS
     5.3. Fonctions d'acc√®s
          - get_preset()
          - list_presets()

VI.  PRESETS I/O (DISQUE) (lignes ~1070-1120)
     6.1. save_preset()
     6.2. load_preset()

VII. PRESETS VERSIONN√âS (SYST√àME AVANC√â) (lignes ~1120-1400)
     7.1. Configuration et gestion du r√©pertoire
          - get_versioned_presets_dir()
     7.2. Sauvegarde et chargement
          - save_versioned_preset()
          - load_strategy_version()
     7.3. Listage et r√©solution
          - list_strategy_versions()
          - resolve_latest_version()
     7.4. Validation
          - validate_before_use()

VIII. EXPORTS (lignes ~1400-1450)
     8.1. __all__

---

NOTES IMPORTANTES
=================

SOURCE OF TRUTH pour les valeurs par d√©faut:
--------------------------------------------
Les valeurs par d√©faut (default) sont d√©finies dans les classes de strat√©gies
(strategies/*.py) via la propri√©t√© `parameter_specs`.

Les PRESETS dans ce fichier d√©finissent les PLAGES D'OPTIMISATION (min/max)
et peuvent avoir des defaults DIFF√âRENTS des strat√©gies pour certains cas d'usage
(ex: MINIMAL_PRESET avec granularit√©=1.0 pour tests rapides).

R√®gle: Les strat√©gies sont la source de v√©rit√©. Les presets sont des configurations
d'optimisation qui peuvent d√©river de ces valeurs.

Architecture des responsabilit√©s:
---------------------------------
- Chapitre I-II: Fondations (types, helpers)
- Chapitre III: Moteur de g√©n√©ration d'espaces de recherche
- Chapitre IV: Filtrage et contraintes
- Chapitre V-VI: Presets simples (configs pr√©d√©finies)
- Chapitre VII: Syst√®me avanc√© de versioning (snapshot de r√©sultats)

Concepts cl√©s:
-------------
- Granularit√© 0% = tr√®s fin (beaucoup de valeurs)
- Granularit√© 100% = tr√®s grossier (peu de valeurs, souvent juste la m√©diane)
- Maximum 4 valeurs par param√®tre (r√®gle de plafonnement)
- Contraintes inter-param√®tres (ex: slow > fast)
"""
   
                           

                                              ^
[1m.\utils\parameters.py[m[36m:[m16[36m:[m80[36m:[m [1m[31mE501[m line too long (87 > 79 characters)
"""
Module-ID: utils.parameters

Purpose: Gestion granularit√© param√®tres, presets, contraintes (contr√¥le combinatoire).

Role in pipeline: configuration

Key components: ParameterSpec, Preset, ConstraintValidator, SearchSpaceStats, versioned presets

Inputs: Strategy parameter_specs, constraint rules, TOML presets

Outputs: Param grids, SearchSpaceStats, validated presets, versioned snapshots

Dependencies: dataclasses, pathlib, tomllib, typing

Conventions: Granularit√© 0.0=fin‚Üí1.0=grossier; BPS unit√©s; presets source plages optim.

Read-if: Modification presets, contraintes, ou gestion versioning.

Skip-if: Vous appelez juste generate_param_grid() ou list_presets().

TABLE DES MATI√àRES (r√©f√©rence architecture)
==============================================

I.   INFRASTRUCTURE & CONFIGURATION (lignes ~35-250)
     1.1. Imports
     1.2. Logger et constantes
     1.3. Helpers priv√©s de normalisation et conversion
          - _normalize_slug()
          - _to_builtin()
          - _semver_key(), _parse_created_at(), _preset_sort_key()
          - _parse_versioned_id(), _apply_versioned_defaults()
     1.4. Helpers priv√©s de construction
          - _build_fixed_parameter_specs()
          - _compute_param_count() [D√âPLAC√â depuis ancienne ligne 355]
          - _get_repo_root(), _migrate_legacy_presets()

II.  TYPES & STRUCTURES DE DONN√âES (lignes ~250-410)
     2.1. ParameterSpec (dataclass)
     2.2. SearchSpaceStats (dataclass)
     2.3. Preset (dataclass)
     2.4. ParameterConstraint (dataclass)

III. G√âN√âRATION D'ESPACES DE RECHERCHE (lignes ~410-600)
     3.1. parameter_values() - G√©n√©ration de valeurs selon granularit√©
     3.2. calculate_combinations() - Calcul du nombre de combinaisons
     3.3. generate_param_grid() - Grille cart√©sienne de param√®tres
     3.4. compute_search_space_stats() - Statistiques unifi√©es

IV.  SYST√àME DE CONTRAINTES (lignes ~600-850)
     4.1. ConstraintValidator (classe)
     4.2. COMMON_CONSTRAINTS (registre)
     4.3. get_common_constraints()
     4.4. generate_constrained_param_grid()

V.   PRESETS SIMPLES (IN-MEMORY) (lignes ~850-1070)
     5.1. D√©finitions des presets
          - SAFE_RANGES_PRESET
          - MINIMAL_PRESET
          - EMA_CROSS_PRESET
          - MACD_CROSS_PRESET
          - RSI_REVERSAL_PRESET
          - ATR_CHANNEL_PRESET
     5.2. Registre PRESETS
     5.3. Fonctions d'acc√®s
          - get_preset()
          - list_presets()

VI.  PRESETS I/O (DISQUE) (lignes ~1070-1120)
     6.1. save_preset()
     6.2. load_preset()

VII. PRESETS VERSIONN√âS (SYST√àME AVANC√â) (lignes ~1120-1400)
     7.1. Configuration et gestion du r√©pertoire
          - get_versioned_presets_dir()
     7.2. Sauvegarde et chargement
          - save_versioned_preset()
          - load_strategy_version()
     7.3. Listage et r√©solution
          - list_strategy_versions()
          - resolve_latest_version()
     7.4. Validation
          - validate_before_use()

VIII. EXPORTS (lignes ~1400-1450)
     8.1. __all__

---

NOTES IMPORTANTES
=================

SOURCE OF TRUTH pour les valeurs par d√©faut:
--------------------------------------------
Les valeurs par d√©faut (default) sont d√©finies dans les classes de strat√©gies
(strategies/*.py) via la propri√©t√© `parameter_specs`.

Les PRESETS dans ce fichier d√©finissent les PLAGES D'OPTIMISATION (min/max)
et peuvent avoir des defaults DIFF√âRENTS des strat√©gies pour certains cas d'usage
(ex: MINIMAL_PRESET avec granularit√©=1.0 pour tests rapides).

R√®gle: Les strat√©gies sont la source de v√©rit√©. Les presets sont des configurations
d'optimisation qui peuvent d√©river de ces valeurs.

Architecture des responsabilit√©s:
---------------------------------
- Chapitre I-II: Fondations (types, helpers)
- Chapitre III: Moteur de g√©n√©ration d'espaces de recherche
- Chapitre IV: Filtrage et contraintes
- Chapitre V-VI: Presets simples (configs pr√©d√©finies)
- Chapitre VII: Syst√®me avanc√© de versioning (snapshot de r√©sultats)

Concepts cl√©s:
-------------
- Granularit√© 0% = tr√®s fin (beaucoup de valeurs)
- Granularit√© 100% = tr√®s grossier (peu de valeurs, souvent juste la m√©diane)
- Maximum 4 valeurs par param√®tre (r√®gle de plafonnement)
- Contraintes inter-param√®tres (ex: slow > fast)
"""
   
                           

                                              ^
[1m.\utils\parameters.py[m[36m:[m99[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
"""
Module-ID: utils.parameters

Purpose: Gestion granularit√© param√®tres, presets, contraintes (contr√¥le combinatoire).

Role in pipeline: configuration

Key components: ParameterSpec, Preset, ConstraintValidator, SearchSpaceStats, versioned presets

Inputs: Strategy parameter_specs, constraint rules, TOML presets

Outputs: Param grids, SearchSpaceStats, validated presets, versioned snapshots

Dependencies: dataclasses, pathlib, tomllib, typing

Conventions: Granularit√© 0.0=fin‚Üí1.0=grossier; BPS unit√©s; presets source plages optim.

Read-if: Modification presets, contraintes, ou gestion versioning.

Skip-if: Vous appelez juste generate_param_grid() ou list_presets().

TABLE DES MATI√àRES (r√©f√©rence architecture)
==============================================

I.   INFRASTRUCTURE & CONFIGURATION (lignes ~35-250)
     1.1. Imports
     1.2. Logger et constantes
     1.3. Helpers priv√©s de normalisation et conversion
          - _normalize_slug()
          - _to_builtin()
          - _semver_key(), _parse_created_at(), _preset_sort_key()
          - _parse_versioned_id(), _apply_versioned_defaults()
     1.4. Helpers priv√©s de construction
          - _build_fixed_parameter_specs()
          - _compute_param_count() [D√âPLAC√â depuis ancienne ligne 355]
          - _get_repo_root(), _migrate_legacy_presets()

II.  TYPES & STRUCTURES DE DONN√âES (lignes ~250-410)
     2.1. ParameterSpec (dataclass)
     2.2. SearchSpaceStats (dataclass)
     2.3. Preset (dataclass)
     2.4. ParameterConstraint (dataclass)

III. G√âN√âRATION D'ESPACES DE RECHERCHE (lignes ~410-600)
     3.1. parameter_values() - G√©n√©ration de valeurs selon granularit√©
     3.2. calculate_combinations() - Calcul du nombre de combinaisons
     3.3. generate_param_grid() - Grille cart√©sienne de param√®tres
     3.4. compute_search_space_stats() - Statistiques unifi√©es

IV.  SYST√àME DE CONTRAINTES (lignes ~600-850)
     4.1. ConstraintValidator (classe)
     4.2. COMMON_CONSTRAINTS (registre)
     4.3. get_common_constraints()
     4.4. generate_constrained_param_grid()

V.   PRESETS SIMPLES (IN-MEMORY) (lignes ~850-1070)
     5.1. D√©finitions des presets
          - SAFE_RANGES_PRESET
          - MINIMAL_PRESET
          - EMA_CROSS_PRESET
          - MACD_CROSS_PRESET
          - RSI_REVERSAL_PRESET
          - ATR_CHANNEL_PRESET
     5.2. Registre PRESETS
     5.3. Fonctions d'acc√®s
          - get_preset()
          - list_presets()

VI.  PRESETS I/O (DISQUE) (lignes ~1070-1120)
     6.1. save_preset()
     6.2. load_preset()

VII. PRESETS VERSIONN√âS (SYST√àME AVANC√â) (lignes ~1120-1400)
     7.1. Configuration et gestion du r√©pertoire
          - get_versioned_presets_dir()
     7.2. Sauvegarde et chargement
          - save_versioned_preset()
          - load_strategy_version()
     7.3. Listage et r√©solution
          - list_strategy_versions()
          - resolve_latest_version()
     7.4. Validation
          - validate_before_use()

VIII. EXPORTS (lignes ~1400-1450)
     8.1. __all__

---

NOTES IMPORTANTES
=================

SOURCE OF TRUTH pour les valeurs par d√©faut:
--------------------------------------------
Les valeurs par d√©faut (default) sont d√©finies dans les classes de strat√©gies
(strategies/*.py) via la propri√©t√© `parameter_specs`.

Les PRESETS dans ce fichier d√©finissent les PLAGES D'OPTIMISATION (min/max)
et peuvent avoir des defaults DIFF√âRENTS des strat√©gies pour certains cas d'usage
(ex: MINIMAL_PRESET avec granularit√©=1.0 pour tests rapides).

R√®gle: Les strat√©gies sont la source de v√©rit√©. Les presets sont des configurations
d'optimisation qui peuvent d√©river de ces valeurs.

Architecture des responsabilit√©s:
---------------------------------
- Chapitre I-II: Fondations (types, helpers)
- Chapitre III: Moteur de g√©n√©ration d'espaces de recherche
- Chapitre IV: Filtrage et contraintes
- Chapitre V-VI: Presets simples (configs pr√©d√©finies)
- Chapitre VII: Syst√®me avanc√© de versioning (snapshot de r√©sultats)

Concepts cl√©s:
-------------
- Granularit√© 0% = tr√®s fin (beaucoup de valeurs)
- Granularit√© 100% = tr√®s grossier (peu de valeurs, souvent juste la m√©diane)
- Maximum 4 valeurs par param√®tre (r√®gle de plafonnement)
- Contraintes inter-param√®tres (ex: slow > fast)
"""
   
                           

                                              ^
[1m.\utils\parameters.py[m[36m:[m102[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
"""
Module-ID: utils.parameters

Purpose: Gestion granularit√© param√®tres, presets, contraintes (contr√¥le combinatoire).

Role in pipeline: configuration

Key components: ParameterSpec, Preset, ConstraintValidator, SearchSpaceStats, versioned presets

Inputs: Strategy parameter_specs, constraint rules, TOML presets

Outputs: Param grids, SearchSpaceStats, validated presets, versioned snapshots

Dependencies: dataclasses, pathlib, tomllib, typing

Conventions: Granularit√© 0.0=fin‚Üí1.0=grossier; BPS unit√©s; presets source plages optim.

Read-if: Modification presets, contraintes, ou gestion versioning.

Skip-if: Vous appelez juste generate_param_grid() ou list_presets().

TABLE DES MATI√àRES (r√©f√©rence architecture)
==============================================

I.   INFRASTRUCTURE & CONFIGURATION (lignes ~35-250)
     1.1. Imports
     1.2. Logger et constantes
     1.3. Helpers priv√©s de normalisation et conversion
          - _normalize_slug()
          - _to_builtin()
          - _semver_key(), _parse_created_at(), _preset_sort_key()
          - _parse_versioned_id(), _apply_versioned_defaults()
     1.4. Helpers priv√©s de construction
          - _build_fixed_parameter_specs()
          - _compute_param_count() [D√âPLAC√â depuis ancienne ligne 355]
          - _get_repo_root(), _migrate_legacy_presets()

II.  TYPES & STRUCTURES DE DONN√âES (lignes ~250-410)
     2.1. ParameterSpec (dataclass)
     2.2. SearchSpaceStats (dataclass)
     2.3. Preset (dataclass)
     2.4. ParameterConstraint (dataclass)

III. G√âN√âRATION D'ESPACES DE RECHERCHE (lignes ~410-600)
     3.1. parameter_values() - G√©n√©ration de valeurs selon granularit√©
     3.2. calculate_combinations() - Calcul du nombre de combinaisons
     3.3. generate_param_grid() - Grille cart√©sienne de param√®tres
     3.4. compute_search_space_stats() - Statistiques unifi√©es

IV.  SYST√àME DE CONTRAINTES (lignes ~600-850)
     4.1. ConstraintValidator (classe)
     4.2. COMMON_CONSTRAINTS (registre)
     4.3. get_common_constraints()
     4.4. generate_constrained_param_grid()

V.   PRESETS SIMPLES (IN-MEMORY) (lignes ~850-1070)
     5.1. D√©finitions des presets
          - SAFE_RANGES_PRESET
          - MINIMAL_PRESET
          - EMA_CROSS_PRESET
          - MACD_CROSS_PRESET
          - RSI_REVERSAL_PRESET
          - ATR_CHANNEL_PRESET
     5.2. Registre PRESETS
     5.3. Fonctions d'acc√®s
          - get_preset()
          - list_presets()

VI.  PRESETS I/O (DISQUE) (lignes ~1070-1120)
     6.1. save_preset()
     6.2. load_preset()

VII. PRESETS VERSIONN√âS (SYST√àME AVANC√â) (lignes ~1120-1400)
     7.1. Configuration et gestion du r√©pertoire
          - get_versioned_presets_dir()
     7.2. Sauvegarde et chargement
          - save_versioned_preset()
          - load_strategy_version()
     7.3. Listage et r√©solution
          - list_strategy_versions()
          - resolve_latest_version()
     7.4. Validation
          - validate_before_use()

VIII. EXPORTS (lignes ~1400-1450)
     8.1. __all__

---

NOTES IMPORTANTES
=================

SOURCE OF TRUTH pour les valeurs par d√©faut:
--------------------------------------------
Les valeurs par d√©faut (default) sont d√©finies dans les classes de strat√©gies
(strategies/*.py) via la propri√©t√© `parameter_specs`.

Les PRESETS dans ce fichier d√©finissent les PLAGES D'OPTIMISATION (min/max)
et peuvent avoir des defaults DIFF√âRENTS des strat√©gies pour certains cas d'usage
(ex: MINIMAL_PRESET avec granularit√©=1.0 pour tests rapides).

R√®gle: Les strat√©gies sont la source de v√©rit√©. Les presets sont des configurations
d'optimisation qui peuvent d√©river de ces valeurs.

Architecture des responsabilit√©s:
---------------------------------
- Chapitre I-II: Fondations (types, helpers)
- Chapitre III: Moteur de g√©n√©ration d'espaces de recherche
- Chapitre IV: Filtrage et contraintes
- Chapitre V-VI: Presets simples (configs pr√©d√©finies)
- Chapitre VII: Syst√®me avanc√© de versioning (snapshot de r√©sultats)

Concepts cl√©s:
-------------
- Granularit√© 0% = tr√®s fin (beaucoup de valeurs)
- Granularit√© 100% = tr√®s grossier (peu de valeurs, souvent juste la m√©diane)
- Maximum 4 valeurs par param√®tre (r√®gle de plafonnement)
- Contraintes inter-param√®tres (ex: slow > fast)
"""
   
                           

                                              ^
[1m.\utils\parameters.py[m[36m:[m164[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
    """Convertit les types numpy en types Python natifs pour s√©rialisation JSON."""
                                                                               ^
[1m.\utils\parameters.py[m[36m:[m203[36m:[m80[36m:[m [1m[31mE501[m line too long (85 > 79 characters)
def _preset_sort_key(preset: "Preset") -> Tuple[Tuple[int, int, int, str], int, str]:
                                                                               ^
[1m.\utils\parameters.py[m[36m:[m345[36m:[m80[36m:[m [1m[31mE501[m line too long (86 > 79 characters)
    """Migre les anciens presets depuis ui/data/presets vers le nouveau r√©pertoire."""
                                                                               ^
[1m.\utils\parameters.py[m[36m:[m774[36m:[m80[36m:[m [1m[31mE501[m line too long (92 > 79 characters)
    # Forme non-lin√©aire pour √©viter une explosion combinatoire avec de nombreux param√®tres.
                                                                               ^
[1m.\utils\parameters.py[m[36m:[m973[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
    """
    Normalise et valide les ranges demand√©es par le LLM pour grid search.

    - Clamp aux bornes des ParameterSpec
    - V√©rifie min <= max, step > 0
    - Rejette cl√©s inconnues
    - Retourne param_grid compatible avec SweepEngine

    Args:
        param_specs: Liste des sp√©cifications de param√®tres (bornes autoris√©es)
        ranges: Ranges demand√©es par le LLM {param: {"min": x, "max": y, "step": z}}

    Returns:
        Dict[str, List[float]]: Grille de param√®tres pr√™te pour SweepEngine

    Raises:
        ValueError: Si ranges invalides (param inconnu, min > max, etc.)

    Example:
        >>> specs = [
        ...     ParameterSpec("bb_period", min_val=10, max_val=50, default=20, step=1),
        ...     ParameterSpec("bb_std", min_val=1.0, max_val=3.0, default=2.0, step=0.1)
        ... ]
        >>> ranges = {
        ...     "bb_period": {"min": 20, "max": 25, "step": 1},
        ...     "bb_std": {"min": 2.0, "max": 2.5, "step": 0.1}
        ... }
        >>> grid = normalize_param_ranges(specs, ranges)
        >>> grid["bb_period"]
        [20, 21, 22, 23, 24, 25]
        >>> grid["bb_std"]
        [2.0, 2.1, 2.2, 2.3, 2.4, 2.5]
    """
       
                                                                       ^
[1m.\utils\parameters.py[m[36m:[m983[36m:[m80[36m:[m [1m[31mE501[m line too long (87 > 79 characters)
    """
    Normalise et valide les ranges demand√©es par le LLM pour grid search.

    - Clamp aux bornes des ParameterSpec
    - V√©rifie min <= max, step > 0
    - Rejette cl√©s inconnues
    - Retourne param_grid compatible avec SweepEngine

    Args:
        param_specs: Liste des sp√©cifications de param√®tres (bornes autoris√©es)
        ranges: Ranges demand√©es par le LLM {param: {"min": x, "max": y, "step": z}}

    Returns:
        Dict[str, List[float]]: Grille de param√®tres pr√™te pour SweepEngine

    Raises:
        ValueError: Si ranges invalides (param inconnu, min > max, etc.)

    Example:
        >>> specs = [
        ...     ParameterSpec("bb_period", min_val=10, max_val=50, default=20, step=1),
        ...     ParameterSpec("bb_std", min_val=1.0, max_val=3.0, default=2.0, step=0.1)
        ... ]
        >>> ranges = {
        ...     "bb_period": {"min": 20, "max": 25, "step": 1},
        ...     "bb_std": {"min": 2.0, "max": 2.5, "step": 0.1}
        ... }
        >>> grid = normalize_param_ranges(specs, ranges)
        >>> grid["bb_period"]
        [20, 21, 22, 23, 24, 25]
        >>> grid["bb_std"]
        [2.0, 2.1, 2.2, 2.3, 2.4, 2.5]
    """
       
                                                                       ^
[1m.\utils\parameters.py[m[36m:[m984[36m:[m80[36m:[m [1m[31mE501[m line too long (88 > 79 characters)
    """
    Normalise et valide les ranges demand√©es par le LLM pour grid search.

    - Clamp aux bornes des ParameterSpec
    - V√©rifie min <= max, step > 0
    - Rejette cl√©s inconnues
    - Retourne param_grid compatible avec SweepEngine

    Args:
        param_specs: Liste des sp√©cifications de param√®tres (bornes autoris√©es)
        ranges: Ranges demand√©es par le LLM {param: {"min": x, "max": y, "step": z}}

    Returns:
        Dict[str, List[float]]: Grille de param√®tres pr√™te pour SweepEngine

    Raises:
        ValueError: Si ranges invalides (param inconnu, min > max, etc.)

    Example:
        >>> specs = [
        ...     ParameterSpec("bb_period", min_val=10, max_val=50, default=20, step=1),
        ...     ParameterSpec("bb_std", min_val=1.0, max_val=3.0, default=2.0, step=0.1)
        ... ]
        >>> ranges = {
        ...     "bb_period": {"min": 20, "max": 25, "step": 1},
        ...     "bb_std": {"min": 2.0, "max": 2.5, "step": 0.1}
        ... }
        >>> grid = normalize_param_ranges(specs, ranges)
        >>> grid["bb_period"]
        [20, 21, 22, 23, 24, 25]
        >>> grid["bb_std"]
        [2.0, 2.1, 2.2, 2.3, 2.4, 2.5]
    """
       
                                                                       ^
[1m.\utils\parameters.py[m[36m:[m1034[36m:[m80[36m:[m [1m[31mE501[m line too long (87 > 79 characters)
                f"Param√®tre '{param_name}': min ({clamped_min}) > max ({clamped_max}) "
                                                                               ^
[1m.\utils\parameters.py[m[36m:[m1040[36m:[m80[36m:[m [1m[31mE501[m line too long (91 > 79 characters)
            step = spec.step if spec.step is not None else (clamped_max - clamped_min) / 10
                                                                               ^
[1m.\utils\parameters.py[m[36m:[m1047[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
        # G√©n√©rer valeurs (m√©thode robuste pour √©viter erreurs de pr√©cision float)
                                                                               ^
[1m.\utils\parameters.py[m[36m:[m1054[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
            # S'assurer de ne pas d√©passer max (avec tol√©rance pour pr√©cision float)
                                                                               ^
[1m.\utils\parameters.py[m[36m:[m1567[36m:[m80[36m:[m [1m[31mE501[m line too long (113 > 79 characters)
    description="Configuration pour strat√©gie Bollinger + filtre ATR. ~128-2000 combinaisons selon granularit√©.",
                                                                               ^
[1m.\utils\preset_validation.py[m[36m:[m4[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
"""
Module-ID: utils.preset_validation

Purpose: Valide/remplit presets (coh√©rence indicateurs et params vs strat√©gies).

Role in pipeline: configuration

Key components: PresetValidationResult, validate_preset(), auto_fill_indicators_from_strategy()

Inputs: Preset dict, strategy name, expected indicators

Outputs: ValidationResult {is_valid, errors[], warnings[], summary()}

Dependencies: dataclasses, typing, log

Conventions: Auto-fill indicateurs depuis mapping; erreurs = breaks validit√©; warnings = info.

Read-if: Modification validation ou preset auto-fill.

Skip-if: Vous appelez juste validate_preset(preset_name).
"""
   
                                  

                                       ^
[1m.\utils\preset_validation.py[m[36m:[m8[36m:[m80[36m:[m [1m[31mE501[m line too long (95 > 79 characters)
"""
Module-ID: utils.preset_validation

Purpose: Valide/remplit presets (coh√©rence indicateurs et params vs strat√©gies).

Role in pipeline: configuration

Key components: PresetValidationResult, validate_preset(), auto_fill_indicators_from_strategy()

Inputs: Preset dict, strategy name, expected indicators

Outputs: ValidationResult {is_valid, errors[], warnings[], summary()}

Dependencies: dataclasses, typing, log

Conventions: Auto-fill indicateurs depuis mapping; erreurs = breaks validit√©; warnings = info.

Read-if: Modification validation ou preset auto-fill.

Skip-if: Vous appelez juste validate_preset(preset_name).
"""
   
                                  

                                       ^
[1m.\utils\preset_validation.py[m[36m:[m16[36m:[m80[36m:[m [1m[31mE501[m line too long (94 > 79 characters)
"""
Module-ID: utils.preset_validation

Purpose: Valide/remplit presets (coh√©rence indicateurs et params vs strat√©gies).

Role in pipeline: configuration

Key components: PresetValidationResult, validate_preset(), auto_fill_indicators_from_strategy()

Inputs: Preset dict, strategy name, expected indicators

Outputs: ValidationResult {is_valid, errors[], warnings[], summary()}

Dependencies: dataclasses, typing, log

Conventions: Auto-fill indicateurs depuis mapping; erreurs = breaks validit√©; warnings = info.

Read-if: Modification validation ou preset auto-fill.

Skip-if: Vous appelez juste validate_preset(preset_name).
"""
   
                                  

                                       ^
[1m.\utils\preset_validation.py[m[36m:[m77[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
        logger.warning(f"Strat√©gie '{strategy_name}' non trouv√©e dans le mapping")
                                                                               ^
[1m.\utils\preset_validation.py[m[36m:[m86[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
    """
    Valide qu'un Preset correspond bien aux indicateurs requis par une strat√©gie.

    Args:
        preset: Instance de Preset √† valider
        strategy_name: Nom de la strat√©gie associ√©e

    Returns:
        PresetValidationResult avec tous les d√©tails
    """
       
                                                                       ^
[1m.\utils\preset_validation.py[m[36m:[m237[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
def format_validation_report(results: Dict[str, PresetValidationResult]) -> str:
                                                                               ^
[1m.\utils\run_tracker.py[m[36m:[m117[36m:[m80[36m:[m [1m[31mE501[m line too long (91 > 79 characters)
        """
        Initialise le tracker.

        Args:
            cache_file: Fichier JSON pour persister les runs (d√©faut: runs/.run_cache.json)
        """
           
                              

             
                     ^
[1m.\utils\run_tracker.py[m[36m:[m135[36m:[m80[36m:[m [1m[31mE501[m line too long (87 > 79 characters)
            self.runs = [RunSignature.from_dict(item) for item in data.get("runs", [])]
                                                                               ^
[1m.\utils\run_tracker.py[m[36m:[m269[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
            strategies[run.strategy_name] = strategies.get(run.strategy_name, 0) + 1
                                                                               ^
[1m.\utils\session_param_tracker.py[m[36m:[m4[36m:[m80[36m:[m [1m[31mE501[m line too long (100 > 79 characters)
"""
Module-ID: utils.session_param_tracker

Purpose: D√©duplie param√®tres test√©s DANS UNE SESSION d'optimisation (vs run_tracker cross-sessions).

Role in pipeline: optimization

Key components: SessionParameterTracker, TestedParams, compute_hash()

Inputs: Dict de param√®tres, scores (Sharpe, return)

Outputs: Hash param, flag already_tested, tested_history

Dependencies: hashlib, json, dataclasses, datetime

Conventions: Normalisation JSON + tri cl√©s pour hash stable; stockage session-local.

Read-if: Modification hachage ou d√©tection doublons intra-session.

Skip-if: Vous appelez tracker.is_already_tested(params).
"""
   
                                      

                                   ^
[1m.\utils\session_param_tracker.py[m[36m:[m16[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
"""
Module-ID: utils.session_param_tracker

Purpose: D√©duplie param√®tres test√©s DANS UNE SESSION d'optimisation (vs run_tracker cross-sessions).

Role in pipeline: optimization

Key components: SessionParameterTracker, TestedParams, compute_hash()

Inputs: Dict de param√®tres, scores (Sharpe, return)

Outputs: Hash param, flag already_tested, tested_history

Dependencies: hashlib, json, dataclasses, datetime

Conventions: Normalisation JSON + tri cl√©s pour hash stable; stockage session-local.

Read-if: Modification hachage ou d√©tection doublons intra-session.

Skip-if: Vous appelez tracker.is_already_tested(params).
"""
   
                                      

                                   ^
[1m.\utils\session_param_tracker.py[m[36m:[m46[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
        normalized = json.dumps(self.params, sort_keys=True, ensure_ascii=False)
                                                                               ^
[1m.\utils\session_param_tracker.py[m[36m:[m84[36m:[m80[36m:[m [1m[31mE501[m line too long (93 > 79 characters)
        self.session_id = session_id or f"session_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
                                                                               ^
[1m.\utils\session_param_tracker.py[m[36m:[m97[36m:[m80[36m:[m [1m[31mE501[m line too long (88 > 79 characters)
        """
        V√©rifie si cette combinaison de param√®tres a d√©j√† √©t√© test√©e DANS CETTE SESSION.

        Args:
            params: Dictionnaire des param√®tres √† v√©rifier

        Returns:
            True si d√©j√† test√©, False sinon
        """
           
                                                                   ^
[1m.\utils\session_param_tracker.py[m[36m:[m142[36m:[m80[36m:[m [1m[31mE501[m line too long (91 > 79 characters)
            logger.warning("Tentative d'enregistrement de param√®tres d√©j√† test√©s (ignor√©)")
                                                                               ^
[1m.\utils\session_param_tracker.py[m[36m:[m149[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
        sharpe_str = f"{sharpe_ratio:.3f}" if sharpe_ratio is not None else "N/A"
                                                                               ^
[1m.\utils\session_param_tracker.py[m[36m:[m151[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
            f"‚úÖ Param√®tres enregistr√©s ({self.total_tests}/{self.total_tests}): "
                                                                               ^
[1m.\utils\session_param_tracker.py[m[36m:[m155[36m:[m80[36m:[m [1m[31mE501[m line too long (86 > 79 characters)
    def get_best_params(self, metric: str = "sharpe_ratio") -> Optional[TestedParams]:
                                                                               ^
[1m.\utils\session_param_tracker.py[m[36m:[m169[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
        valid = [p for p in self.tested_params if getattr(p, metric) is not None]
                                                                               ^
[1m.\utils\session_ranges_tracker.py[m[36m:[m4[36m:[m80[36m:[m [1m[31mE501[m line too long (96 > 79 characters)
"""
Module-ID: utils.session_ranges_tracker

Purpose: Tracker de ranges de grid search test√©es dans une session pour √©viter boucles infinies.

Role in pipeline: optimization

Key components: SessionRangesTracker, TestedRange

Inputs: Dict de ranges (param: {min, max, step})

Outputs: Hash range, flag already_tested, ranges_history

Dependencies: hashlib, json, dataclasses, datetime

Conventions: Normalisation JSON + tri cl√©s pour hash stable; stockage session-local.

Read-if: Modification hachage ou d√©tection doublons ranges.

Skip-if: Vous appelez tracker.was_tested(ranges).
"""
   
                                       

                                  ^
[1m.\utils\session_ranges_tracker.py[m[36m:[m16[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
"""
Module-ID: utils.session_ranges_tracker

Purpose: Tracker de ranges de grid search test√©es dans une session pour √©viter boucles infinies.

Role in pipeline: optimization

Key components: SessionRangesTracker, TestedRange

Inputs: Dict de ranges (param: {min, max, step})

Outputs: Hash range, flag already_tested, ranges_history

Dependencies: hashlib, json, dataclasses, datetime

Conventions: Normalisation JSON + tri cl√©s pour hash stable; stockage session-local.

Read-if: Modification hachage ou d√©tection doublons ranges.

Skip-if: Vous appelez tracker.was_tested(ranges).
"""
   
                                       

                                  ^
[1m.\utils\session_ranges_tracker.py[m[36m:[m38[36m:[m80[36m:[m [1m[31mE501[m line too long (85 > 79 characters)
    ranges: Dict[str, Dict[str, float]]  # {"param": {"min": x, "max": y, "step": z}}
                                                                               ^
[1m.\utils\session_ranges_tracker.py[m[36m:[m47[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
        normalized = json.dumps(self.ranges, sort_keys=True, ensure_ascii=False)
                                                                               ^
[1m.\utils\session_ranges_tracker.py[m[36m:[m90[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
        logger.info(f"üìä Nouvelle session de tracking ranges: {self.session_id}")
                                                                               ^
[1m.\utils\session_ranges_tracker.py[m[36m:[m165[36m:[m80[36m:[m [1m[31mE501[m line too long (103 > 79 characters)
        summary = f"**Ranges d√©j√† test√©es dans cette session ({len(self._tested_ranges)} total):**\n\n"
                                                                               ^
[1m.\utils\session_ranges_tracker.py[m[36m:[m180[36m:[m80[36m:[m [1m[31mE501[m line too long (97 > 79 characters)
            summary += f"\n... et {len(self._tested_ranges) - max_ranges} autres ranges test√©es."
                                                                               ^
[1m.\utils\template.py[m[36m:[m8[36m:[m80[36m:[m [1m[31mE501[m line too long (86 > 79 characters)
"""
Module-ID: utils.template

Purpose: Template Jinja2 centralis√© pour prompts LLM agents.

Role in pipeline: orchestration / LLM

Key components: render_prompt, TemplateLoader, prompt templates (analyst.jinja2, etc.)

Inputs: Template name, context dict (strategy, metrics, proposals)

Outputs: Prompt string format√© pr√™t pour LLM

Dependencies: jinja2, pathlib, logging

Conventions: Templates dans templates/ folder; variables contexte nomm√©es; fallback strings si fichier manquant.

Read-if: Modification templates, variables contexte.

Skip-if: Vous appelez juste render_prompt().
"""
   
                         

                                                ^
[1m.\utils\template.py[m[36m:[m16[36m:[m80[36m:[m [1m[31mE501[m line too long (112 > 79 characters)
"""
Module-ID: utils.template

Purpose: Template Jinja2 centralis√© pour prompts LLM agents.

Role in pipeline: orchestration / LLM

Key components: render_prompt, TemplateLoader, prompt templates (analyst.jinja2, etc.)

Inputs: Template name, context dict (strategy, metrics, proposals)

Outputs: Prompt string format√© pr√™t pour LLM

Dependencies: jinja2, pathlib, logging

Conventions: Templates dans templates/ folder; variables contexte nomm√©es; fallback strings si fichier manquant.

Read-if: Modification templates, variables contexte.

Skip-if: Vous appelez juste render_prompt().
"""
   
                         

                                                ^
[1m.\utils\template.py[m[36m:[m41[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
    # Fallback pour Python < 3.9 ou si backtest_core n'est pas un paquet install√©
                                                                               ^
[1m.\utils\template.py[m[36m:[m47[36m:[m80[36m:[m [1m[31mE501[m line too long (91 > 79 characters)
        TEMPLATES_DIR = (Path(__file__).resolve().parent.parent / "templates").expanduser()
                                                                               ^
[1m.\utils\template.py[m[36m:[m121[36m:[m80[36m:[m [1m[31mE501[m line too long (87 > 79 characters)
        logger.debug(f"Template '{template_name}' rendu avec {len(context)} variables")
                                                                               ^
[1m.\utils\template.py[m[36m:[m132[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
def render_prompt_from_string(template_str: str, context: Dict[str, Any]) -> str:
                                                                               ^
[1m.\utils\version.py[m[36m:[m59[36m:[m80[36m:[m [1m[31mE501[m line too long (89 > 79 characters)
    except (subprocess.CalledProcessError, FileNotFoundError, subprocess.TimeoutExpired):
                                                                               ^
[1m.\utils\version.py[m[36m:[m81[36m:[m80[36m:[m [1m[31mE501[m line too long (89 > 79 characters)
    except (subprocess.CalledProcessError, FileNotFoundError, subprocess.TimeoutExpired):
                                                                               ^
[1m.\utils\version.py[m[36m:[m102[36m:[m80[36m:[m [1m[31mE501[m line too long (89 > 79 characters)
    except (subprocess.CalledProcessError, FileNotFoundError, subprocess.TimeoutExpired):
                                                                               ^
[1m.\utils\visualization.py[m[36m:[m4[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
"""
Module-ID: utils.visualization

Purpose: Visualisation interactive - candlesticks, trades, equity curve, dashboard.

Role in pipeline: UI / reporting

Key components: plot_trades, visualize_results, TradePlotter, Plotly-based

Inputs: DataFrame OHLCV, trades (signaux, entries/exits), metrics

Outputs: Graphiques Plotly interactifs, HTML reports

Dependencies: plotly, pandas, numpy, json

Conventions: Candlesticks OHLCV; marqueurs triangles trades (entr√©e/sortie); equity curve + drawdown; tooltips.

Read-if: Modification graphiques, markers, layout.

Skip-if: Vous n'avez pas besoin visualiser r√©sultats.
"""
   
                              

                                           ^
[1m.\utils\visualization.py[m[36m:[m16[36m:[m80[36m:[m [1m[31mE501[m line too long (111 > 79 characters)
"""
Module-ID: utils.visualization

Purpose: Visualisation interactive - candlesticks, trades, equity curve, dashboard.

Role in pipeline: UI / reporting

Key components: plot_trades, visualize_results, TradePlotter, Plotly-based

Inputs: DataFrame OHLCV, trades (signaux, entries/exits), metrics

Outputs: Graphiques Plotly interactifs, HTML reports

Dependencies: plotly, pandas, numpy, json

Conventions: Candlesticks OHLCV; marqueurs triangles trades (entr√©e/sortie); equity curve + drawdown; tooltips.

Read-if: Modification graphiques, markers, layout.

Skip-if: Vous n'avez pas besoin visualiser r√©sultats.
"""
   
                              

                                           ^
[1m.\utils\visualization.py[m[36m:[m220[36m:[m80[36m:[m [1m[31mE501[m line too long (88 > 79 characters)
                        f"PnL: <b style='color:{'#26a69a' if pnl >= 0 else '#ef5350'}'>"
                                                                               ^
[1m.\utils\visualization.py[m[36m:[m328[36m:[m80[36m:[m [1m[31mE501[m line too long (91 > 79 characters)
            line_color = 'rgba(0, 230, 118, 0.4)' if pnl >= 0 else 'rgba(255, 82, 82, 0.4)'
                                                                               ^
[1m.\utils\visualization.py[m[36m:[m564[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
    html = f"""
    <div style="display: flex; flex-wrap: wrap; gap: 15px; margin: 20px 0;">
        <div style="background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
                    padding: 20px; border-radius: 12px; min-width: 150px;
                    border: 1px solid {pnl_color};">
            <div style="color: #888; font-size: 12px;">PnL</div>
            <div style="color: {pnl_color}; font-size: 28px; font-weight: bold;">
                {pnl:+,.2f}
            </div>
            <div style="color: {pnl_color}; font-size: 14px;">
                {total_return_pct:+.2f}%
            </div>
        </div>

        <div style="background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
                    padding: 20px; border-radius: 12px; min-width: 150px;
                    border: 1px solid #3498db;">
            <div style="color: #888; font-size: 12px;">Sharpe Ratio</div>
            <div style="color: #3498db; font-size: 28px; font-weight: bold;">
                {sharpe:.2f}
            </div>
            <div style="color: #888; font-size: 14px;">
                Sortino: {sortino:.2f}
            </div>
        </div>

        <div style="background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
                    padding: 20px; border-radius: 12px; min-width: 150px;
                    border: 1px solid #ff5252;">
            <div style="color: #888; font-size: 12px;">Max Drawdown</div>
            <div style="color: #ff5252; font-size: 28px; font-weight: bold;">
                {max_dd:.1f}%
            </div>
        </div>

        <div style="background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
                    padding: 20px; border-radius: 12px; min-width: 150px;
                    border: 1px solid #9b59b6;">
            <div style="color: #888; font-size: 12px;">Win Rate</div>
            <div style="color: #9b59b6; font-size: 28px; font-weight: bold;">
                {win_rate:.1f}%
            </div>
            <div style="color: #888; font-size: 14px;">
                {num_trades} trades
            </div>
        </div>

        <div style="background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
                    padding: 20px; border-radius: 12px; min-width: 150px;
                    border: 1px solid #f39c12;">
            <div style="color: #888; font-size: 12px;">Profit Factor</div>
            <div style="color: #f39c12; font-size: 28px; font-weight: bold;">
                {profit_factor:.2f}
            </div>
        </div>
    </div>
    """
               
                                                               ^
[1m.\utils\visualization.py[m[36m:[m568[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
    html = f"""
    <div style="display: flex; flex-wrap: wrap; gap: 15px; margin: 20px 0;">
        <div style="background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
                    padding: 20px; border-radius: 12px; min-width: 150px;
                    border: 1px solid {pnl_color};">
            <div style="color: #888; font-size: 12px;">PnL</div>
            <div style="color: {pnl_color}; font-size: 28px; font-weight: bold;">
                {pnl:+,.2f}
            </div>
            <div style="color: {pnl_color}; font-size: 14px;">
                {total_return_pct:+.2f}%
            </div>
        </div>

        <div style="background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
                    padding: 20px; border-radius: 12px; min-width: 150px;
                    border: 1px solid #3498db;">
            <div style="color: #888; font-size: 12px;">Sharpe Ratio</div>
            <div style="color: #3498db; font-size: 28px; font-weight: bold;">
                {sharpe:.2f}
            </div>
            <div style="color: #888; font-size: 14px;">
                Sortino: {sortino:.2f}
            </div>
        </div>

        <div style="background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
                    padding: 20px; border-radius: 12px; min-width: 150px;
                    border: 1px solid #ff5252;">
            <div style="color: #888; font-size: 12px;">Max Drawdown</div>
            <div style="color: #ff5252; font-size: 28px; font-weight: bold;">
                {max_dd:.1f}%
            </div>
        </div>

        <div style="background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
                    padding: 20px; border-radius: 12px; min-width: 150px;
                    border: 1px solid #9b59b6;">
            <div style="color: #888; font-size: 12px;">Win Rate</div>
            <div style="color: #9b59b6; font-size: 28px; font-weight: bold;">
                {win_rate:.1f}%
            </div>
            <div style="color: #888; font-size: 14px;">
                {num_trades} trades
            </div>
        </div>

        <div style="background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
                    padding: 20px; border-radius: 12px; min-width: 150px;
                    border: 1px solid #f39c12;">
            <div style="color: #888; font-size: 12px;">Profit Factor</div>
            <div style="color: #f39c12; font-size: 28px; font-weight: bold;">
                {profit_factor:.2f}
            </div>
        </div>
    </div>
    """
               
                                                               ^
[1m.\utils\visualization.py[m[36m:[m576[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
    html = f"""
    <div style="display: flex; flex-wrap: wrap; gap: 15px; margin: 20px 0;">
        <div style="background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
                    padding: 20px; border-radius: 12px; min-width: 150px;
                    border: 1px solid {pnl_color};">
            <div style="color: #888; font-size: 12px;">PnL</div>
            <div style="color: {pnl_color}; font-size: 28px; font-weight: bold;">
                {pnl:+,.2f}
            </div>
            <div style="color: {pnl_color}; font-size: 14px;">
                {total_return_pct:+.2f}%
            </div>
        </div>

        <div style="background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
                    padding: 20px; border-radius: 12px; min-width: 150px;
                    border: 1px solid #3498db;">
            <div style="color: #888; font-size: 12px;">Sharpe Ratio</div>
            <div style="color: #3498db; font-size: 28px; font-weight: bold;">
                {sharpe:.2f}
            </div>
            <div style="color: #888; font-size: 14px;">
                Sortino: {sortino:.2f}
            </div>
        </div>

        <div style="background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
                    padding: 20px; border-radius: 12px; min-width: 150px;
                    border: 1px solid #ff5252;">
            <div style="color: #888; font-size: 12px;">Max Drawdown</div>
            <div style="color: #ff5252; font-size: 28px; font-weight: bold;">
                {max_dd:.1f}%
            </div>
        </div>

        <div style="background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
                    padding: 20px; border-radius: 12px; min-width: 150px;
                    border: 1px solid #9b59b6;">
            <div style="color: #888; font-size: 12px;">Win Rate</div>
            <div style="color: #9b59b6; font-size: 28px; font-weight: bold;">
                {win_rate:.1f}%
            </div>
            <div style="color: #888; font-size: 14px;">
                {num_trades} trades
            </div>
        </div>

        <div style="background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
                    padding: 20px; border-radius: 12px; min-width: 150px;
                    border: 1px solid #f39c12;">
            <div style="color: #888; font-size: 12px;">Profit Factor</div>
            <div style="color: #f39c12; font-size: 28px; font-weight: bold;">
                {profit_factor:.2f}
            </div>
        </div>
    </div>
    """
               
                                                               ^
[1m.\utils\visualization.py[m[36m:[m588[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
    html = f"""
    <div style="display: flex; flex-wrap: wrap; gap: 15px; margin: 20px 0;">
        <div style="background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
                    padding: 20px; border-radius: 12px; min-width: 150px;
                    border: 1px solid {pnl_color};">
            <div style="color: #888; font-size: 12px;">PnL</div>
            <div style="color: {pnl_color}; font-size: 28px; font-weight: bold;">
                {pnl:+,.2f}
            </div>
            <div style="color: {pnl_color}; font-size: 14px;">
                {total_return_pct:+.2f}%
            </div>
        </div>

        <div style="background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
                    padding: 20px; border-radius: 12px; min-width: 150px;
                    border: 1px solid #3498db;">
            <div style="color: #888; font-size: 12px;">Sharpe Ratio</div>
            <div style="color: #3498db; font-size: 28px; font-weight: bold;">
                {sharpe:.2f}
            </div>
            <div style="color: #888; font-size: 14px;">
                Sortino: {sortino:.2f}
            </div>
        </div>

        <div style="background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
                    padding: 20px; border-radius: 12px; min-width: 150px;
                    border: 1px solid #ff5252;">
            <div style="color: #888; font-size: 12px;">Max Drawdown</div>
            <div style="color: #ff5252; font-size: 28px; font-weight: bold;">
                {max_dd:.1f}%
            </div>
        </div>

        <div style="background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
                    padding: 20px; border-radius: 12px; min-width: 150px;
                    border: 1px solid #9b59b6;">
            <div style="color: #888; font-size: 12px;">Win Rate</div>
            <div style="color: #9b59b6; font-size: 28px; font-weight: bold;">
                {win_rate:.1f}%
            </div>
            <div style="color: #888; font-size: 14px;">
                {num_trades} trades
            </div>
        </div>

        <div style="background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
                    padding: 20px; border-radius: 12px; min-width: 150px;
                    border: 1px solid #f39c12;">
            <div style="color: #888; font-size: 12px;">Profit Factor</div>
            <div style="color: #f39c12; font-size: 28px; font-weight: bold;">
                {profit_factor:.2f}
            </div>
        </div>
    </div>
    """
               
                                                               ^
[1m.\utils\visualization.py[m[36m:[m597[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
    html = f"""
    <div style="display: flex; flex-wrap: wrap; gap: 15px; margin: 20px 0;">
        <div style="background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
                    padding: 20px; border-radius: 12px; min-width: 150px;
                    border: 1px solid {pnl_color};">
            <div style="color: #888; font-size: 12px;">PnL</div>
            <div style="color: {pnl_color}; font-size: 28px; font-weight: bold;">
                {pnl:+,.2f}
            </div>
            <div style="color: {pnl_color}; font-size: 14px;">
                {total_return_pct:+.2f}%
            </div>
        </div>

        <div style="background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
                    padding: 20px; border-radius: 12px; min-width: 150px;
                    border: 1px solid #3498db;">
            <div style="color: #888; font-size: 12px;">Sharpe Ratio</div>
            <div style="color: #3498db; font-size: 28px; font-weight: bold;">
                {sharpe:.2f}
            </div>
            <div style="color: #888; font-size: 14px;">
                Sortino: {sortino:.2f}
            </div>
        </div>

        <div style="background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
                    padding: 20px; border-radius: 12px; min-width: 150px;
                    border: 1px solid #ff5252;">
            <div style="color: #888; font-size: 12px;">Max Drawdown</div>
            <div style="color: #ff5252; font-size: 28px; font-weight: bold;">
                {max_dd:.1f}%
            </div>
        </div>

        <div style="background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
                    padding: 20px; border-radius: 12px; min-width: 150px;
                    border: 1px solid #9b59b6;">
            <div style="color: #888; font-size: 12px;">Win Rate</div>
            <div style="color: #9b59b6; font-size: 28px; font-weight: bold;">
                {win_rate:.1f}%
            </div>
            <div style="color: #888; font-size: 14px;">
                {num_trades} trades
            </div>
        </div>

        <div style="background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
                    padding: 20px; border-radius: 12px; min-width: 150px;
                    border: 1px solid #f39c12;">
            <div style="color: #888; font-size: 12px;">Profit Factor</div>
            <div style="color: #f39c12; font-size: 28px; font-weight: bold;">
                {profit_factor:.2f}
            </div>
        </div>
    </div>
    """
               
                                                               ^
[1m.\utils\visualization.py[m[36m:[m609[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
    html = f"""
    <div style="display: flex; flex-wrap: wrap; gap: 15px; margin: 20px 0;">
        <div style="background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
                    padding: 20px; border-radius: 12px; min-width: 150px;
                    border: 1px solid {pnl_color};">
            <div style="color: #888; font-size: 12px;">PnL</div>
            <div style="color: {pnl_color}; font-size: 28px; font-weight: bold;">
                {pnl:+,.2f}
            </div>
            <div style="color: {pnl_color}; font-size: 14px;">
                {total_return_pct:+.2f}%
            </div>
        </div>

        <div style="background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
                    padding: 20px; border-radius: 12px; min-width: 150px;
                    border: 1px solid #3498db;">
            <div style="color: #888; font-size: 12px;">Sharpe Ratio</div>
            <div style="color: #3498db; font-size: 28px; font-weight: bold;">
                {sharpe:.2f}
            </div>
            <div style="color: #888; font-size: 14px;">
                Sortino: {sortino:.2f}
            </div>
        </div>

        <div style="background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
                    padding: 20px; border-radius: 12px; min-width: 150px;
                    border: 1px solid #ff5252;">
            <div style="color: #888; font-size: 12px;">Max Drawdown</div>
            <div style="color: #ff5252; font-size: 28px; font-weight: bold;">
                {max_dd:.1f}%
            </div>
        </div>

        <div style="background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
                    padding: 20px; border-radius: 12px; min-width: 150px;
                    border: 1px solid #9b59b6;">
            <div style="color: #888; font-size: 12px;">Win Rate</div>
            <div style="color: #9b59b6; font-size: 28px; font-weight: bold;">
                {win_rate:.1f}%
            </div>
            <div style="color: #888; font-size: 14px;">
                {num_trades} trades
            </div>
        </div>

        <div style="background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
                    padding: 20px; border-radius: 12px; min-width: 150px;
                    border: 1px solid #f39c12;">
            <div style="color: #888; font-size: 12px;">Profit Factor</div>
            <div style="color: #f39c12; font-size: 28px; font-weight: bold;">
                {profit_factor:.2f}
            </div>
        </div>
    </div>
    """
               
                                                               ^
[1m.\utils\visualization.py[m[36m:[m623[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
def create_trades_table(trades: List[Dict[str, Any]], max_rows: int = 50) -> str:
                                                                               ^
[1m.\utils\visualization.py[m[36m:[m684[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
        entry_ts = pd.Timestamp(trade.get('entry_ts')).strftime('%Y-%m-%d %H:%M')
                                                                               ^
[1m.\utils\visualization.py[m[36m:[m815[36m:[m80[36m:[m [1m[31mE501[m line too long (85 > 79 characters)
        html_content = f"""
<!DOCTYPE html>
<html>
<head>
    <title>{title}</title>
    <meta charset="utf-8">
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
    <style>
        body {{
            font-family: 'Segoe UI', Arial, sans-serif;
            background: #0a0a1a;
            color: #fff;
            margin: 0;
            padding: 20px;
        }}
        h1 {{
            color: #fff;
            border-bottom: 2px solid #3498db;
            padding-bottom: 10px;
        }}
        h2 {{
            color: #888;
            margin-top: 30px;
        }}
        .chart-container {{
            background: #1a1a2e;
            border-radius: 12px;
            padding: 15px;
            margin: 20px 0;
        }}
        .timestamp {{
            color: #666;
            font-size: 12px;
            text-align: right;
        }}
    </style>
</head>
<body>
    <h1>üèÜ {title}</h1>
    <p class="timestamp">G√©n√©r√© le {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}</p>

    <h2>üìä Performance</h2>
    {create_performance_cards(metrics)}

    <h2>üìà Graphique des Trades</h2>
    <div class="chart-container" id="chart-trades"></div>

"""
                           
               
      
      
                     ^
[1m.\utils\visualization.py[m[36m:[m839[36m:[m80[36m:[m [1m[31mE501[m line too long (99 > 79 characters)
        html_content += f"""
    <h2>üìã D√©tail des Trades ({len(trades)} trades)</h2>
    {create_trades_table(trades)}

    <script>
        Plotly.newPlot('chart-trades', {fig_trades.to_json()}.data, {fig_trades.to_json()}.layout);
"""
                            
                                                  ^
[1m.\utils\visualization.py[m[36m:[m844[36m:[m80[36m:[m [1m[31mE501[m line too long (99 > 79 characters)
            html_content += f"""
        Plotly.newPlot('chart-equity', {fig_equity.to_json()}.data, {fig_equity.to_json()}.layout);
        Plotly.newPlot('chart-drawdown', {fig_dd.to_json()}.data, {fig_dd.to_json()}.layout);
"""
                                
                                              ^
[1m.\utils\visualization.py[m[36m:[m845[36m:[m80[36m:[m [1m[31mE501[m line too long (93 > 79 characters)
            html_content += f"""
        Plotly.newPlot('chart-equity', {fig_equity.to_json()}.data, {fig_equity.to_json()}.layout);
        Plotly.newPlot('chart-drawdown', {fig_dd.to_json()}.data, {fig_dd.to_json()}.layout);
"""
                                
                                              ^
2     E131 continuation line unaligned for hanging indent
3     E302 expected 2 blank lines, found 1
13    E303 too many blank lines (3)
2     E305 expected 2 blank lines after class or function definition, found 1
27    E402 module level import not at top of file
2479  E501 line too long (92 > 79 characters)
11    F401 '.amplitude_hunter' imported but unused
1     F541 f-string is missing placeholders
5     F821 undefined name 'AgentResult'
