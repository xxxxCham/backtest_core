"""
Module-ID: ui.components.archive.sweep_monitor

Purpose: Composant monitoring sweep temps r√©el Phase 5.2 - progression, meilleurs r√©sultats, m√©triques.

Role in pipeline: visualization (archive)

Key components: SweepMonitor, render_sweep_progress(), render_sweep_summary()

Inputs: Param grid, backtest results en continu

Outputs: UI temps r√©el avec progress bar, top results

Dependencies: streamlit, backtest.sweep

Conventions: Composant optionnel archive

Read-if: Vous voulez monitoring temps r√©el sweep.

Skip-if: Archive - utiliser composants actifs ui/components/
"""

from __future__ import annotations

from dataclasses import dataclass, field
from datetime import datetime, timedelta
from typing import Any, Dict, List, Optional

try:
    import streamlit as st
    STREAMLIT_AVAILABLE = True
except ImportError:
    STREAMLIT_AVAILABLE = False

try:
    import plotly.graph_objects as go
    PLOTLY_AVAILABLE = True
except ImportError:
    PLOTLY_AVAILABLE = False

import numpy as np


@dataclass
class SweepResult:
    """R√©sultat d'une √©valuation de sweep."""
    params: Dict[str, Any]
    metrics: Dict[str, float]
    timestamp: datetime = field(default_factory=lambda: datetime.now())
    duration_ms: float = 0.0

    @property
    def sharpe(self) -> float:
        """Raccourci pour Sharpe Ratio."""
        return self.metrics.get('sharpe_ratio', 0.0)

    @property
    def total_return(self) -> float:
        """Raccourci pour rendement total."""
        return self.metrics.get('total_return', 0.0)


@dataclass
class SweepStats:
    """Statistiques du sweep en cours."""
    total_combinations: int = 0
    evaluated: int = 0
    pruned: int = 0
    errors: int = 0
    start_time: Optional[datetime] = None

    @property
    def progress_percent(self) -> float:
        """Pourcentage de progression."""
        if self.total_combinations == 0:
            return 0.0
        return (self.evaluated / self.total_combinations) * 100

    @property
    def elapsed(self) -> timedelta:
        """Temps √©coul√©."""
        if not self.start_time:
            return timedelta(0)
        return datetime.now() - self.start_time

    @property
    def elapsed_seconds(self) -> float:
        """Temps √©coul√© en secondes."""
        return self.elapsed.total_seconds()

    @property
    def rate(self) -> float:
        """Taux d'√©valuation (eval/sec)."""
        if self.elapsed_seconds == 0:
            return 0.0
        return self.evaluated / self.elapsed_seconds

    @property
    def eta(self) -> Optional[timedelta]:
        """Temps estim√© restant."""
        if self.rate == 0:
            return None
        remaining = self.total_combinations - self.evaluated
        return timedelta(seconds=remaining / self.rate)

    @property
    def eta_str(self) -> str:
        """ETA format√©."""
        eta = self.eta
        if eta is None:
            return "Calcul..."

        total_secs = int(eta.total_seconds())
        if total_secs < 60:
            return f"{total_secs}s"
        elif total_secs < 3600:
            return f"{total_secs // 60}m {total_secs % 60}s"
        else:
            hours = total_secs // 3600
            mins = (total_secs % 3600) // 60
            return f"{hours}h {mins}m"


class SweepMonitor:
    """
    Moniteur de progression pour les optimisations sweep.

    Collecte les r√©sultats et fournit des statistiques en temps r√©el.
    """

    def __init__(
        self,
        total_combinations: int,
        objectives: List[str] = None,
        top_k: int = 10,
    ):
        """
        Args:
            total_combinations: Nombre total de combinaisons √† √©valuer
            objectives: Liste des objectifs √† tracker
            top_k: Nombre de meilleurs r√©sultats √† garder
        """
        self.total = total_combinations
        # Note: Utiliser les cl√©s correctes retourn√©es par calculate_metrics
        self.objectives = objectives or ['sharpe_ratio', 'total_return_pct', 'max_drawdown']
        self.top_k = top_k

        self._results: List[SweepResult] = []
        self._top_results: Dict[str, List[SweepResult]] = {
            obj: [] for obj in self.objectives
        }
        self._stats = SweepStats(total_combinations=total_combinations)
        self._metric_history: Dict[str, List[float]] = {
            obj: [] for obj in self.objectives
        }
        self._last_update = None

    def start(self):
        """D√©marre le monitoring."""
        self._stats.start_time = datetime.now()

    def update(
        self,
        params: Dict[str, Any],
        metrics: Dict[str, float],
        duration_ms: float = 0.0,
        pruned: bool = False,
        error: bool = False,
    ):
        """
        Met √† jour avec un nouveau r√©sultat.

        Args:
            params: Param√®tres √©valu√©s
            metrics: M√©triques r√©sultantes
            duration_ms: Dur√©e de l'√©valuation
            pruned: Si la combinaison a √©t√© prun√©e
            error: Si une erreur s'est produite
        """
        if self._stats.start_time is None:
            self.start()

        if error:
            self._stats.errors += 1
            return

        if pruned:
            self._stats.pruned += 1
            return

        self._stats.evaluated += 1

        result = SweepResult(
            params=params,
            metrics=metrics,
            duration_ms=duration_ms,
        )
        self._results.append(result)

        # Mettre √† jour l'historique des m√©triques
        for obj in self.objectives:
            if obj in metrics:
                self._metric_history[obj].append(metrics[obj])

        # Mettre √† jour les top r√©sultats
        self._update_top_results(result)
        self._last_update = datetime.now()

    def _update_top_results(self, result: SweepResult):
        """Met √† jour les meilleurs r√©sultats."""
        for obj in self.objectives:
            if obj not in result.metrics:
                continue

            top = self._top_results[obj]
            top.append(result)

            # Trier et garder le top_k
            reverse = obj != 'max_drawdown'  # Minimiser le drawdown
            top.sort(key=lambda r: r.metrics.get(obj, 0), reverse=reverse)
            self._top_results[obj] = top[:self.top_k]

    @property
    def stats(self) -> SweepStats:
        """Retourne les statistiques."""
        return self._stats

    @property
    def results(self) -> List[SweepResult]:
        """Retourne tous les r√©sultats."""
        return list(self._results)

    def get_top_results(self, objective: str) -> List[SweepResult]:
        """Retourne les meilleurs r√©sultats pour un objectif."""
        return self._top_results.get(objective, [])

    def get_best_result(self, objective: str) -> Optional[SweepResult]:
        """Retourne le meilleur r√©sultat pour un objectif."""
        top = self.get_top_results(objective)
        return top[0] if top else None

    def get_metric_history(self, objective: str) -> List[float]:
        """Retourne l'historique d'une m√©trique."""
        return self._metric_history.get(objective, [])

    @property
    def is_complete(self) -> bool:
        """Indique si le sweep est termin√©."""
        return self._stats.evaluated >= self.total


def _create_progress_chart(stats: SweepStats) -> go.Figure:
    """Cr√©e un graphique de progression."""
    evaluated = stats.evaluated
    pruned = stats.pruned
    remaining = stats.total_combinations - evaluated - pruned

    fig = go.Figure(data=[go.Pie(
        values=[evaluated, pruned, remaining],
        labels=['√âvalu√©s', 'Prun√©s', 'Restants'],
        marker_colors=['#2ca02c', '#ff7f0e', '#d3d3d3'],
        hole=0.6,
        textinfo='percent',
        textposition='outside',
    )])

    fig.update_layout(
        height=200,
        margin=dict(l=20, r=20, t=20, b=20),
        showlegend=True,
        legend=dict(orientation="h", yanchor="bottom", y=-0.2),
        annotations=[dict(
            text=f"{stats.progress_percent:.0f}%",
            x=0.5, y=0.5,
            font_size=24,
            showarrow=False
        )],
    )

    return fig


def _create_metric_evolution_chart(
    history: Dict[str, List[float]],
    objectives: List[str],
) -> go.Figure:
    """Cr√©e le graphique d'√©volution des m√©triques."""
    fig = go.Figure()

    colors = ['#1f77b4', '#2ca02c', '#ff7f0e', '#d62728']

    for i, obj in enumerate(objectives):
        values = history.get(obj, [])
        if not values:
            continue

        # Calculer la moyenne mobile
        window = min(20, len(values))
        if window > 1:
            moving_avg = np.convolve(values, np.ones(window)/window, mode='valid')
            x_values = list(range(window-1, len(values)))
        else:
            moving_avg = values
            x_values = list(range(len(values)))

        fig.add_trace(go.Scatter(
            x=x_values,
            y=moving_avg,
            name=obj.replace('_', ' ').title(),
            line=dict(color=colors[i % len(colors)], width=2),
        ))

    fig.update_layout(
        height=200,
        margin=dict(l=40, r=20, t=30, b=30),
        legend=dict(orientation="h", yanchor="bottom", y=1.02, xanchor="right", x=1),
        xaxis=dict(title="√âvaluations"),
        yaxis=dict(title="Valeur"),
    )

    return fig


def _create_param_impact_chart(
    results: List[SweepResult],
    objective: str,
    param_name: str,
) -> go.Figure:
    """Cr√©e un graphique d'impact d'un param√®tre."""
    if not results:
        return go.Figure()

    # Extraire les donn√©es
    param_values = []
    metric_values = []

    for r in results:
        if param_name in r.params and objective in r.metrics:
            param_values.append(r.params[param_name])
            metric_values.append(r.metrics[objective])

    if not param_values:
        return go.Figure()

    fig = go.Figure(data=go.Scatter(
        x=param_values,
        y=metric_values,
        mode='markers',
        marker=dict(
            color=metric_values,
            colorscale='Viridis',
            size=8,
            showscale=True,
            colorbar=dict(title=objective),
        ),
    ))

    fig.update_layout(
        height=200,
        margin=dict(l=40, r=20, t=30, b=30),
        xaxis=dict(title=param_name),
        yaxis=dict(title=objective),
    )

    return fig


def render_sweep_progress(
    monitor: SweepMonitor,
    key: str = "sweep_monitor",
    show_top_results: bool = True,
    show_evolution: bool = True,
):
    """
    Render le composant Sweep Monitor dans Streamlit.

    Args:
        monitor: Instance de SweepMonitor
        key: Cl√© unique pour le composant
        show_top_results: Afficher les meilleurs r√©sultats
        show_evolution: Afficher l'√©volution des m√©triques
    """
    if not STREAMLIT_AVAILABLE:
        raise ImportError("Streamlit non disponible")

    stats = monitor.stats

    # Header avec stats principales
    st.subheader("üîÑ Sweep Progress")

    col1, col2, col3, col4 = st.columns(4)

    with col1:
        st.metric(
            "Progression",
            f"{stats.progress_percent:.1f}%",
            f"{stats.evaluated}/{stats.total_combinations}",
        )

    with col2:
        st.metric(
            "Vitesse",
            f"{stats.rate:.1f}/s",
            f"{stats.elapsed_seconds:.0f}s √©coul√©s",
        )

    with col3:
        st.metric("ETA", stats.eta_str)

    with col4:
        st.metric(
            "Prun√©s/Erreurs",
            f"{stats.pruned}",
            f"{stats.errors} erreurs",
        )

    # Barre de progression
    st.progress(stats.progress_percent / 100)

    # Graphiques c√¥te √† c√¥te
    if PLOTLY_AVAILABLE:
        col_left, col_right = st.columns(2)

        with col_left:
            st.markdown("**Distribution**")
            fig = _create_progress_chart(stats)
            st.plotly_chart(fig, width='stretch', key=f"{key}_progress")

        if show_evolution and monitor.get_metric_history(monitor.objectives[0]):
            with col_right:
                st.markdown("**√âvolution des m√©triques**")
                fig = _create_metric_evolution_chart(
                    monitor._metric_history,
                    monitor.objectives,
                )
                st.plotly_chart(fig, width='stretch', key=f"{key}_evolution")

    # Meilleurs r√©sultats
    if show_top_results:
        st.markdown("**üèÜ Meilleurs r√©sultats**")

        tabs = st.tabs([obj.replace('_', ' ').title() for obj in monitor.objectives])

        for i, obj in enumerate(monitor.objectives):
            with tabs[i]:
                top_results = monitor.get_top_results(obj)

                if top_results:
                    # Tableau des r√©sultats
                    data = []
                    for rank, r in enumerate(top_results[:5], 1):
                        row = {
                            "Rank": rank,
                            **{k: f"{v:.4f}" if isinstance(v, float) else v
                               for k, v in r.params.items()},
                            obj: f"{r.metrics.get(obj, 0):.4f}",
                        }
                        data.append(row)

                    st.dataframe(data, width='stretch')
                else:
                    st.info("Pas encore de r√©sultats")


def render_sweep_summary(monitor: SweepMonitor, key: str = "sweep_summary"):
    """
    Render un r√©sum√© final du sweep.

    Args:
        monitor: Instance de SweepMonitor termin√©
        key: Cl√© unique
    """
    if not STREAMLIT_AVAILABLE:
        return

    stats = monitor.stats

    st.success(f"‚úÖ Sweep termin√© - {stats.evaluated} combinaisons √©valu√©es")

    # Stats finales
    col1, col2, col3 = st.columns(3)

    with col1:
        st.metric("Dur√©e totale", f"{stats.elapsed_seconds:.1f}s")

    with col2:
        st.metric("Vitesse moyenne", f"{stats.rate:.2f}/s")

    with col3:
        st.metric("Taux de pruning", f"{(stats.pruned/stats.total_combinations)*100:.1f}%")

    # Meilleurs param√®tres
    st.markdown("### üèÜ Meilleurs param√®tres")

    for obj in monitor.objectives:
        best = monitor.get_best_result(obj)
        if best:
            with st.expander(f"**{obj.replace('_', ' ').title()}**: {best.metrics.get(obj, 0):.4f}"):
                st.json(best.params)


__all__ = [
    "SweepResult",
    "SweepStats",
    "SweepMonitor",
    "render_sweep_progress",
    "render_sweep_summary",
]