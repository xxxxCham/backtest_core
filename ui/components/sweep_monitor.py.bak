"""
Module-ID: ui.components.sweep_monitor

Purpose: Monitor live pour sweeps/optimisation - progress, ETA, top results, ranking.

Role in pipeline: visualization/monitoring

Key components: SweepMonitor, render_sweep_progress(), render_sweep_summary(), SweepStats

Inputs: Sweep updates {completed, total, current_result}

Outputs: Progress bar, ETA estimate, top-N table, live chart updates

Dependencies: streamlit (optionnel), plotly (optionnel), numpy, dataclasses

Conventions: ETA based on rolling avg; refresh 100ms; top-5 constant display.

Read-if: Modification ETA algo ou layout progress.

Skip-if: Vous appelez render_sweep_progress(monitor).
"""

from __future__ import annotations

from collections import deque
from dataclasses import dataclass, field
from datetime import datetime, timedelta
from typing import Any, Dict, List, Optional

try:
    import streamlit as st
    STREAMLIT_AVAILABLE = True
except ImportError:
    STREAMLIT_AVAILABLE = False

try:
    import plotly.graph_objects as go
    PLOTLY_AVAILABLE = True
except ImportError:
    PLOTLY_AVAILABLE = False

import numpy as np
import pandas as pd


def _pnl_per_day(total_pnl: float, period_days: Optional[float]) -> Optional[float]:
    if not period_days:
        return None
    try:
        return float(total_pnl) / float(period_days)
    except Exception:
        return None


@dataclass
class SweepResult:
    """
    Stores the parameters, metrics and timing of a single sweep evaluation.

    Used by `SweepMonitor` to surface the latest runs and compute leaderboards
    without coupling to the backtest engine.
    """
    params: Dict[str, Any]
    metrics: Dict[str, float]
    timestamp: datetime = field(default_factory=lambda: datetime.now())
    duration_ms: float = 0.0

    @property
    def sharpe(self) -> float:
        """Raccourci pour Sharpe Ratio."""
        return self.metrics.get('sharpe_ratio', 0.0)

    @property
    def total_return(self) -> float:
        """Raccourci pour rendement total."""
        return self.metrics.get('total_return', 0.0)


@dataclass
class SweepStats:
    """
    Running statistics for an in-progress sweep.

    Tracks counts, elapsed time and provides ETA/rate helpers so renderers can
    present useful progress indicators.
    """
    total_combinations: int = 0
    evaluated: int = 0
    pruned: int = 0
    errors: int = 0
    start_time: Optional[datetime] = None

    @property
    def progress_percent(self) -> float:
        """Pourcentage de progression."""
        if self.total_combinations == 0:
            return 0.0
        return (self.evaluated / self.total_combinations) * 100

    @property
    def elapsed(self) -> timedelta:
        """Temps √©coul√©."""
        if not self.start_time:
            return timedelta(0)
        return datetime.now() - self.start_time

    @property
    def elapsed_seconds(self) -> float:
        """Temps √©coul√© en secondes."""
        return self.elapsed.total_seconds()

    @property
    def rate(self) -> float:
        """Taux d'√©valuation (eval/sec)."""
        if self.elapsed_seconds == 0:
            return 0.0
        return self.evaluated / self.elapsed_seconds

    @property
    def eta(self) -> Optional[timedelta]:
        """Temps estim√© restant."""
        if self.rate == 0:
            return None
        remaining = self.total_combinations - self.evaluated
        return timedelta(seconds=remaining / self.rate)

    @property
    def eta_str(self) -> str:
        """ETA format√©."""
        eta = self.eta
        if eta is None:
            return "Calcul..."

        total_secs = int(eta.total_seconds())
        if total_secs < 60:
            return f"{total_secs}s"
        elif total_secs < 3600:
            return f"{total_secs // 60}m {total_secs % 60}s"
        else:
            hours = total_secs // 3600
            mins = (total_secs % 3600) // 60
            return f"{hours}h {mins}m"


class SweepMonitor:
    """
    Stateful progress tracker for grid sweeps (optimizations, grid search).

    Lifecycle:
      - Created before a sweep begins with known total combinations.
      - `.update()` is called per evaluation and top results are updated.
      - Handed to `render_sweep_progress`/`render_sweep_summary` for UI render.
    Responsibilities:
      - Record metrics, maintain top-K leaders, and expose ETA/progress.
    """

    def __init__(
        self,
        total_combinations: int,
        objectives: List[str] = None,
        top_k: int = 10,
        max_results: Optional[int] = 100,  # ‚úÖ FIX: Limite par d√©faut pour √©viter OOM
        max_history: Optional[int] = 1000,  # ‚úÖ FIX: Limite par d√©faut pour graphiques
    ):
        """
        Args:
            total_combinations: Nombre total de combinaisons √† √©valuer
            objectives: Liste des objectifs √† tracker
            top_k: Nombre de meilleurs r√©sultats √† garder
            max_results: Limite r√©sultats en m√©moire (d√©faut: 100, 0=illimit√© ‚ö†Ô∏è OOM risk)
            max_history: Limite historique graphiques (d√©faut: 1000, 0=illimit√© ‚ö†Ô∏è OOM risk)
        """
        self.total = total_combinations
        # Note: Utiliser les cl√©s correctes retourn√©es par calculate_metrics
        # Ajout de 'total_pnl' pour tracking visible du meilleur gain
        self.objectives = objectives or ['total_pnl', 'sharpe_ratio', 'total_return_pct', 'max_drawdown']
        self.top_k = top_k
        self.max_results = max_results if max_results != 0 else None  # 0 = illimit√©
        self.max_history = max_history if max_history != 0 else None  # 0 = illimit√©

        # ‚úÖ FIX: Toujours utiliser deque avec maxlen pour √©viter OOM
        self._results: deque = deque(maxlen=self.max_results)
        self._top_results: Dict[str, List[SweepResult]] = {
            obj: [] for obj in self.objectives
        }
        self._stats = SweepStats(total_combinations=total_combinations)
        # ‚úÖ FIX: Toujours deque avec maxlen (1000 par d√©faut)
        self._metric_history = {
            obj: deque(maxlen=self.max_history or 1000) for obj in self.objectives
        }
        self._last_update = None

        # Compteur pour downsampling automatique
        self._update_count = 0

    def start(self):
        """D√©marre le monitoring."""
        self._stats.start_time = datetime.now()

    def update(
        self,
        params: Dict[str, Any],
        metrics: Dict[str, float],
        duration_ms: float = 0.0,
        pruned: bool = False,
        error: bool = False,
    ):
        """
        Met √† jour avec un nouveau r√©sultat.

        Args:
            params: Param√®tres √©valu√©s
            metrics: M√©triques r√©sultantes
            duration_ms: Dur√©e de l'√©valuation
            pruned: Si la combinaison a √©t√© prun√©e
            error: Si une erreur s'est produite
        """
        if self._stats.start_time is None:
            self.start()

        if error:
            self._stats.errors += 1
            self._stats.evaluated += 1
            return

        if pruned:
            self._stats.pruned += 1
            self._stats.evaluated += 1
            return

        self._stats.evaluated += 1
        self._update_count += 1

        result = SweepResult(
            params=params,
            metrics=metrics,
            duration_ms=duration_ms,
        )

        # ‚úÖ FIX: deque g√®re automatiquement la limite (pas besoin de del manuel)
        self._results.append(result)

        # ‚úÖ FIX: Mettre √† jour l'historique (deque auto-limite)
        for obj in self.objectives:
            if obj in metrics:
                self._metric_history[obj].append(metrics[obj])

        # Mettre √† jour les top r√©sultats
        self._update_top_results(result)
        self._last_update = datetime.now()

        # ‚úÖ FIX: Nettoyage m√©moire p√©riodique (tous les 1000 updates)
        if self._update_count % 1000 == 0:
            import gc
            gc.collect()

    def _update_top_results(self, result: SweepResult):
        """Met √† jour les meilleurs r√©sultats."""
        if result.metrics.get("account_ruined"):
            return
        for obj in self.objectives:
            if obj not in result.metrics:
                continue

            top = self._top_results[obj]
            top.append(result)

            # Trier et garder le top_k
            # Minimiser uniquement le drawdown, maximiser tout le reste (PnL, Sharpe, Return)
            reverse = obj not in ['max_drawdown', 'max_drawdown_pct']
            top.sort(key=lambda r: r.metrics.get(obj, 0), reverse=reverse)
            self._top_results[obj] = top[:self.top_k]

    @property
    def stats(self) -> SweepStats:
        """Retourne les statistiques."""
        return self._stats

    @property
    def results(self) -> List[SweepResult]:
        """Retourne tous les r√©sultats."""
        return list(self._results)

    def get_top_results(self, objective: str) -> List[SweepResult]:
        """Retourne les meilleurs r√©sultats pour un objectif."""
        return self._top_results.get(objective, [])

    def get_best_result(self, objective: str) -> Optional[SweepResult]:
        """Retourne le meilleur r√©sultat pour un objectif."""
        top = self.get_top_results(objective)
        return top[0] if top else None

    def get_metric_history(self, objective: str) -> List[float]:
        """Retourne l'historique d'une m√©trique (complet)."""
        history = self._metric_history.get(objective, [])
        return list(history)

    def get_metric_history_downsampled(
        self,
        objective: str,
        max_points: int = 500
    ) -> List[float]:
        """
        Retourne l'historique d'une m√©trique avec downsampling automatique.

        ‚úÖ FIX OOM: Pour sweeps longs (>10k runs), r√©duit automatiquement
        le nombre de points affich√©s sans perdre la tendance visuelle.

        Args:
            objective: M√©trique √† r√©cup√©rer
            max_points: Nombre max de points √† retourner (d√©faut: 500)

        Returns:
            Liste de valeurs (downsampl√©e si n√©cessaire)
        """
        history = list(self._metric_history.get(objective, []))

        if len(history) <= max_points:
            return history

        # Downsampling simple : prendre 1 point tous les N
        step = len(history) // max_points
        if step < 1:
            step = 1

        return history[::step]

    @property
    def is_complete(self) -> bool:
        """Indique si le sweep est termin√©."""
        return self._stats.evaluated >= self.total


def _create_progress_chart(stats: SweepStats) -> go.Figure:
    """Cr√©e un graphique de progression."""
    evaluated = stats.evaluated
    pruned = stats.pruned
    remaining = stats.total_combinations - evaluated - pruned

    fig = go.Figure(data=[go.Pie(
        values=[evaluated, pruned, remaining],
        labels=['√âvalu√©s', 'Prun√©s', 'Restants'],
        marker_colors=['#2ca02c', '#ff7f0e', '#d3d3d3'],
        hole=0.6,
        textinfo='percent',
        textposition='outside',
    )])

    fig.update_layout(
        height=200,
        margin=dict(l=20, r=20, t=20, b=20),
        showlegend=True,
        legend=dict(orientation="h", yanchor="bottom", y=-0.2),
        annotations=[dict(
            text=f"{stats.progress_percent:.0f}%",
            x=0.5, y=0.5,
            font_size=24,
            showarrow=False
        )],
    )

    return fig


def _create_metric_evolution_chart(
    history: Dict[str, List[float]],
    objectives: List[str],
) -> go.Figure:
    """Cr√©e le graphique d'√©volution des m√©triques."""
    fig = go.Figure()

    colors = ['#1f77b4', '#2ca02c', '#ff7f0e', '#d62728']

    for i, obj in enumerate(objectives):
        values = list(history.get(obj, []))
        if not values:
            continue

        # Calculer la moyenne mobile
        window = min(20, len(values))
        if window > 1:
            moving_avg = np.convolve(values, np.ones(window)/window, mode='valid')
            x_values = list(range(window-1, len(values)))
        else:
            moving_avg = values
            x_values = list(range(len(values)))

        fig.add_trace(go.Scatter(
            x=x_values,
            y=moving_avg,
            name=obj.replace('_', ' ').title(),
            line=dict(color=colors[i % len(colors)], width=2),
        ))

    fig.update_layout(
        height=200,
        margin=dict(l=40, r=20, t=30, b=30),
        legend=dict(orientation="h", yanchor="bottom", y=1.02, xanchor="right", x=1),
        xaxis=dict(title="√âvaluations"),
        yaxis=dict(title="Valeur"),
    )

    return fig


def _create_param_impact_chart(
    results: List[SweepResult],
    objective: str,
    param_name: str,
) -> go.Figure:
    """Cr√©e un graphique d'impact d'un param√®tre."""
    if not results:
        return go.Figure()

    # Extraire les donn√©es
    param_values = []
    metric_values = []

    for r in results:
        if param_name in r.params and objective in r.metrics:
            param_values.append(r.params[param_name])
            metric_values.append(r.metrics[objective])

    if not param_values:
        return go.Figure()

    fig = go.Figure(data=go.Scatter(
        x=param_values,
        y=metric_values,
        mode='markers',
        marker=dict(
            color=metric_values,
            colorscale='Viridis',
            size=8,
            showscale=True,
            colorbar=dict(title=objective),
        ),
    ))

    fig.update_layout(
        height=200,
        margin=dict(l=40, r=20, t=30, b=30),
        xaxis=dict(title=param_name),
        yaxis=dict(title=objective),
    )

    return fig


def render_sweep_progress(
    monitor: SweepMonitor,
    key: str = "sweep_monitor",
    show_top_results: bool = True,
    show_evolution: bool = True,
    static_plots: bool = False,
):
    """
    Streamlit panel that renders live sweep progress and leaderboards.

    Called inside the grid search loop to provide real-time feedback,
    including gauges, evolution chart and top results per objective.

    Args:
        monitor: Stateful sweep tracker updated per result.
        key: Unique widget key for rerun safety.
        show_top_results: Toggle the leaderboard section.
        show_evolution: Toggle the metrics evolution chart.
        static_plots: D√©sactiver interactivit√© Plotly (r√©duit WebSocket overhead).
    """
    if not STREAMLIT_AVAILABLE:
        raise ImportError("Streamlit non disponible")

    stats = monitor.stats

    # Header avec stats principales
    st.subheader("üîÑ Sweep Progress")

    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    # üöÄ AFFICHAGE D√âBIT EN TEMPS R√âEL (bt/s) - Style "Gaming"
    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    rate = stats.rate
    if rate > 0:
        # Couleur selon performance (vert > 100/s, jaune 10-100, rouge < 10)
        if rate >= 100:
            rate_color = "#00ff88"  # Vert n√©on
            rate_icon = "üöÄ"
            rate_label = "TURBO"
        elif rate >= 10:
            rate_color = "#ffcc00"  # Jaune
            rate_icon = "‚ö°"
            rate_label = "FAST"
        else:
            rate_color = "#ff6b6b"  # Rouge
            rate_icon = "üê¢"
            rate_label = "SLOW"

        st.markdown(
            f"""<div style='background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            padding: 15px 25px; border-radius: 12px; text-align: center; margin-bottom: 15px;
            border: 2px solid {rate_color}; box-shadow: 0 0 20px {rate_color}40;'>
            <span style='color: #888; font-size: 0.9em; text-transform: uppercase; letter-spacing: 2px;'>
            {rate_label} MODE</span>
            <h2 style='color: {rate_color}; margin: 5px 0; font-size: 2.5em; font-weight: bold;
            text-shadow: 0 0 10px {rate_color};'>
            {rate_icon} {rate:,.1f} bt/s {rate_icon}
            </h2>
            <span style='color: #aaa; font-size: 0.85em;'>
            {stats.evaluated:,} / {stats.total_combinations:,} ({stats.progress_percent:.1f}%) ‚Ä¢ ETA: {stats.eta_str}
            </span>
            </div>""",
            unsafe_allow_html=True
        )

    # Afficher le meilleur PnL et le PnL moyen de mani√®re TR√àS VISIBLE (avec gestion d'erreur robuste)
    try:
        # Calculer le PnL moyen et le meilleur PnL pour √©viter les sommes trompeuses
        cumulative_pnl = 0.0
        pnl_values = []
        period_days_sum = 0.0
        period_days_count = 0

        for result in monitor.results:
            if result.metrics and 'total_pnl' in result.metrics:
                pnl_value = result.metrics.get('total_pnl', 0)
                cumulative_pnl += pnl_value
                pnl_values.append(pnl_value)
                if 'period_days' in result.metrics:
                    period_days_sum += result.metrics.get('period_days', 0)
                    period_days_count += 1

        # Moyenne des period_days pour calcul PnL/jour
        if period_days_count > 0:
            period_days_avg = period_days_sum / period_days_count
        else:
            period_days_avg = None

        if pnl_values:
            avg_pnl = cumulative_pnl / len(pnl_values)
            best_pnl = max(pnl_values)
            worst_pnl = min(pnl_values)  # PnL le plus n√©gatif pour identifier le risque de liquidation
            pnl_color = "#28a745" if best_pnl > 0 else "#dc3545"  # Bootstrap colors
            pnl_icon = "üìà" if best_pnl > 0 else "üìâ"
            # Correction : afficher explicitement le signe n√©gatif
            best_sign = "+" if best_pnl > 0 else ("-" if best_pnl < 0 else "")
            avg_sign = "+" if avg_pnl > 0 else ("-" if avg_pnl < 0 else "")
            worst_sign = "+" if worst_pnl > 0 else ("-" if worst_pnl < 0 else "")
            best_per_day = _pnl_per_day(best_pnl, period_days_avg)
            avg_per_day = _pnl_per_day(avg_pnl, period_days_avg)
            worst_per_day = _pnl_per_day(worst_pnl, period_days_avg)
            if best_per_day is not None:
                best_day_text = f" ({best_sign}${abs(best_per_day):,.2f}/jour)"
            else:
                best_day_text = ""
            if avg_per_day is not None:
                avg_day_text = f" ({avg_sign}${abs(avg_per_day):,.2f}/jour)"
            else:
                avg_day_text = ""
            if worst_per_day is not None:
                worst_day_text = f" ({worst_sign}${abs(worst_per_day):,.2f}/jour)"
            else:
                worst_day_text = ""

            # Indicateur de liquidation si worst PnL est tr√®s n√©gatif
            liquidation_warning = ""
            if worst_pnl < -5000:  # Seuil de warning liquidation
                liquidation_warning = " ‚ö†Ô∏è RISQUE LIQUIDATION"
            elif worst_pnl < 0:
                liquidation_warning = " ‚ö†Ô∏è"

            # PnL cumul√© (somme de tous les PnL)
            cumul_sign = "+" if cumulative_pnl > 0 else ("-" if cumulative_pnl < 0 else "")
            cumul_per_day = _pnl_per_day(cumulative_pnl, period_days_avg)
            if cumul_per_day is not None:
                cumul_day_text = f" ({cumul_sign}${abs(cumul_per_day):,.2f}/jour)"
            else:
                cumul_day_text = ""

            # Calcul distribution profitable/non-profitable
            profitable_count = sum(1 for pnl in pnl_values if pnl > 0)
            losing_count = sum(1 for pnl in pnl_values if pnl < 0)
            breakeven_count = sum(1 for pnl in pnl_values if pnl == 0)
            total_configs = len(pnl_values)
            profitable_pct = (profitable_count / total_configs * 100) if total_configs > 0 else 0

            st.markdown(
                f"""<div style='background: linear-gradient(135deg, {pnl_color} 0%, {pnl_color}dd 100%);
                padding: 20px; border-radius: 10px; text-align: center; margin-bottom: 15px;
                box-shadow: 0 4px 6px rgba(0,0,0,0.1);'>
                <h2 style='color: white; margin: 0; font-size: 1.8em;'>
                {pnl_icon} Meilleure Config: <b>{best_sign}${abs(best_pnl):,.2f}{best_day_text}</b> {pnl_icon}
                </h2>
                <div style='color: #f8f9fa; font-size: 0.95em; margin-top: 4px; opacity: 0.9;'>
                (PnL de la configuration optimale parmi {total_configs:,} test√©es)
                </div>
                <div style='color: #f8f9fa; font-size: 1.05em; margin-top: 12px;'>
                üìä PnL Moyen/Config: <b>{avg_sign}${abs(avg_pnl):,.2f}{avg_day_text}</b>
                </div>
                <div style='color: #f8f9fa; font-size: 0.95em; margin-top: 4px; opacity: 0.9;'>
                ‚úÖ {profitable_count:,} profitables ({profitable_pct:.1f}%) ‚Ä¢ ‚ùå {losing_count:,} pertes ‚Ä¢ ‚öñÔ∏è {breakeven_count:,} neutres
                </div>
                <div style='color: #ffe6e6; font-size: 1.05em; margin-top: 8px;'>
                üìâ Pire Config: <b>{worst_sign}${abs(worst_pnl):,.2f}{worst_day_text}</b>{liquidation_warning}
                </div></div>""",
                unsafe_allow_html=True
            )
    except Exception:
        pass  # Ne pas bloquer l'affichage si erreur

    # M√©triques principales avec style am√©lior√©
    col1, col2, col3, col4, col5 = st.columns(5)

    with col1:
        st.metric(
            "üìä Progression",
            f"{stats.progress_percent:.1f}%",
            f"{stats.evaluated}/{stats.total_combinations}",
        )

    with col2:
        st.metric(
            "‚ö° Vitesse",
            f"{stats.rate:.1f}/s",
            f"{stats.elapsed_seconds:.0f}s √©coul√©s",
        )

    with col3:
        st.metric("‚è±Ô∏è ETA", stats.eta_str)

    with col4:
        st.metric(
            "‚úÇÔ∏è Prun√©s",
            f"{stats.pruned}",
            delta=f"-{stats.pruned}" if stats.pruned > 0 else None,
            delta_color="off"
        )

    with col5:
        st.metric(
            "‚ùå Erreurs",
            f"{stats.errors}",
            delta=f"+{stats.errors}" if stats.errors > 0 else None,
            delta_color="inverse"
        )

    # Barre de progression avec couleur
    progress_color = "#28a745" if stats.progress_percent > 50 else "#ffc107" if stats.progress_percent > 25 else "#dc3545"
    st.markdown(f"""
        <div style='margin: 10px 0;'>
            <div style='background-color: #e9ecef; border-radius: 10px; overflow: hidden; height: 30px;'>
                <div style='background: linear-gradient(90deg, {progress_color} 0%, {progress_color}aa 100%);
                width: {stats.progress_percent}%; height: 100%; display: flex; align-items: center;
                justify-content: center; color: white; font-weight: bold; transition: width 0.3s;'>
                {stats.progress_percent:.1f}%
                </div>
            </div>
        </div>
    """, unsafe_allow_html=True)

    # Graphiques c√¥te √† c√¥te
    if PLOTLY_AVAILABLE:
        # Configuration Plotly : mode statique r√©duit la taille des messages WebSocket
        plotly_config = {
            "staticPlot": static_plots,  # D√©sactiver toute interactivit√© si demand√©
            "displayModeBar": not static_plots,  # Masquer la toolbar en mode statique
            "displaylogo": False,
        } if static_plots else {"displaylogo": False}

        col_left, col_right = st.columns(2)

        with col_left:
            st.markdown("**Distribution**")
            fig = _create_progress_chart(stats)
            st.plotly_chart(
                fig,
                width="stretch",
                key=f"{key}_dist",
                config=plotly_config
            )

        if show_evolution and monitor.get_metric_history(monitor.objectives[0]):
            with col_right:
                st.markdown("**√âvolution des m√©triques**")
                # ‚úÖ FIX OOM: Utiliser downsampling pour gros volumes
                history_downsampled = {
                    obj: monitor.get_metric_history_downsampled(obj, max_points=500)
                    for obj in monitor.objectives
                }
                fig = _create_metric_evolution_chart(
                    history_downsampled,
                    monitor.objectives,
                )
                st.plotly_chart(
                    fig,
                    width="stretch",
                    key=f"{key}_evol",
                    config=plotly_config
                )

    # Meilleurs r√©sultats avec design am√©lior√©
    if show_top_results:
        st.markdown("---")
        st.markdown("### üèÜ Top R√©sultats par M√©trique")

        tabs = st.tabs([f"{obj.replace('_', ' ').title()}" for obj in monitor.objectives])

        for i, obj in enumerate(monitor.objectives):
            with tabs[i]:
                top_results = monitor.get_top_results(obj)

                if top_results:
                    # Tableau des r√©sultats avec formatage am√©lior√©
                    data = []
                    display_results = top_results[:monitor.top_k]
                    for rank, r in enumerate(display_results, 1):
                        # M√©dailles pour le top 3
                        medal = "ü•á" if rank == 1 else "ü•à" if rank == 2 else "ü•â" if rank == 3 else f"#{rank}"

                        row = {"üèÖ": medal}

                        # Ajouter les param√®tres
                        for k, v in r.params.items():
                            if isinstance(v, np.integer):
                                row[k] = int(v)
                            elif isinstance(v, np.floating):
                                row[k] = round(float(v), 3)
                            elif isinstance(v, float):
                                row[k] = round(v, 3)
                            elif isinstance(v, int) and not isinstance(v, bool):
                                row[k] = v
                            else:
                                row[k] = str(v)

                        # Ajouter les m√©triques cl√©s
                        total_pnl = r.metrics.get("total_pnl", 0.0) or 0.0
                        pnl_day = _pnl_per_day(total_pnl, r.metrics.get("period_days"))
                        total_return = r.metrics.get("total_return_pct", 0.0) or 0.0
                        sharpe = r.metrics.get("sharpe_ratio", 0.0) or 0.0
                        max_dd = r.metrics.get("max_drawdown_pct", 0.0) or 0.0
                        row["PnL"] = float(total_pnl)
                        if pnl_day is not None:
                            row["PnL/jour"] = float(pnl_day)
                        row["Return%"] = float(total_return)
                        row["Sharpe"] = float(sharpe)
                        row["MaxDD%"] = abs(float(max_dd))

                        data.append(row)

                    results_df = pd.DataFrame(data)
                    st.dataframe(
                        results_df,
                        width="stretch",
                        hide_index=True,
                        height=min(400, len(results_df) * 35 + 38),  # Hauteur dynamique
                        column_config={
                            "PnL": st.column_config.NumberColumn("PnL", format="$%.0f"),
                            "PnL/jour": st.column_config.NumberColumn("PnL/jour", format="$%.2f"),
                            "Return%": st.column_config.NumberColumn("Return%", format="%.1f%%"),
                            "Sharpe": st.column_config.NumberColumn("Sharpe", format="%.2f"),
                            "MaxDD%": st.column_config.NumberColumn("MaxDD%", format="%.1f%%"),
                        },
                    )
                else:
                    st.info("‚è≥ En attente des premiers r√©sultats...")


def render_sweep_summary(monitor: SweepMonitor, key: str = "sweep_summary"):
    """
    Summary view rendered once the sweep completes.

    Highlights total duration, rate, pruning ratio and best parameter sets per objective.

    Args:
        monitor: SweepMonitor that tracked the recently finished sweep.
        key: Widget key for the summary block.
    """
    if not STREAMLIT_AVAILABLE:
        return

    stats = monitor.stats

    st.success(f"‚úÖ Sweep termin√© - {stats.evaluated} combinaisons √©valu√©es")
    ruined_count = sum(1 for r in monitor.results if r.metrics.get("account_ruined"))
    if ruined_count:
        st.warning(
            f"‚ö†Ô∏è {ruined_count} combinaison(s) ont ruin√© le compte "
            "et sont exclues du classement."
        )

    # Stats finales
    col1, col2, col3 = st.columns(3)

    with col1:
        st.metric("Dur√©e totale", f"{stats.elapsed_seconds:.1f}s")

    with col2:
        st.metric("Vitesse moyenne", f"{stats.rate:.2f}/s")

    with col3:
        st.metric("Taux de pruning", f"{(stats.pruned/stats.total_combinations)*100:.1f}%")

    # Meilleurs param√®tres
    st.markdown("### üèÜ Meilleurs param√®tres")

    any_best_found = False
    for obj in monitor.objectives:
        best = monitor.get_best_result(obj)
        if best:
            any_best_found = True
            with st.expander(f"**{obj.replace('_', ' ').title()}**: {best.metrics.get(obj, 0):.4f}"):
                st.json(best.params)

    if not any_best_found:
        st.warning(
            f"‚ùå Aucun r√©sultat valide trouv√©.\n\n"
            f"**{stats.errors}** erreurs sur **{stats.evaluated}** combinaisons √©valu√©es.\n\n"
            "V√©rifiez les logs ci-dessus pour identifier le probl√®me."
        )


__all__ = [
    "SweepResult",
    "SweepStats",
    "SweepMonitor",
    "render_sweep_progress",
    "render_sweep_summary",
]