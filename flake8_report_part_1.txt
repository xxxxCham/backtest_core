[1m.\agents\__init__.py[m[36m:[m149[36m:[m80[36m:[m [1m[31mE501[m line too long (92 > 79 characters)
from .orchestrator import Orchestrator, OrchestratorConfig, OrchestratorResult  # noqa: E402
                                                                               ^
[1m.\agents\analyst.py[m[36m:[m4[36m:[m80[36m:[m [1m[31mE501[m line too long (100 > 79 characters)
"""
Module-ID: agents.analyst

Purpose: Analyser quantitativement les r√©sultats de backtest et diagnostiquer les forces/faiblesses.

Role in pipeline: orchestration

Key components: AnalystAgent, AnalysisResponse, KeyMetricsAssessment

Inputs: AgentContext (m√©triques, configuration, walk-forward metrics optionnels)

Outputs: AnalysisResponse (JSON Pydantic valid√©) avec √©valuations et ratings

Dependencies: agents.base_agent, utils.template, pydantic, utils.log

Conventions: Ratings en patterns stricts (EXCELLENT/GOOD/FAIR/POOR/CRITICAL); fields non-null; template Jinja2 + parse_json

Read-if: Modification analyse diagnostic, formules de notation, ou structure r√©ponse.

Skip-if: Vous ne changez que propose/critique/validate.
"""
   
                         

                                                ^
[1m.\agents\analyst.py[m[36m:[m10[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
"""
Module-ID: agents.analyst

Purpose: Analyser quantitativement les r√©sultats de backtest et diagnostiquer les forces/faiblesses.

Role in pipeline: orchestration

Key components: AnalystAgent, AnalysisResponse, KeyMetricsAssessment

Inputs: AgentContext (m√©triques, configuration, walk-forward metrics optionnels)

Outputs: AnalysisResponse (JSON Pydantic valid√©) avec √©valuations et ratings

Dependencies: agents.base_agent, utils.template, pydantic, utils.log

Conventions: Ratings en patterns stricts (EXCELLENT/GOOD/FAIR/POOR/CRITICAL); fields non-null; template Jinja2 + parse_json

Read-if: Modification analyse diagnostic, formules de notation, ou structure r√©ponse.

Skip-if: Vous ne changez que propose/critique/validate.
"""
   
                         

                                                ^
[1m.\agents\analyst.py[m[36m:[m16[36m:[m80[36m:[m [1m[31mE501[m line too long (123 > 79 characters)
"""
Module-ID: agents.analyst

Purpose: Analyser quantitativement les r√©sultats de backtest et diagnostiquer les forces/faiblesses.

Role in pipeline: orchestration

Key components: AnalystAgent, AnalysisResponse, KeyMetricsAssessment

Inputs: AgentContext (m√©triques, configuration, walk-forward metrics optionnels)

Outputs: AnalysisResponse (JSON Pydantic valid√©) avec √©valuations et ratings

Dependencies: agents.base_agent, utils.template, pydantic, utils.log

Conventions: Ratings en patterns stricts (EXCELLENT/GOOD/FAIR/POOR/CRITICAL); fields non-null; template Jinja2 + parse_json

Read-if: Modification analyse diagnostic, formules de notation, ou structure r√©ponse.

Skip-if: Vous ne changez que propose/critique/validate.
"""
   
                         

                                                ^
[1m.\agents\analyst.py[m[36m:[m18[36m:[m80[36m:[m [1m[31mE501[m line too long (85 > 79 characters)
"""
Module-ID: agents.analyst

Purpose: Analyser quantitativement les r√©sultats de backtest et diagnostiquer les forces/faiblesses.

Role in pipeline: orchestration

Key components: AnalystAgent, AnalysisResponse, KeyMetricsAssessment

Inputs: AgentContext (m√©triques, configuration, walk-forward metrics optionnels)

Outputs: AnalysisResponse (JSON Pydantic valid√©) avec √©valuations et ratings

Dependencies: agents.base_agent, utils.template, pydantic, utils.log

Conventions: Ratings en patterns stricts (EXCELLENT/GOOD/FAIR/POOR/CRITICAL); fields non-null; template Jinja2 + parse_json

Read-if: Modification analyse diagnostic, formules de notation, ou structure r√©ponse.

Skip-if: Vous ne changez que propose/critique/validate.
"""
   
                         

                                                ^
[1m.\agents\analyst.py[m[36m:[m67[36m:[m80[36m:[m [1m[31mE501[m line too long (89 > 79 characters)
    performance_rating: str = Field(..., pattern="^(EXCELLENT|GOOD|FAIR|POOR|CRITICAL)$")
                                                                               ^
[1m.\agents\analyst.py[m[36m:[m69[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
    overfitting_risk: str = Field(..., pattern="^(LOW|MODERATE|HIGH|CRITICAL)$")
                                                                               ^
[1m.\agents\analyst.py[m[36m:[m78[36m:[m80[36m:[m [1m[31mE501[m line too long (92 > 79 characters)
    @field_validator('strengths', 'weaknesses', 'concerns', 'recommendations', mode='after')
                                                                               ^
[1m.\agents\analyst.py[m[36m:[m85[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
                    raise ValueError("Les items de liste ne doivent pas √™tre vides")
                                                                               ^
[1m.\agents\analyst.py[m[36m:[m86[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
            return [item.strip() if isinstance(item, str) else item for item in v]
                                                                               ^
[1m.\agents\analyst.py[m[36m:[m108[36m:[m80[36m:[m [1m[31mE501[m line too long (112 > 79 characters)
        return """You are a senior quantitative analyst specializing in algorithmic trading strategy evaluation.

Your expertise includes:
- Statistical analysis of trading performance metrics
- Risk assessment and drawdown analysis
- Detection of overfitting and curve-fitting issues
- Identification of market regime dependencies
- Recognition of strategy strengths and weaknesses

Your analysis must be:
- Data-driven and objective
- Structured and clear
- Actionable with specific recommendations
- Honest about limitations and risks

When analyzing, always consider:
1. Is the sample size (number of trades) sufficient for statistical significance?
2. Are the results consistent across train/test splits (walk-forward)?
3. Is the strategy robust or likely overfit to historical data?
4. What are the main risk factors?

Respond ONLY in valid JSON format with this exact structure:
{
    "summary": "Brief one-paragraph analysis summary",
    "performance_rating": "EXCELLENT|GOOD|FAIR|POOR|CRITICAL",
    "risk_rating": "LOW|MODERATE|HIGH|EXTREME",
    "overfitting_risk": "LOW|MODERATE|HIGH|CRITICAL",
    "strengths": ["strength1", "strength2", ...],
    "weaknesses": ["weakness1", "weakness2", ...],
    "concerns": ["concern1", "concern2", ...],
    "key_metrics_assessment": {
        "sharpe_ratio": {"value": X, "assessment": "..."},
        "max_drawdown": {"value": X, "assessment": "..."},
        "win_rate": {"value": X, "assessment": "..."},
        "profit_factor": {"value": X, "assessment": "..."}
    },
    "recommendations": ["recommendation1", "recommendation2", ...],
    "proceed_to_optimization": true/false,
    "reasoning": "Why proceed or not proceed"
}"""
                                                                               ^
[1m.\agents\analyst.py[m[36m:[m124[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
        return """You are a senior quantitative analyst specializing in algorithmic trading strategy evaluation.

Your expertise includes:
- Statistical analysis of trading performance metrics
- Risk assessment and drawdown analysis
- Detection of overfitting and curve-fitting issues
- Identification of market regime dependencies
- Recognition of strategy strengths and weaknesses

Your analysis must be:
- Data-driven and objective
- Structured and clear
- Actionable with specific recommendations
- Honest about limitations and risks

When analyzing, always consider:
1. Is the sample size (number of trades) sufficient for statistical significance?
2. Are the results consistent across train/test splits (walk-forward)?
3. Is the strategy robust or likely overfit to historical data?
4. What are the main risk factors?

Respond ONLY in valid JSON format with this exact structure:
{
    "summary": "Brief one-paragraph analysis summary",
    "performance_rating": "EXCELLENT|GOOD|FAIR|POOR|CRITICAL",
    "risk_rating": "LOW|MODERATE|HIGH|EXTREME",
    "overfitting_risk": "LOW|MODERATE|HIGH|CRITICAL",
    "strengths": ["strength1", "strength2", ...],
    "weaknesses": ["weakness1", "weakness2", ...],
    "concerns": ["concern1", "concern2", ...],
    "key_metrics_assessment": {
        "sharpe_ratio": {"value": X, "assessment": "..."},
        "max_drawdown": {"value": X, "assessment": "..."},
        "win_rate": {"value": X, "assessment": "..."},
        "profit_factor": {"value": X, "assessment": "..."}
    },
    "recommendations": ["recommendation1", "recommendation2", ...],
    "proceed_to_optimization": true/false,
    "reasoning": "Why proceed or not proceed"
}"""
                                                                               ^
[1m.\agents\analyst.py[m[36m:[m225[36m:[m80[36m:[m [1m[31mE501[m line too long (90 > 79 characters)
                "proceed_to_optimization": analysis.get("proceed_to_optimization", False),
                                                                               ^
[1m.\agents\analyst.py[m[36m:[m315[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
            logger.warning(f"Validation Pydantic √©chou√©e: {len(errors)} erreur(s)")
                                                                               ^
[1m.\agents\autonomous_strategist.py[m[36m:[m4[36m:[m80[36m:[m [1m[31mE501[m line too long (92 > 79 characters)
"""
Module-ID: agents.autonomous_strategist

Purpose: Optimiseur autonome pilot√© par LLM qui it√®re propose ‚Üí backtest ‚Üí analyse ‚Üí d√©cide.

Role in pipeline: orchestration

Key components: AutonomousStrategist, OptimizationSession, IterationDecision, create_autonomous_optimizer

Inputs: LLMClient/LLMConfig, BacktestExecutor/backtest_fn, DataFrame OHLCV, initial_params/param_bounds

Outputs: OptimizationSession (best_result/all_results/decisions), historique de BacktestResult

Dependencies: agents.backtest_executor, agents.base_agent, agents.llm_client, agents.ollama_manager, utils.parameters

Conventions: target_metric="sharpe_ratio"; max_time_seconds en secondes; stop si next_parameters vide; LLM d√©charg√© GPU durant backtests.

Read-if: Vous modifiez/debuggez la boucle d'optimisation autonome ou son int√©gration d'ex√©cution.

Skip-if: Vous utilisez uniquement le mode orchestr√© sans ex√©cution de backtests.
"""
   
                                       

                                  ^
[1m.\agents\autonomous_strategist.py[m[36m:[m8[36m:[m80[36m:[m [1m[31mE501[m line too long (105 > 79 characters)
"""
Module-ID: agents.autonomous_strategist

Purpose: Optimiseur autonome pilot√© par LLM qui it√®re propose ‚Üí backtest ‚Üí analyse ‚Üí d√©cide.

Role in pipeline: orchestration

Key components: AutonomousStrategist, OptimizationSession, IterationDecision, create_autonomous_optimizer

Inputs: LLMClient/LLMConfig, BacktestExecutor/backtest_fn, DataFrame OHLCV, initial_params/param_bounds

Outputs: OptimizationSession (best_result/all_results/decisions), historique de BacktestResult

Dependencies: agents.backtest_executor, agents.base_agent, agents.llm_client, agents.ollama_manager, utils.parameters

Conventions: target_metric="sharpe_ratio"; max_time_seconds en secondes; stop si next_parameters vide; LLM d√©charg√© GPU durant backtests.

Read-if: Vous modifiez/debuggez la boucle d'optimisation autonome ou son int√©gration d'ex√©cution.

Skip-if: Vous utilisez uniquement le mode orchestr√© sans ex√©cution de backtests.
"""
   
                                       

                                  ^
[1m.\agents\autonomous_strategist.py[m[36m:[m10[36m:[m80[36m:[m [1m[31mE501[m line too long (103 > 79 characters)
"""
Module-ID: agents.autonomous_strategist

Purpose: Optimiseur autonome pilot√© par LLM qui it√®re propose ‚Üí backtest ‚Üí analyse ‚Üí d√©cide.

Role in pipeline: orchestration

Key components: AutonomousStrategist, OptimizationSession, IterationDecision, create_autonomous_optimizer

Inputs: LLMClient/LLMConfig, BacktestExecutor/backtest_fn, DataFrame OHLCV, initial_params/param_bounds

Outputs: OptimizationSession (best_result/all_results/decisions), historique de BacktestResult

Dependencies: agents.backtest_executor, agents.base_agent, agents.llm_client, agents.ollama_manager, utils.parameters

Conventions: target_metric="sharpe_ratio"; max_time_seconds en secondes; stop si next_parameters vide; LLM d√©charg√© GPU durant backtests.

Read-if: Vous modifiez/debuggez la boucle d'optimisation autonome ou son int√©gration d'ex√©cution.

Skip-if: Vous utilisez uniquement le mode orchestr√© sans ex√©cution de backtests.
"""
   
                                       

                                  ^
[1m.\agents\autonomous_strategist.py[m[36m:[m12[36m:[m80[36m:[m [1m[31mE501[m line too long (94 > 79 characters)
"""
Module-ID: agents.autonomous_strategist

Purpose: Optimiseur autonome pilot√© par LLM qui it√®re propose ‚Üí backtest ‚Üí analyse ‚Üí d√©cide.

Role in pipeline: orchestration

Key components: AutonomousStrategist, OptimizationSession, IterationDecision, create_autonomous_optimizer

Inputs: LLMClient/LLMConfig, BacktestExecutor/backtest_fn, DataFrame OHLCV, initial_params/param_bounds

Outputs: OptimizationSession (best_result/all_results/decisions), historique de BacktestResult

Dependencies: agents.backtest_executor, agents.base_agent, agents.llm_client, agents.ollama_manager, utils.parameters

Conventions: target_metric="sharpe_ratio"; max_time_seconds en secondes; stop si next_parameters vide; LLM d√©charg√© GPU durant backtests.

Read-if: Vous modifiez/debuggez la boucle d'optimisation autonome ou son int√©gration d'ex√©cution.

Skip-if: Vous utilisez uniquement le mode orchestr√© sans ex√©cution de backtests.
"""
   
                                       

                                  ^
[1m.\agents\autonomous_strategist.py[m[36m:[m14[36m:[m80[36m:[m [1m[31mE501[m line too long (117 > 79 characters)
"""
Module-ID: agents.autonomous_strategist

Purpose: Optimiseur autonome pilot√© par LLM qui it√®re propose ‚Üí backtest ‚Üí analyse ‚Üí d√©cide.

Role in pipeline: orchestration

Key components: AutonomousStrategist, OptimizationSession, IterationDecision, create_autonomous_optimizer

Inputs: LLMClient/LLMConfig, BacktestExecutor/backtest_fn, DataFrame OHLCV, initial_params/param_bounds

Outputs: OptimizationSession (best_result/all_results/decisions), historique de BacktestResult

Dependencies: agents.backtest_executor, agents.base_agent, agents.llm_client, agents.ollama_manager, utils.parameters

Conventions: target_metric="sharpe_ratio"; max_time_seconds en secondes; stop si next_parameters vide; LLM d√©charg√© GPU durant backtests.

Read-if: Vous modifiez/debuggez la boucle d'optimisation autonome ou son int√©gration d'ex√©cution.

Skip-if: Vous utilisez uniquement le mode orchestr√© sans ex√©cution de backtests.
"""
   
                                       

                                  ^
[1m.\agents\autonomous_strategist.py[m[36m:[m16[36m:[m80[36m:[m [1m[31mE501[m line too long (137 > 79 characters)
"""
Module-ID: agents.autonomous_strategist

Purpose: Optimiseur autonome pilot√© par LLM qui it√®re propose ‚Üí backtest ‚Üí analyse ‚Üí d√©cide.

Role in pipeline: orchestration

Key components: AutonomousStrategist, OptimizationSession, IterationDecision, create_autonomous_optimizer

Inputs: LLMClient/LLMConfig, BacktestExecutor/backtest_fn, DataFrame OHLCV, initial_params/param_bounds

Outputs: OptimizationSession (best_result/all_results/decisions), historique de BacktestResult

Dependencies: agents.backtest_executor, agents.base_agent, agents.llm_client, agents.ollama_manager, utils.parameters

Conventions: target_metric="sharpe_ratio"; max_time_seconds en secondes; stop si next_parameters vide; LLM d√©charg√© GPU durant backtests.

Read-if: Vous modifiez/debuggez la boucle d'optimisation autonome ou son int√©gration d'ex√©cution.

Skip-if: Vous utilisez uniquement le mode orchestr√© sans ex√©cution de backtests.
"""
   
                                       

                                  ^
[1m.\agents\autonomous_strategist.py[m[36m:[m18[36m:[m80[36m:[m [1m[31mE501[m line too long (97 > 79 characters)
"""
Module-ID: agents.autonomous_strategist

Purpose: Optimiseur autonome pilot√© par LLM qui it√®re propose ‚Üí backtest ‚Üí analyse ‚Üí d√©cide.

Role in pipeline: orchestration

Key components: AutonomousStrategist, OptimizationSession, IterationDecision, create_autonomous_optimizer

Inputs: LLMClient/LLMConfig, BacktestExecutor/backtest_fn, DataFrame OHLCV, initial_params/param_bounds

Outputs: OptimizationSession (best_result/all_results/decisions), historique de BacktestResult

Dependencies: agents.backtest_executor, agents.base_agent, agents.llm_client, agents.ollama_manager, utils.parameters

Conventions: target_metric="sharpe_ratio"; max_time_seconds en secondes; stop si next_parameters vide; LLM d√©charg√© GPU durant backtests.

Read-if: Vous modifiez/debuggez la boucle d'optimisation autonome ou son int√©gration d'ex√©cution.

Skip-if: Vous utilisez uniquement le mode orchestr√© sans ex√©cution de backtests.
"""
   
                                       

                                  ^
[1m.\agents\autonomous_strategist.py[m[36m:[m20[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
"""
Module-ID: agents.autonomous_strategist

Purpose: Optimiseur autonome pilot√© par LLM qui it√®re propose ‚Üí backtest ‚Üí analyse ‚Üí d√©cide.

Role in pipeline: orchestration

Key components: AutonomousStrategist, OptimizationSession, IterationDecision, create_autonomous_optimizer

Inputs: LLMClient/LLMConfig, BacktestExecutor/backtest_fn, DataFrame OHLCV, initial_params/param_bounds

Outputs: OptimizationSession (best_result/all_results/decisions), historique de BacktestResult

Dependencies: agents.backtest_executor, agents.base_agent, agents.llm_client, agents.ollama_manager, utils.parameters

Conventions: target_metric="sharpe_ratio"; max_time_seconds en secondes; stop si next_parameters vide; LLM d√©charg√© GPU durant backtests.

Read-if: Vous modifiez/debuggez la boucle d'optimisation autonome ou son int√©gration d'ex√©cution.

Skip-if: Vous utilisez uniquement le mode orchestr√© sans ex√©cution de backtests.
"""
   
                                       

                                  ^
[1m.\agents\autonomous_strategist.py[m[36m:[m37[36m:[m80[36m:[m [1m[31mE501[m line too long (85 > 79 characters)
from utils.parameters import ParameterSpec, RangeProposal, compute_search_space_stats
                                                                               ^
[1m.\agents\autonomous_strategist.py[m[36m:[m102[36m:[m80[36m:[m [1m[31mE501[m line too long (86 > 79 characters)
    final_status: str = ""  # "success", "max_iterations", "timeout", "no_improvement"
                                                                               ^
[1m.\agents\autonomous_strategist.py[m[36m:[m140[36m:[m80[36m:[m [1m[31mE501[m line too long (92 > 79 characters)
        is_int = all(isinstance(bound_spec[i], int) for i in range(min(2, len(bound_spec))))
                                                                               ^
[1m.\agents\autonomous_strategist.py[m[36m:[m189[36m:[m80[36m:[m [1m[31mE501[m line too long (101 > 79 characters)
        return """You are an autonomous trading strategy optimizer with the ability to run backtests.

Your process:
1. ANALYZE current results and history
2. FORMULATE a hypothesis about what might improve performance
3. PROPOSE specific parameters to test OR request a grid search over ranges
4. After seeing results, DECIDE whether to continue, accept, or change direction

Key principles:
- Each experiment should test ONE clear hypothesis
- Learn from failures - don't repeat similar mistakes
- Balance exploration (trying new things) vs exploitation (refining what works)
- Watch for overfitting - prefer robust solutions over peak performance
- Consider parameter interactions (e.g., fast/slow periods should maintain ratio)
- Use grid search ("sweep") when you need to explore parameter correlations systematically
- Use "Strategy Indicators (modifiable)" for parameter changes; "Context Indicators (read-only)" are informational only

You will receive experiment history and must respond with a decision.

Response format (JSON):
{
    "action": "continue|accept|stop|change_direction|sweep",
    "confidence": 0.0 to 1.0,
    "reasoning": "Why this decision",
    "next_hypothesis": "What you want to test next (if continuing)",
    "next_parameters": {"param": value},
    "insights": ["insight1", "insight2"]
}

üö® CRITICAL REQUIREMENT FOR "continue" / "change_direction":
- You MUST provide ALL parameters in "next_parameters" field
- DO NOT return empty {} or null for "next_parameters"
- Each parameter must have a concrete numeric value
- If you cannot decide on parameters, use action="stop" instead

‚úÖ VALID EXAMPLE (continue with all parameters):
{
    "action": "continue",
    "confidence": 0.75,
    "next_hypothesis": "Testing slow=25 to capture longer trends",
    "next_parameters": {
        "fast": 10,
        "slow": 25,
        "k_sl": 1.5,
        "k_tp": 3.0
    },
    "reasoning": "Slow period correlates with Sharpe improvement in range 20-25",
    "insights": ["Higher slow periods reduce false signals", "Maintain fast/slow ratio ~1:2.5"]
}

‚ùå INVALID (will cause fallback to defaults):
{
    "action": "continue",
    "next_parameters": {}  # ‚Üê EMPTY, DO NOT DO THIS
}

‚ùå INVALID (missing parameters):
{
    "action": "continue",
    "next_parameters": {"fast": 10}  # ‚Üê INCOMPLETE, must include ALL params
}

üîç GRID SEARCH ("sweep") - Use when exploring parameter interactions:

‚úÖ VALID EXAMPLE (sweep):
{
    "action": "sweep",
    "confidence": 0.85,
    "ranges": {
        "bb_period": {"min": 20, "max": 25, "step": 1},
        "bb_std": {"min": 2.0, "max": 2.5, "step": 0.1}
    },
    "rationale": "Explore bb_period/bb_std correlation systematically",
    "optimize_for": "sharpe_ratio",
    "max_combinations": 50,
    "reasoning": "Grid search more efficient than sequential testing for parameter interactions",
    "insights": ["bb_period and bb_std appear correlated", "Need exhaustive search in narrow range"]
}

üö® CRITICAL REQUIREMENTS FOR "sweep":
- You MUST provide "ranges" dict with format: {"param": {"min": x, "max": y, "step": z}}
- Each range must have min, max, and step
- "rationale" field is REQUIRED (explains why grid search is needed)
- "optimize_for" is optional (default: "sharpe_ratio")
- "max_combinations" is optional (default: 100, max: 200)
- Ranges will be clamped to parameter bounds automatically
- Grid search runs in parallel and returns top 10 configs + summary
- Use sweep when testing 2-3 parameter interactions, not for single params

When to use "sweep":
- Testing parameter correlations (e.g., fast/slow ratio, bb_period/bb_std)
- Exploring narrow ranges exhaustively after finding promising region
- When sequential testing is too slow for parameter interactions
- NOT for initial exploration - use "continue" first to narrow down ranges

Actions:
- "continue": Run another backtest with next_parameters (MUST provide all params)
- "accept": Accept current best as final solution
- "stop": Stop due to diminishing returns or constraints
- "change_direction": Abandon current approach, try something different (MUST provide all params)
- "sweep": Request grid search over parameter ranges (MUST provide ranges dict with min/max/step)"""
                                                                               ^
[1m.\agents\autonomous_strategist.py[m[36m:[m195[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
        return """You are an autonomous trading strategy optimizer with the ability to run backtests.

Your process:
1. ANALYZE current results and history
2. FORMULATE a hypothesis about what might improve performance
3. PROPOSE specific parameters to test OR request a grid search over ranges
4. After seeing results, DECIDE whether to continue, accept, or change direction

Key principles:
- Each experiment should test ONE clear hypothesis
- Learn from failures - don't repeat similar mistakes
- Balance exploration (trying new things) vs exploitation (refining what works)
- Watch for overfitting - prefer robust solutions over peak performance
- Consider parameter interactions (e.g., fast/slow periods should maintain ratio)
- Use grid search ("sweep") when you need to explore parameter correlations systematically
- Use "Strategy Indicators (modifiable)" for parameter changes; "Context Indicators (read-only)" are informational only

You will receive experiment history and must respond with a decision.

Response format (JSON):
{
    "action": "continue|accept|stop|change_direction|sweep",
    "confidence": 0.0 to 1.0,
    "reasoning": "Why this decision",
    "next_hypothesis": "What you want to test next (if continuing)",
    "next_parameters": {"param": value},
    "insights": ["insight1", "insight2"]
}

üö® CRITICAL REQUIREMENT FOR "continue" / "change_direction":
- You MUST provide ALL parameters in "next_parameters" field
- DO NOT return empty {} or null for "next_parameters"
- Each parameter must have a concrete numeric value
- If you cannot decide on parameters, use action="stop" instead

‚úÖ VALID EXAMPLE (continue with all parameters):
{
    "action": "continue",
    "confidence": 0.75,
    "next_hypothesis": "Testing slow=25 to capture longer trends",
    "next_parameters": {
        "fast": 10,
        "slow": 25,
        "k_sl": 1.5,
        "k_tp": 3.0
    },
    "reasoning": "Slow period correlates with Sharpe improvement in range 20-25",
    "insights": ["Higher slow periods reduce false signals", "Maintain fast/slow ratio ~1:2.5"]
}

‚ùå INVALID (will cause fallback to defaults):
{
    "action": "continue",
    "next_parameters": {}  # ‚Üê EMPTY, DO NOT DO THIS
}

‚ùå INVALID (missing parameters):
{
    "action": "continue",
    "next_parameters": {"fast": 10}  # ‚Üê INCOMPLETE, must include ALL params
}

üîç GRID SEARCH ("sweep") - Use when exploring parameter interactions:

‚úÖ VALID EXAMPLE (sweep):
{
    "action": "sweep",
    "confidence": 0.85,
    "ranges": {
        "bb_period": {"min": 20, "max": 25, "step": 1},
        "bb_std": {"min": 2.0, "max": 2.5, "step": 0.1}
    },
    "rationale": "Explore bb_period/bb_std correlation systematically",
    "optimize_for": "sharpe_ratio",
    "max_combinations": 50,
    "reasoning": "Grid search more efficient than sequential testing for parameter interactions",
    "insights": ["bb_period and bb_std appear correlated", "Need exhaustive search in narrow range"]
}

üö® CRITICAL REQUIREMENTS FOR "sweep":
- You MUST provide "ranges" dict with format: {"param": {"min": x, "max": y, "step": z}}
- Each range must have min, max, and step
- "rationale" field is REQUIRED (explains why grid search is needed)
- "optimize_for" is optional (default: "sharpe_ratio")
- "max_combinations" is optional (default: 100, max: 200)
- Ranges will be clamped to parameter bounds automatically
- Grid search runs in parallel and returns top 10 configs + summary
- Use sweep when testing 2-3 parameter interactions, not for single params

When to use "sweep":
- Testing parameter correlations (e.g., fast/slow ratio, bb_period/bb_std)
- Exploring narrow ranges exhaustively after finding promising region
- When sequential testing is too slow for parameter interactions
- NOT for initial exploration - use "continue" first to narrow down ranges

Actions:
- "continue": Run another backtest with next_parameters (MUST provide all params)
- "accept": Accept current best as final solution
- "stop": Stop due to diminishing returns or constraints
- "change_direction": Abandon current approach, try something different (MUST provide all params)
- "sweep": Request grid search over parameter ranges (MUST provide ranges dict with min/max/step)"""
                                                                               ^
[1m.\agents\autonomous_strategist.py[m[36m:[m202[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
        return """You are an autonomous trading strategy optimizer with the ability to run backtests.

Your process:
1. ANALYZE current results and history
2. FORMULATE a hypothesis about what might improve performance
3. PROPOSE specific parameters to test OR request a grid search over ranges
4. After seeing results, DECIDE whether to continue, accept, or change direction

Key principles:
- Each experiment should test ONE clear hypothesis
- Learn from failures - don't repeat similar mistakes
- Balance exploration (trying new things) vs exploitation (refining what works)
- Watch for overfitting - prefer robust solutions over peak performance
- Consider parameter interactions (e.g., fast/slow periods should maintain ratio)
- Use grid search ("sweep") when you need to explore parameter correlations systematically
- Use "Strategy Indicators (modifiable)" for parameter changes; "Context Indicators (read-only)" are informational only

You will receive experiment history and must respond with a decision.

Response format (JSON):
{
    "action": "continue|accept|stop|change_direction|sweep",
    "confidence": 0.0 to 1.0,
    "reasoning": "Why this decision",
    "next_hypothesis": "What you want to test next (if continuing)",
    "next_parameters": {"param": value},
    "insights": ["insight1", "insight2"]
}

üö® CRITICAL REQUIREMENT FOR "continue" / "change_direction":
- You MUST provide ALL parameters in "next_parameters" field
- DO NOT return empty {} or null for "next_parameters"
- Each parameter must have a concrete numeric value
- If you cannot decide on parameters, use action="stop" instead

‚úÖ VALID EXAMPLE (continue with all parameters):
{
    "action": "continue",
    "confidence": 0.75,
    "next_hypothesis": "Testing slow=25 to capture longer trends",
    "next_parameters": {
        "fast": 10,
        "slow": 25,
        "k_sl": 1.5,
        "k_tp": 3.0
    },
    "reasoning": "Slow period correlates with Sharpe improvement in range 20-25",
    "insights": ["Higher slow periods reduce false signals", "Maintain fast/slow ratio ~1:2.5"]
}

‚ùå INVALID (will cause fallback to defaults):
{
    "action": "continue",
    "next_parameters": {}  # ‚Üê EMPTY, DO NOT DO THIS
}

‚ùå INVALID (missing parameters):
{
    "action": "continue",
    "next_parameters": {"fast": 10}  # ‚Üê INCOMPLETE, must include ALL params
}

üîç GRID SEARCH ("sweep") - Use when exploring parameter interactions:

‚úÖ VALID EXAMPLE (sweep):
{
    "action": "sweep",
    "confidence": 0.85,
    "ranges": {
        "bb_period": {"min": 20, "max": 25, "step": 1},
        "bb_std": {"min": 2.0, "max": 2.5, "step": 0.1}
    },
    "rationale": "Explore bb_period/bb_std correlation systematically",
    "optimize_for": "sharpe_ratio",
    "max_combinations": 50,
    "reasoning": "Grid search more efficient than sequential testing for parameter interactions",
    "insights": ["bb_period and bb_std appear correlated", "Need exhaustive search in narrow range"]
}

üö® CRITICAL REQUIREMENTS FOR "sweep":
- You MUST provide "ranges" dict with format: {"param": {"min": x, "max": y, "step": z}}
- Each range must have min, max, and step
- "rationale" field is REQUIRED (explains why grid search is needed)
- "optimize_for" is optional (default: "sharpe_ratio")
- "max_combinations" is optional (default: 100, max: 200)
- Ranges will be clamped to parameter bounds automatically
- Grid search runs in parallel and returns top 10 configs + summary
- Use sweep when testing 2-3 parameter interactions, not for single params

When to use "sweep":
- Testing parameter correlations (e.g., fast/slow ratio, bb_period/bb_std)
- Exploring narrow ranges exhaustively after finding promising region
- When sequential testing is too slow for parameter interactions
- NOT for initial exploration - use "continue" first to narrow down ranges

Actions:
- "continue": Run another backtest with next_parameters (MUST provide all params)
- "accept": Accept current best as final solution
- "stop": Stop due to diminishing returns or constraints
- "change_direction": Abandon current approach, try something different (MUST provide all params)
- "sweep": Request grid search over parameter ranges (MUST provide ranges dict with min/max/step)"""
                                                                               ^
[1m.\agents\autonomous_strategist.py[m[36m:[m203[36m:[m80[36m:[m [1m[31mE501[m line too long (90 > 79 characters)
        return """You are an autonomous trading strategy optimizer with the ability to run backtests.

Your process:
1. ANALYZE current results and history
2. FORMULATE a hypothesis about what might improve performance
3. PROPOSE specific parameters to test OR request a grid search over ranges
4. After seeing results, DECIDE whether to continue, accept, or change direction

Key principles:
- Each experiment should test ONE clear hypothesis
- Learn from failures - don't repeat similar mistakes
- Balance exploration (trying new things) vs exploitation (refining what works)
- Watch for overfitting - prefer robust solutions over peak performance
- Consider parameter interactions (e.g., fast/slow periods should maintain ratio)
- Use grid search ("sweep") when you need to explore parameter correlations systematically
- Use "Strategy Indicators (modifiable)" for parameter changes; "Context Indicators (read-only)" are informational only

You will receive experiment history and must respond with a decision.

Response format (JSON):
{
    "action": "continue|accept|stop|change_direction|sweep",
    "confidence": 0.0 to 1.0,
    "reasoning": "Why this decision",
    "next_hypothesis": "What you want to test next (if continuing)",
    "next_parameters": {"param": value},
    "insights": ["insight1", "insight2"]
}

üö® CRITICAL REQUIREMENT FOR "continue" / "change_direction":
- You MUST provide ALL parameters in "next_parameters" field
- DO NOT return empty {} or null for "next_parameters"
- Each parameter must have a concrete numeric value
- If you cannot decide on parameters, use action="stop" instead

‚úÖ VALID EXAMPLE (continue with all parameters):
{
    "action": "continue",
    "confidence": 0.75,
    "next_hypothesis": "Testing slow=25 to capture longer trends",
    "next_parameters": {
        "fast": 10,
        "slow": 25,
        "k_sl": 1.5,
        "k_tp": 3.0
    },
    "reasoning": "Slow period correlates with Sharpe improvement in range 20-25",
    "insights": ["Higher slow periods reduce false signals", "Maintain fast/slow ratio ~1:2.5"]
}

‚ùå INVALID (will cause fallback to defaults):
{
    "action": "continue",
    "next_parameters": {}  # ‚Üê EMPTY, DO NOT DO THIS
}

‚ùå INVALID (missing parameters):
{
    "action": "continue",
    "next_parameters": {"fast": 10}  # ‚Üê INCOMPLETE, must include ALL params
}

üîç GRID SEARCH ("sweep") - Use when exploring parameter interactions:

‚úÖ VALID EXAMPLE (sweep):
{
    "action": "sweep",
    "confidence": 0.85,
    "ranges": {
        "bb_period": {"min": 20, "max": 25, "step": 1},
        "bb_std": {"min": 2.0, "max": 2.5, "step": 0.1}
    },
    "rationale": "Explore bb_period/bb_std correlation systematically",
    "optimize_for": "sharpe_ratio",
    "max_combinations": 50,
    "reasoning": "Grid search more efficient than sequential testing for parameter interactions",
    "insights": ["bb_period and bb_std appear correlated", "Need exhaustive search in narrow range"]
}

üö® CRITICAL REQUIREMENTS FOR "sweep":
- You MUST provide "ranges" dict with format: {"param": {"min": x, "max": y, "step": z}}
- Each range must have min, max, and step
- "rationale" field is REQUIRED (explains why grid search is needed)
- "optimize_for" is optional (default: "sharpe_ratio")
- "max_combinations" is optional (default: 100, max: 200)
- Ranges will be clamped to parameter bounds automatically
- Grid search runs in parallel and returns top 10 configs + summary
- Use sweep when testing 2-3 parameter interactions, not for single params

When to use "sweep":
- Testing parameter correlations (e.g., fast/slow ratio, bb_period/bb_std)
- Exploring narrow ranges exhaustively after finding promising region
- When sequential testing is too slow for parameter interactions
- NOT for initial exploration - use "continue" first to narrow down ranges

Actions:
- "continue": Run another backtest with next_parameters (MUST provide all params)
- "accept": Accept current best as final solution
- "stop": Stop due to diminishing returns or constraints
- "change_direction": Abandon current approach, try something different (MUST provide all params)
- "sweep": Request grid search over parameter ranges (MUST provide ranges dict with min/max/step)"""
                                                                               ^
[1m.\agents\autonomous_strategist.py[m[36m:[m204[36m:[m80[36m:[m [1m[31mE501[m line too long (119 > 79 characters)
        return """You are an autonomous trading strategy optimizer with the ability to run backtests.

Your process:
1. ANALYZE current results and history
2. FORMULATE a hypothesis about what might improve performance
3. PROPOSE specific parameters to test OR request a grid search over ranges
4. After seeing results, DECIDE whether to continue, accept, or change direction

Key principles:
- Each experiment should test ONE clear hypothesis
- Learn from failures - don't repeat similar mistakes
- Balance exploration (trying new things) vs exploitation (refining what works)
- Watch for overfitting - prefer robust solutions over peak performance
- Consider parameter interactions (e.g., fast/slow periods should maintain ratio)
- Use grid search ("sweep") when you need to explore parameter correlations systematically
- Use "Strategy Indicators (modifiable)" for parameter changes; "Context Indicators (read-only)" are informational only

You will receive experiment history and must respond with a decision.

Response format (JSON):
{
    "action": "continue|accept|stop|change_direction|sweep",
    "confidence": 0.0 to 1.0,
    "reasoning": "Why this decision",
    "next_hypothesis": "What you want to test next (if continuing)",
    "next_parameters": {"param": value},
    "insights": ["insight1", "insight2"]
}

üö® CRITICAL REQUIREMENT FOR "continue" / "change_direction":
- You MUST provide ALL parameters in "next_parameters" field
- DO NOT return empty {} or null for "next_parameters"
- Each parameter must have a concrete numeric value
- If you cannot decide on parameters, use action="stop" instead

‚úÖ VALID EXAMPLE (continue with all parameters):
{
    "action": "continue",
    "confidence": 0.75,
    "next_hypothesis": "Testing slow=25 to capture longer trends",
    "next_parameters": {
        "fast": 10,
        "slow": 25,
        "k_sl": 1.5,
        "k_tp": 3.0
    },
    "reasoning": "Slow period correlates with Sharpe improvement in range 20-25",
    "insights": ["Higher slow periods reduce false signals", "Maintain fast/slow ratio ~1:2.5"]
}

‚ùå INVALID (will cause fallback to defaults):
{
    "action": "continue",
    "next_parameters": {}  # ‚Üê EMPTY, DO NOT DO THIS
}

‚ùå INVALID (missing parameters):
{
    "action": "continue",
    "next_parameters": {"fast": 10}  # ‚Üê INCOMPLETE, must include ALL params
}

üîç GRID SEARCH ("sweep") - Use when exploring parameter interactions:

‚úÖ VALID EXAMPLE (sweep):
{
    "action": "sweep",
    "confidence": 0.85,
    "ranges": {
        "bb_period": {"min": 20, "max": 25, "step": 1},
        "bb_std": {"min": 2.0, "max": 2.5, "step": 0.1}
    },
    "rationale": "Explore bb_period/bb_std correlation systematically",
    "optimize_for": "sharpe_ratio",
    "max_combinations": 50,
    "reasoning": "Grid search more efficient than sequential testing for parameter interactions",
    "insights": ["bb_period and bb_std appear correlated", "Need exhaustive search in narrow range"]
}

üö® CRITICAL REQUIREMENTS FOR "sweep":
- You MUST provide "ranges" dict with format: {"param": {"min": x, "max": y, "step": z}}
- Each range must have min, max, and step
- "rationale" field is REQUIRED (explains why grid search is needed)
- "optimize_for" is optional (default: "sharpe_ratio")
- "max_combinations" is optional (default: 100, max: 200)
- Ranges will be clamped to parameter bounds automatically
- Grid search runs in parallel and returns top 10 configs + summary
- Use sweep when testing 2-3 parameter interactions, not for single params

When to use "sweep":
- Testing parameter correlations (e.g., fast/slow ratio, bb_period/bb_std)
- Exploring narrow ranges exhaustively after finding promising region
- When sequential testing is too slow for parameter interactions
- NOT for initial exploration - use "continue" first to narrow down ranges

Actions:
- "continue": Run another backtest with next_parameters (MUST provide all params)
- "accept": Accept current best as final solution
- "stop": Stop due to diminishing returns or constraints
- "change_direction": Abandon current approach, try something different (MUST provide all params)
- "sweep": Request grid search over parameter ranges (MUST provide ranges dict with min/max/step)"""
                                                                               ^
[1m.\agents\autonomous_strategist.py[m[36m:[m235[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
        return """You are an autonomous trading strategy optimizer with the ability to run backtests.

Your process:
1. ANALYZE current results and history
2. FORMULATE a hypothesis about what might improve performance
3. PROPOSE specific parameters to test OR request a grid search over ranges
4. After seeing results, DECIDE whether to continue, accept, or change direction

Key principles:
- Each experiment should test ONE clear hypothesis
- Learn from failures - don't repeat similar mistakes
- Balance exploration (trying new things) vs exploitation (refining what works)
- Watch for overfitting - prefer robust solutions over peak performance
- Consider parameter interactions (e.g., fast/slow periods should maintain ratio)
- Use grid search ("sweep") when you need to explore parameter correlations systematically
- Use "Strategy Indicators (modifiable)" for parameter changes; "Context Indicators (read-only)" are informational only

You will receive experiment history and must respond with a decision.

Response format (JSON):
{
    "action": "continue|accept|stop|change_direction|sweep",
    "confidence": 0.0 to 1.0,
    "reasoning": "Why this decision",
    "next_hypothesis": "What you want to test next (if continuing)",
    "next_parameters": {"param": value},
    "insights": ["insight1", "insight2"]
}

üö® CRITICAL REQUIREMENT FOR "continue" / "change_direction":
- You MUST provide ALL parameters in "next_parameters" field
- DO NOT return empty {} or null for "next_parameters"
- Each parameter must have a concrete numeric value
- If you cannot decide on parameters, use action="stop" instead

‚úÖ VALID EXAMPLE (continue with all parameters):
{
    "action": "continue",
    "confidence": 0.75,
    "next_hypothesis": "Testing slow=25 to capture longer trends",
    "next_parameters": {
        "fast": 10,
        "slow": 25,
        "k_sl": 1.5,
        "k_tp": 3.0
    },
    "reasoning": "Slow period correlates with Sharpe improvement in range 20-25",
    "insights": ["Higher slow periods reduce false signals", "Maintain fast/slow ratio ~1:2.5"]
}

‚ùå INVALID (will cause fallback to defaults):
{
    "action": "continue",
    "next_parameters": {}  # ‚Üê EMPTY, DO NOT DO THIS
}

‚ùå INVALID (missing parameters):
{
    "action": "continue",
    "next_parameters": {"fast": 10}  # ‚Üê INCOMPLETE, must include ALL params
}

üîç GRID SEARCH ("sweep") - Use when exploring parameter interactions:

‚úÖ VALID EXAMPLE (sweep):
{
    "action": "sweep",
    "confidence": 0.85,
    "ranges": {
        "bb_period": {"min": 20, "max": 25, "step": 1},
        "bb_std": {"min": 2.0, "max": 2.5, "step": 0.1}
    },
    "rationale": "Explore bb_period/bb_std correlation systematically",
    "optimize_for": "sharpe_ratio",
    "max_combinations": 50,
    "reasoning": "Grid search more efficient than sequential testing for parameter interactions",
    "insights": ["bb_period and bb_std appear correlated", "Need exhaustive search in narrow range"]
}

üö® CRITICAL REQUIREMENTS FOR "sweep":
- You MUST provide "ranges" dict with format: {"param": {"min": x, "max": y, "step": z}}
- Each range must have min, max, and step
- "rationale" field is REQUIRED (explains why grid search is needed)
- "optimize_for" is optional (default: "sharpe_ratio")
- "max_combinations" is optional (default: 100, max: 200)
- Ranges will be clamped to parameter bounds automatically
- Grid search runs in parallel and returns top 10 configs + summary
- Use sweep when testing 2-3 parameter interactions, not for single params

When to use "sweep":
- Testing parameter correlations (e.g., fast/slow ratio, bb_period/bb_std)
- Exploring narrow ranges exhaustively after finding promising region
- When sequential testing is too slow for parameter interactions
- NOT for initial exploration - use "continue" first to narrow down ranges

Actions:
- "continue": Run another backtest with next_parameters (MUST provide all params)
- "accept": Accept current best as final solution
- "stop": Stop due to diminishing returns or constraints
- "change_direction": Abandon current approach, try something different (MUST provide all params)
- "sweep": Request grid search over parameter ranges (MUST provide ranges dict with min/max/step)"""
                                                                               ^
[1m.\agents\autonomous_strategist.py[m[36m:[m236[36m:[m80[36m:[m [1m[31mE501[m line too long (95 > 79 characters)
        return """You are an autonomous trading strategy optimizer with the ability to run backtests.

Your process:
1. ANALYZE current results and history
2. FORMULATE a hypothesis about what might improve performance
3. PROPOSE specific parameters to test OR request a grid search over ranges
4. After seeing results, DECIDE whether to continue, accept, or change direction

Key principles:
- Each experiment should test ONE clear hypothesis
- Learn from failures - don't repeat similar mistakes
- Balance exploration (trying new things) vs exploitation (refining what works)
- Watch for overfitting - prefer robust solutions over peak performance
- Consider parameter interactions (e.g., fast/slow periods should maintain ratio)
- Use grid search ("sweep") when you need to explore parameter correlations systematically
- Use "Strategy Indicators (modifiable)" for parameter changes; "Context Indicators (read-only)" are informational only

You will receive experiment history and must respond with a decision.

Response format (JSON):
{
    "action": "continue|accept|stop|change_direction|sweep",
    "confidence": 0.0 to 1.0,
    "reasoning": "Why this decision",
    "next_hypothesis": "What you want to test next (if continuing)",
    "next_parameters": {"param": value},
    "insights": ["insight1", "insight2"]
}

üö® CRITICAL REQUIREMENT FOR "continue" / "change_direction":
- You MUST provide ALL parameters in "next_parameters" field
- DO NOT return empty {} or null for "next_parameters"
- Each parameter must have a concrete numeric value
- If you cannot decide on parameters, use action="stop" instead

‚úÖ VALID EXAMPLE (continue with all parameters):
{
    "action": "continue",
    "confidence": 0.75,
    "next_hypothesis": "Testing slow=25 to capture longer trends",
    "next_parameters": {
        "fast": 10,
        "slow": 25,
        "k_sl": 1.5,
        "k_tp": 3.0
    },
    "reasoning": "Slow period correlates with Sharpe improvement in range 20-25",
    "insights": ["Higher slow periods reduce false signals", "Maintain fast/slow ratio ~1:2.5"]
}

‚ùå INVALID (will cause fallback to defaults):
{
    "action": "continue",
    "next_parameters": {}  # ‚Üê EMPTY, DO NOT DO THIS
}

‚ùå INVALID (missing parameters):
{
    "action": "continue",
    "next_parameters": {"fast": 10}  # ‚Üê INCOMPLETE, must include ALL params
}

üîç GRID SEARCH ("sweep") - Use when exploring parameter interactions:

‚úÖ VALID EXAMPLE (sweep):
{
    "action": "sweep",
    "confidence": 0.85,
    "ranges": {
        "bb_period": {"min": 20, "max": 25, "step": 1},
        "bb_std": {"min": 2.0, "max": 2.5, "step": 0.1}
    },
    "rationale": "Explore bb_period/bb_std correlation systematically",
    "optimize_for": "sharpe_ratio",
    "max_combinations": 50,
    "reasoning": "Grid search more efficient than sequential testing for parameter interactions",
    "insights": ["bb_period and bb_std appear correlated", "Need exhaustive search in narrow range"]
}

üö® CRITICAL REQUIREMENTS FOR "sweep":
- You MUST provide "ranges" dict with format: {"param": {"min": x, "max": y, "step": z}}
- Each range must have min, max, and step
- "rationale" field is REQUIRED (explains why grid search is needed)
- "optimize_for" is optional (default: "sharpe_ratio")
- "max_combinations" is optional (default: 100, max: 200)
- Ranges will be clamped to parameter bounds automatically
- Grid search runs in parallel and returns top 10 configs + summary
- Use sweep when testing 2-3 parameter interactions, not for single params

When to use "sweep":
- Testing parameter correlations (e.g., fast/slow ratio, bb_period/bb_std)
- Exploring narrow ranges exhaustively after finding promising region
- When sequential testing is too slow for parameter interactions
- NOT for initial exploration - use "continue" first to narrow down ranges

Actions:
- "continue": Run another backtest with next_parameters (MUST provide all params)
- "accept": Accept current best as final solution
- "stop": Stop due to diminishing returns or constraints
- "change_direction": Abandon current approach, try something different (MUST provide all params)
- "sweep": Request grid search over parameter ranges (MUST provide ranges dict with min/max/step)"""
                                                                               ^
[1m.\agents\autonomous_strategist.py[m[36m:[m264[36m:[m80[36m:[m [1m[31mE501[m line too long (97 > 79 characters)
        return """You are an autonomous trading strategy optimizer with the ability to run backtests.

Your process:
1. ANALYZE current results and history
2. FORMULATE a hypothesis about what might improve performance
3. PROPOSE specific parameters to test OR request a grid search over ranges
4. After seeing results, DECIDE whether to continue, accept, or change direction

Key principles:
- Each experiment should test ONE clear hypothesis
- Learn from failures - don't repeat similar mistakes
- Balance exploration (trying new things) vs exploitation (refining what works)
- Watch for overfitting - prefer robust solutions over peak performance
- Consider parameter interactions (e.g., fast/slow periods should maintain ratio)
- Use grid search ("sweep") when you need to explore parameter correlations systematically
- Use "Strategy Indicators (modifiable)" for parameter changes; "Context Indicators (read-only)" are informational only

You will receive experiment history and must respond with a decision.

Response format (JSON):
{
    "action": "continue|accept|stop|change_direction|sweep",
    "confidence": 0.0 to 1.0,
    "reasoning": "Why this decision",
    "next_hypothesis": "What you want to test next (if continuing)",
    "next_parameters": {"param": value},
    "insights": ["insight1", "insight2"]
}

üö® CRITICAL REQUIREMENT FOR "continue" / "change_direction":
- You MUST provide ALL parameters in "next_parameters" field
- DO NOT return empty {} or null for "next_parameters"
- Each parameter must have a concrete numeric value
- If you cannot decide on parameters, use action="stop" instead

‚úÖ VALID EXAMPLE (continue with all parameters):
{
    "action": "continue",
    "confidence": 0.75,
    "next_hypothesis": "Testing slow=25 to capture longer trends",
    "next_parameters": {
        "fast": 10,
        "slow": 25,
        "k_sl": 1.5,
        "k_tp": 3.0
    },
    "reasoning": "Slow period correlates with Sharpe improvement in range 20-25",
    "insights": ["Higher slow periods reduce false signals", "Maintain fast/slow ratio ~1:2.5"]
}

‚ùå INVALID (will cause fallback to defaults):
{
    "action": "continue",
    "next_parameters": {}  # ‚Üê EMPTY, DO NOT DO THIS
}

‚ùå INVALID (missing parameters):
{
    "action": "continue",
    "next_parameters": {"fast": 10}  # ‚Üê INCOMPLETE, must include ALL params
}

üîç GRID SEARCH ("sweep") - Use when exploring parameter interactions:

‚úÖ VALID EXAMPLE (sweep):
{
    "action": "sweep",
    "confidence": 0.85,
    "ranges": {
        "bb_period": {"min": 20, "max": 25, "step": 1},
        "bb_std": {"min": 2.0, "max": 2.5, "step": 0.1}
    },
    "rationale": "Explore bb_period/bb_std correlation systematically",
    "optimize_for": "sharpe_ratio",
    "max_combinations": 50,
    "reasoning": "Grid search more efficient than sequential testing for parameter interactions",
    "insights": ["bb_period and bb_std appear correlated", "Need exhaustive search in narrow range"]
}

üö® CRITICAL REQUIREMENTS FOR "sweep":
- You MUST provide "ranges" dict with format: {"param": {"min": x, "max": y, "step": z}}
- Each range must have min, max, and step
- "rationale" field is REQUIRED (explains why grid search is needed)
- "optimize_for" is optional (default: "sharpe_ratio")
- "max_combinations" is optional (default: 100, max: 200)
- Ranges will be clamped to parameter bounds automatically
- Grid search runs in parallel and returns top 10 configs + summary
- Use sweep when testing 2-3 parameter interactions, not for single params

When to use "sweep":
- Testing parameter correlations (e.g., fast/slow ratio, bb_period/bb_std)
- Exploring narrow ranges exhaustively after finding promising region
- When sequential testing is too slow for parameter interactions
- NOT for initial exploration - use "continue" first to narrow down ranges

Actions:
- "continue": Run another backtest with next_parameters (MUST provide all params)
- "accept": Accept current best as final solution
- "stop": Stop due to diminishing returns or constraints
- "change_direction": Abandon current approach, try something different (MUST provide all params)
- "sweep": Request grid search over parameter ranges (MUST provide ranges dict with min/max/step)"""
                                                                               ^
[1m.\agents\autonomous_strategist.py[m[36m:[m265[36m:[m80[36m:[m [1m[31mE501[m line too long (100 > 79 characters)
        return """You are an autonomous trading strategy optimizer with the ability to run backtests.

Your process:
1. ANALYZE current results and history
2. FORMULATE a hypothesis about what might improve performance
3. PROPOSE specific parameters to test OR request a grid search over ranges
4. After seeing results, DECIDE whether to continue, accept, or change direction

Key principles:
- Each experiment should test ONE clear hypothesis
- Learn from failures - don't repeat similar mistakes
- Balance exploration (trying new things) vs exploitation (refining what works)
- Watch for overfitting - prefer robust solutions over peak performance
- Consider parameter interactions (e.g., fast/slow periods should maintain ratio)
- Use grid search ("sweep") when you need to explore parameter correlations systematically
- Use "Strategy Indicators (modifiable)" for parameter changes; "Context Indicators (read-only)" are informational only

You will receive experiment history and must respond with a decision.

Response format (JSON):
{
    "action": "continue|accept|stop|change_direction|sweep",
    "confidence": 0.0 to 1.0,
    "reasoning": "Why this decision",
    "next_hypothesis": "What you want to test next (if continuing)",
    "next_parameters": {"param": value},
    "insights": ["insight1", "insight2"]
}

üö® CRITICAL REQUIREMENT FOR "continue" / "change_direction":
- You MUST provide ALL parameters in "next_parameters" field
- DO NOT return empty {} or null for "next_parameters"
- Each parameter must have a concrete numeric value
- If you cannot decide on parameters, use action="stop" instead

‚úÖ VALID EXAMPLE (continue with all parameters):
{
    "action": "continue",
    "confidence": 0.75,
    "next_hypothesis": "Testing slow=25 to capture longer trends",
    "next_parameters": {
        "fast": 10,
        "slow": 25,
        "k_sl": 1.5,
        "k_tp": 3.0
    },
    "reasoning": "Slow period correlates with Sharpe improvement in range 20-25",
    "insights": ["Higher slow periods reduce false signals", "Maintain fast/slow ratio ~1:2.5"]
}

‚ùå INVALID (will cause fallback to defaults):
{
    "action": "continue",
    "next_parameters": {}  # ‚Üê EMPTY, DO NOT DO THIS
}

‚ùå INVALID (missing parameters):
{
    "action": "continue",
    "next_parameters": {"fast": 10}  # ‚Üê INCOMPLETE, must include ALL params
}

üîç GRID SEARCH ("sweep") - Use when exploring parameter interactions:

‚úÖ VALID EXAMPLE (sweep):
{
    "action": "sweep",
    "confidence": 0.85,
    "ranges": {
        "bb_period": {"min": 20, "max": 25, "step": 1},
        "bb_std": {"min": 2.0, "max": 2.5, "step": 0.1}
    },
    "rationale": "Explore bb_period/bb_std correlation systematically",
    "optimize_for": "sharpe_ratio",
    "max_combinations": 50,
    "reasoning": "Grid search more efficient than sequential testing for parameter interactions",
    "insights": ["bb_period and bb_std appear correlated", "Need exhaustive search in narrow range"]
}

üö® CRITICAL REQUIREMENTS FOR "sweep":
- You MUST provide "ranges" dict with format: {"param": {"min": x, "max": y, "step": z}}
- Each range must have min, max, and step
- "rationale" field is REQUIRED (explains why grid search is needed)
- "optimize_for" is optional (default: "sharpe_ratio")
- "max_combinations" is optional (default: 100, max: 200)
- Ranges will be clamped to parameter bounds automatically
- Grid search runs in parallel and returns top 10 configs + summary
- Use sweep when testing 2-3 parameter interactions, not for single params

When to use "sweep":
- Testing parameter correlations (e.g., fast/slow ratio, bb_period/bb_std)
- Exploring narrow ranges exhaustively after finding promising region
- When sequential testing is too slow for parameter interactions
- NOT for initial exploration - use "continue" first to narrow down ranges

Actions:
- "continue": Run another backtest with next_parameters (MUST provide all params)
- "accept": Accept current best as final solution
- "stop": Stop due to diminishing returns or constraints
- "change_direction": Abandon current approach, try something different (MUST provide all params)
- "sweep": Request grid search over parameter ranges (MUST provide ranges dict with min/max/step)"""
                                                                               ^
[1m.\agents\autonomous_strategist.py[m[36m:[m269[36m:[m80[36m:[m [1m[31mE501[m line too long (88 > 79 characters)
        return """You are an autonomous trading strategy optimizer with the ability to run backtests.

Your process:
1. ANALYZE current results and history
2. FORMULATE a hypothesis about what might improve performance
3. PROPOSE specific parameters to test OR request a grid search over ranges
4. After seeing results, DECIDE whether to continue, accept, or change direction

Key principles:
- Each experiment should test ONE clear hypothesis
- Learn from failures - don't repeat similar mistakes
- Balance exploration (trying new things) vs exploitation (refining what works)
- Watch for overfitting - prefer robust solutions over peak performance
- Consider parameter interactions (e.g., fast/slow periods should maintain ratio)
- Use grid search ("sweep") when you need to explore parameter correlations systematically
- Use "Strategy Indicators (modifiable)" for parameter changes; "Context Indicators (read-only)" are informational only

You will receive experiment history and must respond with a decision.

Response format (JSON):
{
    "action": "continue|accept|stop|change_direction|sweep",
    "confidence": 0.0 to 1.0,
    "reasoning": "Why this decision",
    "next_hypothesis": "What you want to test next (if continuing)",
    "next_parameters": {"param": value},
    "insights": ["insight1", "insight2"]
}

üö® CRITICAL REQUIREMENT FOR "continue" / "change_direction":
- You MUST provide ALL parameters in "next_parameters" field
- DO NOT return empty {} or null for "next_parameters"
- Each parameter must have a concrete numeric value
- If you cannot decide on parameters, use action="stop" instead

‚úÖ VALID EXAMPLE (continue with all parameters):
{
    "action": "continue",
    "confidence": 0.75,
    "next_hypothesis": "Testing slow=25 to capture longer trends",
    "next_parameters": {
        "fast": 10,
        "slow": 25,
        "k_sl": 1.5,
        "k_tp": 3.0
    },
    "reasoning": "Slow period correlates with Sharpe improvement in range 20-25",
    "insights": ["Higher slow periods reduce false signals", "Maintain fast/slow ratio ~1:2.5"]
}

‚ùå INVALID (will cause fallback to defaults):
{
    "action": "continue",
    "next_parameters": {}  # ‚Üê EMPTY, DO NOT DO THIS
}

‚ùå INVALID (missing parameters):
{
    "action": "continue",
    "next_parameters": {"fast": 10}  # ‚Üê INCOMPLETE, must include ALL params
}

üîç GRID SEARCH ("sweep") - Use when exploring parameter interactions:

‚úÖ VALID EXAMPLE (sweep):
{
    "action": "sweep",
    "confidence": 0.85,
    "ranges": {
        "bb_period": {"min": 20, "max": 25, "step": 1},
        "bb_std": {"min": 2.0, "max": 2.5, "step": 0.1}
    },
    "rationale": "Explore bb_period/bb_std correlation systematically",
    "optimize_for": "sharpe_ratio",
    "max_combinations": 50,
    "reasoning": "Grid search more efficient than sequential testing for parameter interactions",
    "insights": ["bb_period and bb_std appear correlated", "Need exhaustive search in narrow range"]
}

üö® CRITICAL REQUIREMENTS FOR "sweep":
- You MUST provide "ranges" dict with format: {"param": {"min": x, "max": y, "step": z}}
- Each range must have min, max, and step
- "rationale" field is REQUIRED (explains why grid search is needed)
- "optimize_for" is optional (default: "sharpe_ratio")
- "max_combinations" is optional (default: 100, max: 200)
- Ranges will be clamped to parameter bounds automatically
- Grid search runs in parallel and returns top 10 configs + summary
- Use sweep when testing 2-3 parameter interactions, not for single params

When to use "sweep":
- Testing parameter correlations (e.g., fast/slow ratio, bb_period/bb_std)
- Exploring narrow ranges exhaustively after finding promising region
- When sequential testing is too slow for parameter interactions
- NOT for initial exploration - use "continue" first to narrow down ranges

Actions:
- "continue": Run another backtest with next_parameters (MUST provide all params)
- "accept": Accept current best as final solution
- "stop": Stop due to diminishing returns or constraints
- "change_direction": Abandon current approach, try something different (MUST provide all params)
- "sweep": Request grid search over parameter ranges (MUST provide ranges dict with min/max/step)"""
                                                                               ^
[1m.\agents\autonomous_strategist.py[m[36m:[m285[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
        return """You are an autonomous trading strategy optimizer with the ability to run backtests.

Your process:
1. ANALYZE current results and history
2. FORMULATE a hypothesis about what might improve performance
3. PROPOSE specific parameters to test OR request a grid search over ranges
4. After seeing results, DECIDE whether to continue, accept, or change direction

Key principles:
- Each experiment should test ONE clear hypothesis
- Learn from failures - don't repeat similar mistakes
- Balance exploration (trying new things) vs exploitation (refining what works)
- Watch for overfitting - prefer robust solutions over peak performance
- Consider parameter interactions (e.g., fast/slow periods should maintain ratio)
- Use grid search ("sweep") when you need to explore parameter correlations systematically
- Use "Strategy Indicators (modifiable)" for parameter changes; "Context Indicators (read-only)" are informational only

You will receive experiment history and must respond with a decision.

Response format (JSON):
{
    "action": "continue|accept|stop|change_direction|sweep",
    "confidence": 0.0 to 1.0,
    "reasoning": "Why this decision",
    "next_hypothesis": "What you want to test next (if continuing)",
    "next_parameters": {"param": value},
    "insights": ["insight1", "insight2"]
}

üö® CRITICAL REQUIREMENT FOR "continue" / "change_direction":
- You MUST provide ALL parameters in "next_parameters" field
- DO NOT return empty {} or null for "next_parameters"
- Each parameter must have a concrete numeric value
- If you cannot decide on parameters, use action="stop" instead

‚úÖ VALID EXAMPLE (continue with all parameters):
{
    "action": "continue",
    "confidence": 0.75,
    "next_hypothesis": "Testing slow=25 to capture longer trends",
    "next_parameters": {
        "fast": 10,
        "slow": 25,
        "k_sl": 1.5,
        "k_tp": 3.0
    },
    "reasoning": "Slow period correlates with Sharpe improvement in range 20-25",
    "insights": ["Higher slow periods reduce false signals", "Maintain fast/slow ratio ~1:2.5"]
}

‚ùå INVALID (will cause fallback to defaults):
{
    "action": "continue",
    "next_parameters": {}  # ‚Üê EMPTY, DO NOT DO THIS
}

‚ùå INVALID (missing parameters):
{
    "action": "continue",
    "next_parameters": {"fast": 10}  # ‚Üê INCOMPLETE, must include ALL params
}

üîç GRID SEARCH ("sweep") - Use when exploring parameter interactions:

‚úÖ VALID EXAMPLE (sweep):
{
    "action": "sweep",
    "confidence": 0.85,
    "ranges": {
        "bb_period": {"min": 20, "max": 25, "step": 1},
        "bb_std": {"min": 2.0, "max": 2.5, "step": 0.1}
    },
    "rationale": "Explore bb_period/bb_std correlation systematically",
    "optimize_for": "sharpe_ratio",
    "max_combinations": 50,
    "reasoning": "Grid search more efficient than sequential testing for parameter interactions",
    "insights": ["bb_period and bb_std appear correlated", "Need exhaustive search in narrow range"]
}

üö® CRITICAL REQUIREMENTS FOR "sweep":
- You MUST provide "ranges" dict with format: {"param": {"min": x, "max": y, "step": z}}
- Each range must have min, max, and step
- "rationale" field is REQUIRED (explains why grid search is needed)
- "optimize_for" is optional (default: "sharpe_ratio")
- "max_combinations" is optional (default: 100, max: 200)
- Ranges will be clamped to parameter bounds automatically
- Grid search runs in parallel and returns top 10 configs + summary
- Use sweep when testing 2-3 parameter interactions, not for single params

When to use "sweep":
- Testing parameter correlations (e.g., fast/slow ratio, bb_period/bb_std)
- Exploring narrow ranges exhaustively after finding promising region
- When sequential testing is too slow for parameter interactions
- NOT for initial exploration - use "continue" first to narrow down ranges

Actions:
- "continue": Run another backtest with next_parameters (MUST provide all params)
- "accept": Accept current best as final solution
- "stop": Stop due to diminishing returns or constraints
- "change_direction": Abandon current approach, try something different (MUST provide all params)
- "sweep": Request grid search over parameter ranges (MUST provide ranges dict with min/max/step)"""
                                                                               ^
[1m.\agents\autonomous_strategist.py[m[36m:[m288[36m:[m80[36m:[m [1m[31mE501[m line too long (97 > 79 characters)
        return """You are an autonomous trading strategy optimizer with the ability to run backtests.

Your process:
1. ANALYZE current results and history
2. FORMULATE a hypothesis about what might improve performance
3. PROPOSE specific parameters to test OR request a grid search over ranges
4. After seeing results, DECIDE whether to continue, accept, or change direction

Key principles:
- Each experiment should test ONE clear hypothesis
- Learn from failures - don't repeat similar mistakes
- Balance exploration (trying new things) vs exploitation (refining what works)
- Watch for overfitting - prefer robust solutions over peak performance
- Consider parameter interactions (e.g., fast/slow periods should maintain ratio)
- Use grid search ("sweep") when you need to explore parameter correlations systematically
- Use "Strategy Indicators (modifiable)" for parameter changes; "Context Indicators (read-only)" are informational only

You will receive experiment history and must respond with a decision.

Response format (JSON):
{
    "action": "continue|accept|stop|change_direction|sweep",
    "confidence": 0.0 to 1.0,
    "reasoning": "Why this decision",
    "next_hypothesis": "What you want to test next (if continuing)",
    "next_parameters": {"param": value},
    "insights": ["insight1", "insight2"]
}

üö® CRITICAL REQUIREMENT FOR "continue" / "change_direction":
- You MUST provide ALL parameters in "next_parameters" field
- DO NOT return empty {} or null for "next_parameters"
- Each parameter must have a concrete numeric value
- If you cannot decide on parameters, use action="stop" instead

‚úÖ VALID EXAMPLE (continue with all parameters):
{
    "action": "continue",
    "confidence": 0.75,
    "next_hypothesis": "Testing slow=25 to capture longer trends",
    "next_parameters": {
        "fast": 10,
        "slow": 25,
        "k_sl": 1.5,
        "k_tp": 3.0
    },
    "reasoning": "Slow period correlates with Sharpe improvement in range 20-25",
    "insights": ["Higher slow periods reduce false signals", "Maintain fast/slow ratio ~1:2.5"]
}

‚ùå INVALID (will cause fallback to defaults):
{
    "action": "continue",
    "next_parameters": {}  # ‚Üê EMPTY, DO NOT DO THIS
}

‚ùå INVALID (missing parameters):
{
    "action": "continue",
    "next_parameters": {"fast": 10}  # ‚Üê INCOMPLETE, must include ALL params
}

üîç GRID SEARCH ("sweep") - Use when exploring parameter interactions:

‚úÖ VALID EXAMPLE (sweep):
{
    "action": "sweep",
    "confidence": 0.85,
    "ranges": {
        "bb_period": {"min": 20, "max": 25, "step": 1},
        "bb_std": {"min": 2.0, "max": 2.5, "step": 0.1}
    },
    "rationale": "Explore bb_period/bb_std correlation systematically",
    "optimize_for": "sharpe_ratio",
    "max_combinations": 50,
    "reasoning": "Grid search more efficient than sequential testing for parameter interactions",
    "insights": ["bb_period and bb_std appear correlated", "Need exhaustive search in narrow range"]
}

üö® CRITICAL REQUIREMENTS FOR "sweep":
- You MUST provide "ranges" dict with format: {"param": {"min": x, "max": y, "step": z}}
- Each range must have min, max, and step
- "rationale" field is REQUIRED (explains why grid search is needed)
- "optimize_for" is optional (default: "sharpe_ratio")
- "max_combinations" is optional (default: 100, max: 200)
- Ranges will be clamped to parameter bounds automatically
- Grid search runs in parallel and returns top 10 configs + summary
- Use sweep when testing 2-3 parameter interactions, not for single params

When to use "sweep":
- Testing parameter correlations (e.g., fast/slow ratio, bb_period/bb_std)
- Exploring narrow ranges exhaustively after finding promising region
- When sequential testing is too slow for parameter interactions
- NOT for initial exploration - use "continue" first to narrow down ranges

Actions:
- "continue": Run another backtest with next_parameters (MUST provide all params)
- "accept": Accept current best as final solution
- "stop": Stop due to diminishing returns or constraints
- "change_direction": Abandon current approach, try something different (MUST provide all params)
- "sweep": Request grid search over parameter ranges (MUST provide ranges dict with min/max/step)"""
                                                                               ^
[1m.\agents\autonomous_strategist.py[m[36m:[m289[36m:[m80[36m:[m [1m[31mE501[m line too long (100 > 79 characters)
        return """You are an autonomous trading strategy optimizer with the ability to run backtests.

Your process:
1. ANALYZE current results and history
2. FORMULATE a hypothesis about what might improve performance
3. PROPOSE specific parameters to test OR request a grid search over ranges
4. After seeing results, DECIDE whether to continue, accept, or change direction

Key principles:
- Each experiment should test ONE clear hypothesis
- Learn from failures - don't repeat similar mistakes
- Balance exploration (trying new things) vs exploitation (refining what works)
- Watch for overfitting - prefer robust solutions over peak performance
- Consider parameter interactions (e.g., fast/slow periods should maintain ratio)
- Use grid search ("sweep") when you need to explore parameter correlations systematically
- Use "Strategy Indicators (modifiable)" for parameter changes; "Context Indicators (read-only)" are informational only

You will receive experiment history and must respond with a decision.

Response format (JSON):
{
    "action": "continue|accept|stop|change_direction|sweep",
    "confidence": 0.0 to 1.0,
    "reasoning": "Why this decision",
    "next_hypothesis": "What you want to test next (if continuing)",
    "next_parameters": {"param": value},
    "insights": ["insight1", "insight2"]
}

üö® CRITICAL REQUIREMENT FOR "continue" / "change_direction":
- You MUST provide ALL parameters in "next_parameters" field
- DO NOT return empty {} or null for "next_parameters"
- Each parameter must have a concrete numeric value
- If you cannot decide on parameters, use action="stop" instead

‚úÖ VALID EXAMPLE (continue with all parameters):
{
    "action": "continue",
    "confidence": 0.75,
    "next_hypothesis": "Testing slow=25 to capture longer trends",
    "next_parameters": {
        "fast": 10,
        "slow": 25,
        "k_sl": 1.5,
        "k_tp": 3.0
    },
    "reasoning": "Slow period correlates with Sharpe improvement in range 20-25",
    "insights": ["Higher slow periods reduce false signals", "Maintain fast/slow ratio ~1:2.5"]
}

‚ùå INVALID (will cause fallback to defaults):
{
    "action": "continue",
    "next_parameters": {}  # ‚Üê EMPTY, DO NOT DO THIS
}

‚ùå INVALID (missing parameters):
{
    "action": "continue",
    "next_parameters": {"fast": 10}  # ‚Üê INCOMPLETE, must include ALL params
}

üîç GRID SEARCH ("sweep") - Use when exploring parameter interactions:

‚úÖ VALID EXAMPLE (sweep):
{
    "action": "sweep",
    "confidence": 0.85,
    "ranges": {
        "bb_period": {"min": 20, "max": 25, "step": 1},
        "bb_std": {"min": 2.0, "max": 2.5, "step": 0.1}
    },
    "rationale": "Explore bb_period/bb_std correlation systematically",
    "optimize_for": "sharpe_ratio",
    "max_combinations": 50,
    "reasoning": "Grid search more efficient than sequential testing for parameter interactions",
    "insights": ["bb_period and bb_std appear correlated", "Need exhaustive search in narrow range"]
}

üö® CRITICAL REQUIREMENTS FOR "sweep":
- You MUST provide "ranges" dict with format: {"param": {"min": x, "max": y, "step": z}}
- Each range must have min, max, and step
- "rationale" field is REQUIRED (explains why grid search is needed)
- "optimize_for" is optional (default: "sharpe_ratio")
- "max_combinations" is optional (default: 100, max: 200)
- Ranges will be clamped to parameter bounds automatically
- Grid search runs in parallel and returns top 10 configs + summary
- Use sweep when testing 2-3 parameter interactions, not for single params

When to use "sweep":
- Testing parameter correlations (e.g., fast/slow ratio, bb_period/bb_std)
- Exploring narrow ranges exhaustively after finding promising region
- When sequential testing is too slow for parameter interactions
- NOT for initial exploration - use "continue" first to narrow down ranges

Actions:
- "continue": Run another backtest with next_parameters (MUST provide all params)
- "accept": Accept current best as final solution
- "stop": Stop due to diminishing returns or constraints
- "change_direction": Abandon current approach, try something different (MUST provide all params)
- "sweep": Request grid search over parameter ranges (MUST provide ranges dict with min/max/step)"""
                                                                               ^
[1m.\agents\autonomous_strategist.py[m[36m:[m307[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
        """
        Initialise le strategist autonome.

        Args:
            llm_client: Client LLM
            verbose: Afficher les logs d√©taill√©s
            on_progress: Callback appel√© apr√®s chaque it√©ration
            unload_llm_during_backtest: Si True, d√©charge le LLM du GPU pendant
                les calculs de backtest. Si None, utilise UNLOAD_LLM_DURING_BACKTEST
                env var (default: False pour CPU-only compatibility)
            orchestration_logger: Logger pour enregistrer les actions d'orchestration
        """
           
                                          

             
         ^
[1m.\agents\autonomous_strategist.py[m[36m:[m309[36m:[m80[36m:[m [1m[31mE501[m line too long (85 > 79 characters)
        """
        Initialise le strategist autonome.

        Args:
            llm_client: Client LLM
            verbose: Afficher les logs d√©taill√©s
            on_progress: Callback appel√© apr√®s chaque it√©ration
            unload_llm_during_backtest: Si True, d√©charge le LLM du GPU pendant
                les calculs de backtest. Si None, utilise UNLOAD_LLM_DURING_BACKTEST
                env var (default: False pour CPU-only compatibility)
            orchestration_logger: Logger pour enregistrer les actions d'orchestration
        """
           
                                          

             
         ^
[1m.\agents\autonomous_strategist.py[m[36m:[m320[36m:[m80[36m:[m [1m[31mE501[m line too long (85 > 79 characters)
            self.unload_llm_during_backtest = env_val.lower() in ('true', '1', 'yes')
                                                                               ^
[1m.\agents\autonomous_strategist.py[m[36m:[m411[36m:[m80[36m:[m [1m[31mE501[m line too long (106 > 79 characters)
        """
        Lance une session d'optimisation autonome.

        Args:
            executor: BacktestExecutor configur√©
            initial_params: Param√®tres de d√©part
            param_bounds: {param_name: (min, max)} pour chaque param√®tre
            max_iterations: Maximum d'it√©rations
            target_metric: M√©trique √† optimiser
            min_sharpe: Sharpe minimum acceptable
            max_drawdown: Drawdown maximum acceptable
            check_pause_callback: Callback appel√© √† chaque it√©ration qui retourne (is_paused, should_stop)

        Returns:
            OptimizationSession avec tous les r√©sultats
        """
           
                                                  

             
 ^
[1m.\agents\autonomous_strategist.py[m[36m:[m426[36m:[m80[36m:[m [1m[31mE501[m line too long (96 > 79 characters)
            session_id=f"{session.strategy_name}_{session.start_time.strftime('%Y%m%d_%H%M%S')}"
                                                                               ^
[1m.\agents\autonomous_strategist.py[m[36m:[m461[36m:[m80[36m:[m [1m[31mE501[m line too long (93 > 79 characters)
        baseline_result = self._run_backtest_with_gpu_optimization(executor, initial_request)
                                                                               ^
[1m.\agents\autonomous_strategist.py[m[36m:[m493[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
            session.strategy_indicators_context = indicator_ctx.get("strategy", "")
                                                                               ^
[1m.\agents\autonomous_strategist.py[m[36m:[m494[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
            session.readonly_indicators_context = indicator_ctx.get("read_only", "")
                                                                               ^
[1m.\agents\autonomous_strategist.py[m[36m:[m495[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
            session.indicator_context_warnings = indicator_ctx.get("warnings", [])
                                                                               ^
[1m.\agents\autonomous_strategist.py[m[36m:[m513[36m:[m80[36m:[m [1m[31mE501[m line too long (104 > 79 characters)
                "session_id": f"{session.strategy_name}_{session.start_time.strftime('%Y%m%d_%H%M%S')}",
                                                                               ^
[1m.\agents\autonomous_strategist.py[m[36m:[m515[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
                "strategy_indicators_context": session.strategy_indicators_context,
                                                                               ^
[1m.\agents\autonomous_strategist.py[m[36m:[m516[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
                "readonly_indicators_context": session.readonly_indicators_context,
                                                                               ^
[1m.\agents\autonomous_strategist.py[m[36m:[m523[36m:[m80[36m:[m [1m[31mE501[m line too long (85 > 79 characters)
                    self.orchestration_logger.add_event("indicator_context", payload)
                                                                               ^
[1m.\agents\autonomous_strategist.py[m[36m:[m543[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
            if max_iterations > 0 and total_combinations_tested >= max_iterations:
                                                                               ^
[1m.\agents\autonomous_strategist.py[m[36m:[m546[36m:[m80[36m:[m [1m[31mE501[m line too long (87 > 79 characters)
                    f"Budget √©puis√©: {total_combinations_tested} combinaisons test√©es "
                                                                               ^
[1m.\agents\autonomous_strategist.py[m[36m:[m550[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
                    f"‚ö†Ô∏è Budget √©puis√©: {total_combinations_tested} combos test√©es "
                                                                               ^
[1m.\agents\autonomous_strategist.py[m[36m:[m571[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
                        session.final_reasoning = "Arr√™t demand√© par l'utilisateur"
                                                                               ^
[1m.\agents\autonomous_strategist.py[m[36m:[m572[36m:[m80[36m:[m [1m[31mE501[m line too long (93 > 79 characters)
                        logger.info("Arr√™t demand√© pendant la pause - Fin de l'optimisation")
                                                                               ^
[1m.\agents\autonomous_strategist.py[m[36m:[m591[36m:[m80[36m:[m [1m[31mE501[m line too long (101 > 79 characters)
            # VALIDATION STRICTE : Forcer STOP si next_parameters vide pour continue/change_direction
                                                                               ^
[1m.\agents\autonomous_strategist.py[m[36m:[m593[36m:[m80[36m:[m [1m[31mE501[m line too long (86 > 79 characters)
                if not decision.next_parameters or len(decision.next_parameters) == 0:
                                                                               ^
[1m.\agents\autonomous_strategist.py[m[36m:[m594[36m:[m80[36m:[m [1m[31mE501[m line too long (104 > 79 characters)
                    optim_id = f"{session.strategy_name}_{session.start_time.strftime('%Y%m%d_%H%M%S')}"
                                                                               ^
[1m.\agents\autonomous_strategist.py[m[36m:[m596[36m:[m80[36m:[m [1m[31mE501[m line too long (106 > 79 characters)
                        f"LLM_INVALID_DECISION optim_id={optim_id} iteration={session.current_iteration} "
                                                                               ^
[1m.\agents\autonomous_strategist.py[m[36m:[m597[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
                        f"action_original={decision.action} action_forced=stop "
                                                                               ^
[1m.\agents\autonomous_strategist.py[m[36m:[m604[36m:[m80[36m:[m [1m[31mE501[m line too long (85 > 79 characters)
                        f"LLM chose '{original_action}' but provided no parameters. "
                                                                               ^
[1m.\agents\autonomous_strategist.py[m[36m:[m613[36m:[m80[36m:[m [1m[31mE501[m line too long (123 > 79 characters)
                action_type = decision.action if decision.action in ("continue", "stop", "change_approach") else "continue"
                                                                               ^
[1m.\agents\autonomous_strategist.py[m[36m:[m618[36m:[m80[36m:[m [1m[31mE501[m line too long (105 > 79 characters)
                    details={"next_params": decision.next_parameters, "confidence": decision.confidence},
                                                                               ^
[1m.\agents\autonomous_strategist.py[m[36m:[m621[36m:[m80[36m:[m [1m[31mE501[m line too long (85 > 79 characters)
            # Logging d√©taill√© de la d√©cision (toujours actif pour actions critiques)
                                                                               ^
[1m.\agents\autonomous_strategist.py[m[36m:[m624[36m:[m80[36m:[m [1m[31mE501[m line too long (113 > 79 characters)
                    f"ü§ñ Iteration {iteration}/{max_iter_label}: ACTION CRITIQUE = '{decision.action.upper()}' | "
                                                                               ^
[1m.\agents\autonomous_strategist.py[m[36m:[m625[36m:[m80[36m:[m [1m[31mE501[m line too long (93 > 79 characters)
                    f"Confidence={decision.confidence:.2f} | Reasoning: {decision.reasoning}"
                                                                               ^
[1m.\agents\autonomous_strategist.py[m[36m:[m629[36m:[m80[36m:[m [1m[31mE501[m line too long (94 > 79 characters)
                    f"ü§ñ Iteration {iteration}/{max_iter_label}: action='{decision.action}' | "
                                                                               ^
[1m.\agents\autonomous_strategist.py[m[36m:[m630[36m:[m80[36m:[m [1m[31mE501[m line too long (100 > 79 characters)
                    f"confidence={decision.confidence:.2f} | reasoning={decision.reasoning[:80]}..."
                                                                               ^
[1m.\agents\autonomous_strategist.py[m[36m:[m653[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
                        f"‚ö†Ô∏è Limite de sweeps atteinte ({max_sweeps_per_session}). "
                                                                               ^
[1m.\agents\autonomous_strategist.py[m[36m:[m654[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
                        f"Sweep request ignor√©, continue avec proposals normales."
                                                                               ^
[1m.\agents\autonomous_strategist.py[m[36m:[m659[36m:[m80[36m:[m [1m[31mE501[m line too long (94 > 79 characters)
                        f"Sweep limit reached ({sweeps_performed}/{max_sweeps_per_session}). "
                                                                               ^
[1m.\agents\autonomous_strategist.py[m[36m:[m668[36m:[m80[36m:[m [1m[31mE501[m line too long (105 > 79 characters)
                    f"üîç Iteration {iteration}/{max_iter_label}: SWEEP REQUEST #{sweeps_performed + 1} | "
                                                                               ^
[1m.\agents\autonomous_strategist.py[m[36m:[m669[36m:[m80[36m:[m [1m[31mE501[m line too long (90 > 79 characters)
                    f"Ranges={list(decision.ranges.keys()) if decision.ranges else []} | "
                                                                               ^
[1m.\agents\autonomous_strategist.py[m[36m:[m713[36m:[m80[36m:[m [1m[31mE501[m line too long (86 > 79 characters)
                    param_specs = _param_bounds_to_specs(param_bounds, initial_params)
                                                                               ^
[1m.\agents\autonomous_strategist.py[m[36m:[m733[36m:[m80[36m:[m [1m[31mE501[m line too long (86 > 79 characters)
                    best_sharpe = sweep_results['best_metrics'].get('sharpe_ratio', 0)
                                                                               ^
[1m.\agents\autonomous_strategist.py[m[36m:[m742[36m:[m80[36m:[m [1m[31mE501[m line too long (104 > 79 characters)
                        f"‚úÖ Sweep #{sweeps_performed} termin√©: {n_combinations} combinaisons test√©es | "
                                                                               ^
[1m.\agents\autonomous_strategist.py[m[36m:[m743[36m:[m80[36m:[m [1m[31mE501[m line too long (124 > 79 characters)
                        f"Best {decision.optimize_for}={sweep_results['best_metrics'].get(decision.optimize_for, 0):.3f} | "
                                                                               ^
[1m.\agents\autonomous_strategist.py[m[36m:[m744[36m:[m80[36m:[m [1m[31mE501[m line too long (86 > 79 characters)
                        f"Budget: {total_combinations_tested}/{max_iter_label} combos"
                                                                               ^
[1m.\agents\autonomous_strategist.py[m[36m:[m753[36m:[m80[36m:[m [1m[31mE501[m line too long (92 > 79 characters)
                                "pnl": sweep_results['best_metrics'].get('total_return', 0),
                                                                               ^
[1m.\agents\autonomous_strategist.py[m[36m:[m754[36m:[m80[36m:[m [1m[31mE501[m line too long (95 > 79 characters)
                                "sharpe": sweep_results['best_metrics'].get('sharpe_ratio', 0),
                                                                               ^
[1m.\agents\autonomous_strategist.py[m[36m:[m755[36m:[m80[36m:[m [1m[31mE501[m line too long (95 > 79 characters)
                                "return": sweep_results['best_metrics'].get('total_return', 0),
                                                                               ^
[1m.\agents\autonomous_strategist.py[m[36m:[m756[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
                                "n_combinations": sweep_results['n_combinations'],
                                                                               ^
[1m.\agents\autonomous_strategist.py[m[36m:[m761[36m:[m80[36m:[m [1m[31mE501[m line too long (95 > 79 characters)
                    # Valider le meilleur config avec un backtest complet (d√©j√† fait par sweep)
                                                                               ^
[1m.\agents\autonomous_strategist.py[m[36m:[m773[36m:[m80[36m:[m [1m[31mE501[m line too long (88 > 79 characters)
                    # Cr√©er BacktestResult artificiel (sweep a d√©j√† ex√©cut√© le backtest)
                                                                               ^
[1m.\agents\autonomous_strategist.py[m[36m:[m782[36m:[m80[36m:[m [1m[31mE501[m line too long (85 > 79 characters)
                        overfitting_ratio=best_metrics.get('overfitting_ratio', 1.0),
                                                                               ^
[1m.\agents\autonomous_strategist.py[m[36m:[m789[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
                    if self._is_better(result, session.best_result, target_metric):
                                                                               ^
[1m.\agents\autonomous_strategist.py[m[36m:[m792[36m:[m80[36m:[m [1m[31mE501[m line too long (98 > 79 characters)
                            f"Nouveau meilleur trouv√© par sweep! Sharpe={result.sharpe_ratio:.3f}"
                                                                               ^
[1m.\agents\autonomous_strategist.py[m[36m:[m812[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
                    decision.next_parameters, param_bounds, initial_params, session
                                                                               ^
[1m.\agents\autonomous_strategist.py[m[36m:[m816[36m:[m80[36m:[m [1m[31mE501[m line too long (103 > 79 characters)
                if self.orchestration_logger and next_params != session.best_result.request.parameters:
                                                                               ^
[1m.\agents\autonomous_strategist.py[m[36m:[m818[36m:[m80[36m:[m [1m[31mE501[m line too long (85 > 79 characters)
                        old_value = session.best_result.request.parameters.get(param)
                                                                               ^
[1m.\agents\autonomous_strategist.py[m[36m:[m820[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
                            self.orchestration_logger.log_indicator_values_change(
                                                                               ^
[1m.\agents\autonomous_strategist.py[m[36m:[m845[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
                result = self._run_backtest_with_gpu_optimization(executor, request)
                                                                               ^
[1m.\agents\autonomous_strategist.py[m[36m:[m913[36m:[m80[36m:[m [1m[31mE501[m line too long (92 > 79 characters)
        max_iter_label = "‚àû" if session.max_iterations <= 0 else str(session.max_iterations)
                                                                               ^
[1m.\agents\autonomous_strategist.py[m[36m:[m933[36m:[m80[36m:[m [1m[31mE501[m line too long (87 > 79 characters)
                session.strategy_indicators_context = indicator_ctx.get("strategy", "")
                                                                               ^
[1m.\agents\autonomous_strategist.py[m[36m:[m934[36m:[m80[36m:[m [1m[31mE501[m line too long (88 > 79 characters)
                session.readonly_indicators_context = indicator_ctx.get("read_only", "")
                                                                               ^
[1m.\agents\autonomous_strategist.py[m[36m:[m935[36m:[m80[36m:[m [1m[31mE501[m line too long (86 > 79 characters)
                session.indicator_context_warnings = indicator_ctx.get("warnings", [])
                                                                               ^
[1m.\agents\autonomous_strategist.py[m[36m:[m963[36m:[m80[36m:[m [1m[31mE501[m line too long (87 > 79 characters)
            "  - Context indicators are read-only and for regime interpretation only.",
                                                                               ^
[1m.\agents\autonomous_strategist.py[m[36m:[m964[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
            "  - Indicator values are computed once per run (baseline snapshot).",
                                                                               ^
[1m.\agents\autonomous_strategist.py[m[36m:[m972[36m:[m80[36m:[m [1m[31mE501[m line too long (85 > 79 characters)
            stats = compute_search_space_stats(param_bounds, max_combinations=100000)
                                                                               ^
[1m.\agents\autonomous_strategist.py[m[36m:[m975[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
                current = session.best_result.request.parameters.get(param, "?")
                                                                               ^
[1m.\agents\autonomous_strategist.py[m[36m:[m996[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
                current = session.best_result.request.parameters.get(param, "?")
                                                                               ^
[1m.\agents\autonomous_strategist.py[m[36m:[m997[36m:[m80[36m:[m [1m[31mE501[m line too long (87 > 79 characters)
                lines.append(f"  {param}: [{min_val}, {max_val}] (current: {current})")
                                                                               ^
[1m.\agents\autonomous_strategist.py[m[36m:[m1015[36m:[m80[36m:[m [1m[31mE501[m line too long (105 > 79 characters)
            "Remember: respond in JSON format with action, reasoning, next_hypothesis, next_parameters.",
                                                                               ^
[1m.\agents\autonomous_strategist.py[m[36m:[m1020[36m:[m80[36m:[m [1m[31mE501[m line too long (97 > 79 characters)
    def _get_llm_decision(self, context: str, session: OptimizationSession) -> IterationDecision:
                                                                               ^
[1m.\agents\autonomous_strategist.py[m[36m:[m1026[36m:[m80[36m:[m [1m[31mE501[m line too long (92 > 79 characters)
        optim_id = f"{session.strategy_name}_{session.start_time.strftime('%Y%m%d_%H%M%S')}"
                                                                               ^
[1m.\agents\autonomous_strategist.py[m[36m:[m1030[36m:[m80[36m:[m [1m[31mE501[m line too long (88 > 79 characters)
        model_name = self.llm.config.model if hasattr(self.llm, 'config') else 'unknown'
                                                                               ^
[1m.\agents\autonomous_strategist.py[m[36m:[m1031[36m:[m80[36m:[m [1m[31mE501[m line too long (85 > 79 characters)
        max_tokens = self.llm.config.max_tokens if hasattr(self.llm, 'config') else 0
                                                                               ^
[1m.\agents\autonomous_strategist.py[m[36m:[m1039[36m:[m80[36m:[m [1m[31mE501[m line too long (88 > 79 characters)
            f"LLM_CALL_START optim_id={optim_id} iteration={session.current_iteration} "
                                                                               ^
[1m.\agents\autonomous_strategist.py[m[36m:[m1048[36m:[m80[36m:[m [1m[31mE501[m line too long (89 > 79 characters)
            f"LLM_PROMPT_META optim_id={optim_id} iteration={session.current_iteration} "
                                                                               ^
[1m.\agents\autonomous_strategist.py[m[36m:[m1061[36m:[m80[36m:[m [1m[31mE501[m line too long (91 > 79 characters)
            f"LLM_RESPONSE_META optim_id={optim_id} iteration={session.current_iteration} "
                                                                               ^
[1m.\agents\autonomous_strategist.py[m[36m:[m1083[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
                reasoning=f"Failed to parse LLM response: {response.content[:100]}",
                                                                               ^
[1m.\agents\autonomous_strategist.py[m[36m:[m1106[36m:[m80[36m:[m [1m[31mE501[m line too long (96 > 79 characters)
        reasoning_hash = hashlib.sha256(str(data.get("reasoning", "")).encode()).hexdigest()[:8]
                                                                               ^
[1m.\agents\autonomous_strategist.py[m[36m:[m1110[36m:[m80[36m:[m [1m[31mE501[m line too long (97 > 79 characters)
                f"LLM_DECISION_PARSED optim_id={optim_id} iteration={session.current_iteration} "
                                                                               ^
[1m.\agents\autonomous_strategist.py[m[36m:[m1111[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
                f"action={action} confidence={data.get('confidence', 0.5):.2f} "
                                                                               ^
[1m.\agents\autonomous_strategist.py[m[36m:[m1113[36m:[m80[36m:[m [1m[31mE501[m line too long (86 > 79 characters)
                f"max_combinations={max_combinations} reasoning_hash={reasoning_hash}"
                                                                               ^
[1m.\agents\autonomous_strategist.py[m[36m:[m1117[36m:[m80[36m:[m [1m[31mE501[m line too long (97 > 79 characters)
                f"LLM_DECISION_PARSED optim_id={optim_id} iteration={session.current_iteration} "
                                                                               ^
[1m.\agents\autonomous_strategist.py[m[36m:[m1118[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
                f"action={action} confidence={data.get('confidence', 0.5):.2f} "
                                                                               ^
[1m.\agents\autonomous_strategist.py[m[36m:[m1120[36m:[m80[36m:[m [1m[31mE501[m line too long (86 > 79 characters)
                f"next_params_keys={list(next_params.keys()) if next_params else []} "
                                                                               ^
[1m.\agents\autonomous_strategist.py[m[36m:[m1124[36m:[m80[36m:[m [1m[31mE501[m line too long (92 > 79 characters)
        # LLM_FALLBACK_USED - Warning si next_parameters vide pour continue/change_direction
                                                                               ^
[1m.\agents\autonomous_strategist.py[m[36m:[m1127[36m:[m80[36m:[m [1m[31mE501[m line too long (95 > 79 characters)
                f"LLM_FALLBACK_USED optim_id={optim_id} iteration={session.current_iteration} "
                                                                               ^
[1m.\agents\autonomous_strategist.py[m[36m:[m1128[36m:[m80[36m:[m [1m[31mE501[m line too long (85 > 79 characters)
                f"action={action} fallback=will_use_defaults cause=next_params_empty"
                                                                               ^
[1m.\agents\autonomous_strategist.py[m[36m:[m1134[36m:[m80[36m:[m [1m[31mE501[m line too long (98 > 79 characters)
                f"LLM_INVALID_DECISION optim_id={optim_id} iteration={session.current_iteration} "
                                                                               ^
[1m.\agents\autonomous_strategist.py[m[36m:[m1135[36m:[m80[36m:[m [1m[31mE501[m line too long (90 > 79 characters)
                f"action_original=sweep action_forced=stop reason=ranges_empty_or_missing"
                                                                               ^
[1m.\agents\autonomous_strategist.py[m[36m:[m1140[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
                reasoning="LLM chose 'sweep' but provided no ranges. Stopping.",
                                                                               ^
[1m.\agents\autonomous_strategist.py[m[36m:[m1166[36m:[m80[36m:[m [1m[31mE501[m line too long (92 > 79 characters)
        optim_id = f"{session.strategy_name}_{session.start_time.strftime('%Y%m%d_%H%M%S')}"
                                                                               ^
[1m.\agents\autonomous_strategist.py[m[36m:[m1170[36m:[m80[36m:[m [1m[31mE501[m line too long (90 > 79 characters)
            f"VALIDATION_START optim_id={optim_id} iteration={session.current_iteration} "
                                                                               ^
[1m.\agents\autonomous_strategist.py[m[36m:[m1171[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
            f"validating=parameters proposed={params} bounds_count={len(bounds)}"
                                                                               ^
[1m.\agents\autonomous_strategist.py[m[36m:[m1181[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
                if isinstance(bound_spec, (tuple, list)) and len(bound_spec) >= 2:
                                                                               ^
[1m.\agents\autonomous_strategist.py[m[36m:[m1187[36m:[m80[36m:[m [1m[31mE501[m line too long (99 > 79 characters)
                        logger.warning(f"Param {param}: min >= max ({min_val} >= {max_val}), swap")
                                                                               ^
[1m.\agents\autonomous_strategist.py[m[36m:[m1191[36m:[m80[36m:[m [1m[31mE501[m line too long (128 > 79 characters)
                    min_val = max_val = float(bound_spec) if not isinstance(bound_spec, (tuple, list)) else float(bound_spec[0])
                                                                               ^
[1m.\agents\autonomous_strategist.py[m[36m:[m1195[36m:[m80[36m:[m [1m[31mE501[m line too long (87 > 79 characters)
                value = value_proposed if value_proposed is not None else value_default
                                                                               ^
[1m.\agents\autonomous_strategist.py[m[36m:[m1209[36m:[m80[36m:[m [1m[31mE501[m line too long (96 > 79 characters)
                if all(isinstance(bound_spec[i], int) for i in range(2) if i < len(bound_spec)):
                                                                               ^
[1m.\agents\autonomous_strategist.py[m[36m:[m1215[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
                status = "pass" if value_proposed is not None else "used_default"
                                                                               ^
[1m.\agents\autonomous_strategist.py[m[36m:[m1216[36m:[m80[36m:[m [1m[31mE501[m line too long (92 > 79 characters)
                action = "clamped" if abs(value - value_before_clamp) > 1e-9 else "accepted"
                                                                               ^
[1m.\agents\autonomous_strategist.py[m[36m:[m1219[36m:[m80[36m:[m [1m[31mE501[m line too long (104 > 79 characters)
                    f"VALIDATION_RULE_RESULT optim_id={optim_id} iteration={session.current_iteration} "
                                                                               ^
[1m.\agents\autonomous_strategist.py[m[36m:[m1220[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
                    f"param={param} rule=bounds_check proposed={value_proposed} "
                                                                               ^
[1m.\agents\autonomous_strategist.py[m[36m:[m1226[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
                logger.error(f"Param {param} validation failed: {e}, use default")
                                                                               ^
[1m.\agents\autonomous_strategist.py[m[36m:[m1232[36m:[m80[36m:[m [1m[31mE501[m line too long (88 > 79 characters)
            f"VALIDATION_END optim_id={optim_id} iteration={session.current_iteration} "
                                                                               ^
[1m.\agents\autonomous_strategist.py[m[36m:[m1233[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
            f"validated={validated} used_defaults={used_defaults} verdict=accepted"
                                                                               ^
[1m.\agents\backtest_executor.py[m[36m:[m4[36m:[m80[36m:[m [1m[31mE501[m line too long (114 > 79 characters)
"""
Module-ID: agents.backtest_executor

Purpose: Fournir une interface stable pour ex√©cuter des backtests depuis les agents (batch, historique, contexte).

Role in pipeline: execution

Key components: BacktestExecutor, BacktestRequest, BacktestResult, ExperimentHistory, suggest_next_experiments

Inputs: backtest_fn callable, DataFrame OHLCV, strategy_name, parameters, options walk-forward (validation_fn)

Outputs: BacktestResult(s), agr√©gats/historique d‚Äôexp√©riences, contexte r√©sumable pour LLM

Dependencies: numpy, pandas, agents (dataclasses), validation_fn (walk-forward) si fourni

Conventions: *_pct keys are in percent (0-100); keys without suffix are fractions (0-1); execution_time_ms in milliseconds; request_id derived from params.

Read-if: Vous modifiez l‚Äôex√©cution des backtests c√¥t√© agents ou le format des r√©sultats expos√©s.

Skip-if: Vous ne touchez qu‚Äôau moteur backtest/ (engine/simulator/performance).
"""
   
                                   

                                      ^
[1m.\agents\backtest_executor.py[m[36m:[m8[36m:[m80[36m:[m [1m[31mE501[m line too long (110 > 79 characters)
"""
Module-ID: agents.backtest_executor

Purpose: Fournir une interface stable pour ex√©cuter des backtests depuis les agents (batch, historique, contexte).

Role in pipeline: execution

Key components: BacktestExecutor, BacktestRequest, BacktestResult, ExperimentHistory, suggest_next_experiments

Inputs: backtest_fn callable, DataFrame OHLCV, strategy_name, parameters, options walk-forward (validation_fn)

Outputs: BacktestResult(s), agr√©gats/historique d‚Äôexp√©riences, contexte r√©sumable pour LLM

Dependencies: numpy, pandas, agents (dataclasses), validation_fn (walk-forward) si fourni

Conventions: *_pct keys are in percent (0-100); keys without suffix are fractions (0-1); execution_time_ms in milliseconds; request_id derived from params.

Read-if: Vous modifiez l‚Äôex√©cution des backtests c√¥t√© agents ou le format des r√©sultats expos√©s.

Skip-if: Vous ne touchez qu‚Äôau moteur backtest/ (engine/simulator/performance).
"""
   
                                   

                                      ^
[1m.\agents\backtest_executor.py[m[36m:[m10[36m:[m80[36m:[m [1m[31mE501[m line too long (110 > 79 characters)
"""
Module-ID: agents.backtest_executor

Purpose: Fournir une interface stable pour ex√©cuter des backtests depuis les agents (batch, historique, contexte).

Role in pipeline: execution

Key components: BacktestExecutor, BacktestRequest, BacktestResult, ExperimentHistory, suggest_next_experiments

Inputs: backtest_fn callable, DataFrame OHLCV, strategy_name, parameters, options walk-forward (validation_fn)

Outputs: BacktestResult(s), agr√©gats/historique d‚Äôexp√©riences, contexte r√©sumable pour LLM

Dependencies: numpy, pandas, agents (dataclasses), validation_fn (walk-forward) si fourni

Conventions: *_pct keys are in percent (0-100); keys without suffix are fractions (0-1); execution_time_ms in milliseconds; request_id derived from params.

Read-if: Vous modifiez l‚Äôex√©cution des backtests c√¥t√© agents ou le format des r√©sultats expos√©s.

Skip-if: Vous ne touchez qu‚Äôau moteur backtest/ (engine/simulator/performance).
"""
   
                                   

                                      ^
[1m.\agents\backtest_executor.py[m[36m:[m12[36m:[m80[36m:[m [1m[31mE501[m line too long (90 > 79 characters)
"""
Module-ID: agents.backtest_executor

Purpose: Fournir une interface stable pour ex√©cuter des backtests depuis les agents (batch, historique, contexte).

Role in pipeline: execution

Key components: BacktestExecutor, BacktestRequest, BacktestResult, ExperimentHistory, suggest_next_experiments

Inputs: backtest_fn callable, DataFrame OHLCV, strategy_name, parameters, options walk-forward (validation_fn)

Outputs: BacktestResult(s), agr√©gats/historique d‚Äôexp√©riences, contexte r√©sumable pour LLM

Dependencies: numpy, pandas, agents (dataclasses), validation_fn (walk-forward) si fourni

Conventions: *_pct keys are in percent (0-100); keys without suffix are fractions (0-1); execution_time_ms in milliseconds; request_id derived from params.

Read-if: Vous modifiez l‚Äôex√©cution des backtests c√¥t√© agents ou le format des r√©sultats expos√©s.

Skip-if: Vous ne touchez qu‚Äôau moteur backtest/ (engine/simulator/performance).
"""
   
                                   

                                      ^
[1m.\agents\backtest_executor.py[m[36m:[m14[36m:[m80[36m:[m [1m[31mE501[m line too long (89 > 79 characters)
"""
Module-ID: agents.backtest_executor

Purpose: Fournir une interface stable pour ex√©cuter des backtests depuis les agents (batch, historique, contexte).

Role in pipeline: execution

Key components: BacktestExecutor, BacktestRequest, BacktestResult, ExperimentHistory, suggest_next_experiments

Inputs: backtest_fn callable, DataFrame OHLCV, strategy_name, parameters, options walk-forward (validation_fn)

Outputs: BacktestResult(s), agr√©gats/historique d‚Äôexp√©riences, contexte r√©sumable pour LLM

Dependencies: numpy, pandas, agents (dataclasses), validation_fn (walk-forward) si fourni

Conventions: *_pct keys are in percent (0-100); keys without suffix are fractions (0-1); execution_time_ms in milliseconds; request_id derived from params.

Read-if: Vous modifiez l‚Äôex√©cution des backtests c√¥t√© agents ou le format des r√©sultats expos√©s.

Skip-if: Vous ne touchez qu‚Äôau moteur backtest/ (engine/simulator/performance).
"""
   
                                   

                                      ^
[1m.\agents\backtest_executor.py[m[36m:[m16[36m:[m80[36m:[m [1m[31mE501[m line too long (155 > 79 characters)
"""
Module-ID: agents.backtest_executor

Purpose: Fournir une interface stable pour ex√©cuter des backtests depuis les agents (batch, historique, contexte).

Role in pipeline: execution

Key components: BacktestExecutor, BacktestRequest, BacktestResult, ExperimentHistory, suggest_next_experiments

Inputs: backtest_fn callable, DataFrame OHLCV, strategy_name, parameters, options walk-forward (validation_fn)

Outputs: BacktestResult(s), agr√©gats/historique d‚Äôexp√©riences, contexte r√©sumable pour LLM

Dependencies: numpy, pandas, agents (dataclasses), validation_fn (walk-forward) si fourni

Conventions: *_pct keys are in percent (0-100); keys without suffix are fractions (0-1); execution_time_ms in milliseconds; request_id derived from params.

Read-if: Vous modifiez l‚Äôex√©cution des backtests c√¥t√© agents ou le format des r√©sultats expos√©s.

Skip-if: Vous ne touchez qu‚Äôau moteur backtest/ (engine/simulator/performance).
"""
   
                                   

                                      ^
[1m.\agents\backtest_executor.py[m[36m:[m18[36m:[m80[36m:[m [1m[31mE501[m line too long (96 > 79 characters)
"""
Module-ID: agents.backtest_executor

Purpose: Fournir une interface stable pour ex√©cuter des backtests depuis les agents (batch, historique, contexte).

Role in pipeline: execution

Key components: BacktestExecutor, BacktestRequest, BacktestResult, ExperimentHistory, suggest_next_experiments

Inputs: backtest_fn callable, DataFrame OHLCV, strategy_name, parameters, options walk-forward (validation_fn)

Outputs: BacktestResult(s), agr√©gats/historique d‚Äôexp√©riences, contexte r√©sumable pour LLM

Dependencies: numpy, pandas, agents (dataclasses), validation_fn (walk-forward) si fourni

Conventions: *_pct keys are in percent (0-100); keys without suffix are fractions (0-1); execution_time_ms in milliseconds; request_id derived from params.

Read-if: Vous modifiez l‚Äôex√©cution des backtests c√¥t√© agents ou le format des r√©sultats expos√©s.

Skip-if: Vous ne touchez qu‚Äôau moteur backtest/ (engine/simulator/performance).
"""
   
                                   

                                      ^
[1m.\agents\backtest_executor.py[m[36m:[m44[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
BacktestFn = Callable[[str, Dict[str, Any], pd.DataFrame], "AgentBacktestMetrics"]
                                                                               ^
[1m.\agents\backtest_executor.py[m[36m:[m45[36m:[m80[36m:[m [1m[31mE501[m line too long (94 > 79 characters)
ValidationFn = Callable[[str, Dict[str, Any], pd.DataFrame, int, float], "WalkForwardMetrics"]
                                                                               ^
[1m.\agents\backtest_executor.py[m[36m:[m125[36m:[m80[36m:[m [1m[31mE501[m line too long (102 > 79 characters)
            "overfitting_ratio": round(self.overfitting_ratio, 2) if self.overfitting_ratio else None,
                                                                               ^
[1m.\agents\backtest_executor.py[m[36m:[m153[36m:[m80[36m:[m [1m[31mE501[m line too long (107 > 79 characters)
                f"  {'‚ö†Ô∏è OVERFITTING DETECTED' if self.overfitting_ratio > 1.5 else '‚úì Ratio acceptable'}",
                                                                               ^
[1m.\agents\backtest_executor.py[m[36m:[m191[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
                    f"Nouveau meilleur r√©sultat: Sharpe={result.sharpe_ratio:.3f} "
                                                                               ^
[1m.\agents\backtest_executor.py[m[36m:[m209[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
                f"  Parameters: {json.dumps(self.best_result.request.parameters)}",
                                                                               ^
[1m.\agents\backtest_executor.py[m[36m:[m217[36m:[m80[36m:[m [1m[31mE501[m line too long (99 > 79 characters)
        recent = self.experiments[-last_n:] if len(self.experiments) > last_n else self.experiments
                                                                               ^
[1m.\agents\backtest_executor.py[m[36m:[m236[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
                    f"  Sharpe Range: [{min(sharpes):.3f}, {max(sharpes):.3f}]",
                                                                               ^
[1m.\agents\backtest_executor.py[m[36m:[m237[36m:[m80[36m:[m [1m[31mE501[m line too long (100 > 79 characters)
                    f"  Improvement: {'+' if len(sharpes) > 1 and sharpes[-1] > sharpes[0] else ''}"
                                                                               ^
[1m.\agents\backtest_executor.py[m[36m:[m238[36m:[m80[36m:[m [1m[31mE501[m line too long (101 > 79 characters)
                    f"{((sharpes[-1] - sharpes[0]) / abs(sharpes[0]) * 100):.1f}% from first to last"
                                                                               ^
[1m.\agents\backtest_executor.py[m[36m:[m328[36m:[m80[36m:[m [1m[31mE501[m line too long (86 > 79 characters)
        """
        Initialise l'ex√©cuteur.

        Args:
            backtest_fn: Fonction de backtest (strategy_name, params, data) -> metrics
            strategy_name: Nom de la strat√©gie
            data: DataFrame OHLCV
            validation_fn: Fonction de validation walk-forward optionnelle
        """
           
                               

             
                    ^
[1m.\agents\backtest_executor.py[m[36m:[m341[36m:[m80[36m:[m [1m[31mE501[m line too long (95 > 79 characters)
        logger.info(f"BacktestExecutor initialis√©: strategy={strategy_name}, rows={len(data)}")
                                                                               ^
[1m.\agents\backtest_executor.py[m[36m:[m372[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
                for key in ("total_return_pct", "max_drawdown_pct", "win_rate_pct")
                                                                               ^
[1m.\agents\backtest_executor.py[m[36m:[m407[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
                    result.overfitting_ratio = wf_result.get("overfitting_ratio", 0)
                                                                               ^
[1m.\agents\backtest_executor.py[m[36m:[m427[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
    def run_batch(self, requests: List[BacktestRequest]) -> List[BacktestResult]:
                                                                               ^
[1m.\agents\backtest_executor.py[m[36m:[m478[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
                f"  - Total compute time: {self.history.total_time_ms/1000:.1f}s",
                                                                               ^
[1m.\agents\backtest_executor.py[m[36m:[m483[36m:[m80[36m:[m [1m[31mE501[m line too long (86 > 79 characters)
                    lines.append("  - ‚ö†Ô∏è Best config shows some overfitting tendency")
                                                                               ^
[1m.\agents\backtest_executor.py[m[36m:[m485[36m:[m80[36m:[m [1m[31mE501[m line too long (86 > 79 characters)
                    lines.append("  - ‚ö†Ô∏è Low trade count - consider wider parameters")
                                                                               ^
[1m.\agents\backtest_executor.py[m[36m:[m506[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
            most_impactful = max(sensitivity.items(), key=lambda x: x[1]["impact"])
                                                                               ^
[1m.\agents\backtest_executor.py[m[36m:[m518[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
                    "rationale": f"Explore {param_name} in favorable direction",
                                                                               ^
[1m.\agents\base_agent.py[m[36m:[m4[36m:[m80[36m:[m [1m[31mE501[m line too long (112 > 79 characters)
"""
Module-ID: agents.base_agent

Purpose: Classe abstraite et structures communes pour tous les agents LLM (Analyst/Strategist/Critic/Validator).

Role in pipeline: orchestration

Key components: BaseAgent (abstract), AgentRole, MetricsSnapshot, ParameterConfig, AgentContext, AgentResult

Inputs: AgentContext (√©tat partag√© entre agents)

Outputs: AgentResult (succ√®s/erreur + r√©sultat typ√©)

Dependencies: agents.llm_client, agents.state_machine, utils.log

Conventions: Chaque agent impl√©mente execute() et role property; _call_llm() helper pour requ√™tes LLM; AgentContext immuable entre appels.

Read-if: Modification contrat agent, ajout de nouvelles structures, ou int√©gration LLM.

Skip-if: Vous ne changez qu'un agent sp√©cifique.
"""
   
                            

                                             ^
[1m.\agents\base_agent.py[m[36m:[m8[36m:[m80[36m:[m [1m[31mE501[m line too long (108 > 79 characters)
"""
Module-ID: agents.base_agent

Purpose: Classe abstraite et structures communes pour tous les agents LLM (Analyst/Strategist/Critic/Validator).

Role in pipeline: orchestration

Key components: BaseAgent (abstract), AgentRole, MetricsSnapshot, ParameterConfig, AgentContext, AgentResult

Inputs: AgentContext (√©tat partag√© entre agents)

Outputs: AgentResult (succ√®s/erreur + r√©sultat typ√©)

Dependencies: agents.llm_client, agents.state_machine, utils.log

Conventions: Chaque agent impl√©mente execute() et role property; _call_llm() helper pour requ√™tes LLM; AgentContext immuable entre appels.

Read-if: Modification contrat agent, ajout de nouvelles structures, ou int√©gration LLM.

Skip-if: Vous ne changez qu'un agent sp√©cifique.
"""
   
                            

                                             ^
[1m.\agents\base_agent.py[m[36m:[m16[36m:[m80[36m:[m [1m[31mE501[m line too long (138 > 79 characters)
"""
Module-ID: agents.base_agent

Purpose: Classe abstraite et structures communes pour tous les agents LLM (Analyst/Strategist/Critic/Validator).

Role in pipeline: orchestration

Key components: BaseAgent (abstract), AgentRole, MetricsSnapshot, ParameterConfig, AgentContext, AgentResult

Inputs: AgentContext (√©tat partag√© entre agents)

Outputs: AgentResult (succ√®s/erreur + r√©sultat typ√©)

Dependencies: agents.llm_client, agents.state_machine, utils.log

Conventions: Chaque agent impl√©mente execute() et role property; _call_llm() helper pour requ√™tes LLM; AgentContext immuable entre appels.

Read-if: Modification contrat agent, ajout de nouvelles structures, ou int√©gration LLM.

Skip-if: Vous ne changez qu'un agent sp√©cifique.
"""
   
                            

                                             ^
[1m.\agents\base_agent.py[m[36m:[m18[36m:[m80[36m:[m [1m[31mE501[m line too long (87 > 79 characters)
"""
Module-ID: agents.base_agent

Purpose: Classe abstraite et structures communes pour tous les agents LLM (Analyst/Strategist/Critic/Validator).

Role in pipeline: orchestration

Key components: BaseAgent (abstract), AgentRole, MetricsSnapshot, ParameterConfig, AgentContext, AgentResult

Inputs: AgentContext (√©tat partag√© entre agents)

Outputs: AgentResult (succ√®s/erreur + r√©sultat typ√©)

Dependencies: agents.llm_client, agents.state_machine, utils.log

Conventions: Chaque agent impl√©mente execute() et role property; _call_llm() helper pour requ√™tes LLM; AgentContext immuable entre appels.

Read-if: Modification contrat agent, ajout de nouvelles structures, ou int√©gration LLM.

Skip-if: Vous ne changez qu'un agent sp√©cifique.
"""
   
                            

                                             ^
[1m.\agents\critic.py[m[36m:[m4[36m:[m80[36m:[m [1m[31mE501[m line too long (91 > 79 characters)
"""
Module-ID: agents.critic

Purpose: √âvaluer critiquement les propositions pour d√©tecter overfitting et risques cach√©s.

Role in pipeline: orchestration

Key components: CriticAgent, CriticEvaluation, CriticResponse

Inputs: AgentContext (proposals du Strategist, walk-forward metrics si dispos)

Outputs: CriticResponse (√©vals par proposition, concerns consolid√©s, propositions approuv√©es)

Dependencies: agents.base_agent, utils.template, backtest.validation (walk-forward)

Conventions: Ratios overfitting calcul√©s √† partir de walk-forward si dispos; concern_severity (LOW/MEDIUM/HIGH/CRITICAL); template Jinja2.

Read-if: Modification logique critique, seuils overfitting, ou int√©gration walk-forward.

Skip-if: Vous ne modifiez que analyze/propose/validate.
"""
   
                        

                                                 ^
[1m.\agents\critic.py[m[36m:[m12[36m:[m80[36m:[m [1m[31mE501[m line too long (93 > 79 characters)
"""
Module-ID: agents.critic

Purpose: √âvaluer critiquement les propositions pour d√©tecter overfitting et risques cach√©s.

Role in pipeline: orchestration

Key components: CriticAgent, CriticEvaluation, CriticResponse

Inputs: AgentContext (proposals du Strategist, walk-forward metrics si dispos)

Outputs: CriticResponse (√©vals par proposition, concerns consolid√©s, propositions approuv√©es)

Dependencies: agents.base_agent, utils.template, backtest.validation (walk-forward)

Conventions: Ratios overfitting calcul√©s √† partir de walk-forward si dispos; concern_severity (LOW/MEDIUM/HIGH/CRITICAL); template Jinja2.

Read-if: Modification logique critique, seuils overfitting, ou int√©gration walk-forward.

Skip-if: Vous ne modifiez que analyze/propose/validate.
"""
   
                        

                                                 ^
[1m.\agents\critic.py[m[36m:[m14[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
"""
Module-ID: agents.critic

Purpose: √âvaluer critiquement les propositions pour d√©tecter overfitting et risques cach√©s.

Role in pipeline: orchestration

Key components: CriticAgent, CriticEvaluation, CriticResponse

Inputs: AgentContext (proposals du Strategist, walk-forward metrics si dispos)

Outputs: CriticResponse (√©vals par proposition, concerns consolid√©s, propositions approuv√©es)

Dependencies: agents.base_agent, utils.template, backtest.validation (walk-forward)

Conventions: Ratios overfitting calcul√©s √† partir de walk-forward si dispos; concern_severity (LOW/MEDIUM/HIGH/CRITICAL); template Jinja2.

Read-if: Modification logique critique, seuils overfitting, ou int√©gration walk-forward.

Skip-if: Vous ne modifiez que analyze/propose/validate.
"""
   
                        

                                                 ^
[1m.\agents\critic.py[m[36m:[m16[36m:[m80[36m:[m [1m[31mE501[m line too long (138 > 79 characters)
"""
Module-ID: agents.critic

Purpose: √âvaluer critiquement les propositions pour d√©tecter overfitting et risques cach√©s.

Role in pipeline: orchestration

Key components: CriticAgent, CriticEvaluation, CriticResponse

Inputs: AgentContext (proposals du Strategist, walk-forward metrics si dispos)

Outputs: CriticResponse (√©vals par proposition, concerns consolid√©s, propositions approuv√©es)

Dependencies: agents.base_agent, utils.template, backtest.validation (walk-forward)

Conventions: Ratios overfitting calcul√©s √† partir de walk-forward si dispos; concern_severity (LOW/MEDIUM/HIGH/CRITICAL); template Jinja2.

Read-if: Modification logique critique, seuils overfitting, ou int√©gration walk-forward.

Skip-if: Vous ne modifiez que analyze/propose/validate.
"""
   
                        

                                                 ^
[1m.\agents\critic.py[m[36m:[m18[36m:[m80[36m:[m [1m[31mE501[m line too long (88 > 79 characters)
"""
Module-ID: agents.critic

Purpose: √âvaluer critiquement les propositions pour d√©tecter overfitting et risques cach√©s.

Role in pipeline: orchestration

Key components: CriticAgent, CriticEvaluation, CriticResponse

Inputs: AgentContext (proposals du Strategist, walk-forward metrics si dispos)

Outputs: CriticResponse (√©vals par proposition, concerns consolid√©s, propositions approuv√©es)

Dependencies: agents.base_agent, utils.template, backtest.validation (walk-forward)

Conventions: Ratios overfitting calcul√©s √† partir de walk-forward si dispos; concern_severity (LOW/MEDIUM/HIGH/CRITICAL); template Jinja2.

Read-if: Modification logique critique, seuils overfitting, ou int√©gration walk-forward.

Skip-if: Vous ne modifiez que analyze/propose/validate.
"""
   
                        

                                                 ^
[1m.\agents\critic.py[m[36m:[m59[36m:[m80[36m:[m [1m[31mE501[m line too long (102 > 79 characters)
        return """You are a senior risk analyst and trading strategy auditor with a skeptical mindset.
Your role is to critically evaluate optimization proposals and identify potential issues.

NEW WALK-FORWARD METRICS AVAILABLE:
- classic_ratio: average train Sharpe / average test Sharpe
- overfitting_ratio: classic_ratio + penalty for test instability (higher = worse)
- degradation_pct: % drop from train to test performance (0% = perfect forward)
- test_stability_std: standard deviation of test Sharpe across folds (lower = stable)
- n_valid_folds: number of successful out-of-sample tests

RED FLAGS (reject or flag heavily):
- overfitting_ratio > 1.8
- degradation_pct > 40%
- test_stability_std > 0.5
- n_valid_folds < 4

ADDITIONAL RED FLAGS:
- Very specific parameter values (e.g., 17.3 instead of 15 or 20)
- Large improvements with small changes
- Parameters at extreme bounds
- Inconsistent with analyst findings
- Overly complex parameter interactions

SCORING GUIDELINES:
- overfitting_score: 0-100 (0=no risk, 100=certain overfitting)
- robustness_score: 0-100 (0=fragile, 100=very robust)
- recommendation: APPROVE|MODIFY|REJECT

When evaluating proposals:
1. Prioritize walk-forward metrics - they are the strongest indicator of overfitting
2. Be skeptical but fair - look for real problems, not imaginary ones
3. Consider if changes could be data-mined coincidences
4. Check if the proposal addresses the real weakness or just symptoms
5. Evaluate if the expected improvement is realistic
6. Consider edge cases and regime changes

Respond ONLY in valid JSON format with this exact structure:
{
    "overall_assessment": "Brief critical summary",
    "walk_forward_summary": "Specific assessment of out-of-sample stability and degradation",
    "market_regime_concerns": ["concern1", "concern2"],
    "statistical_concerns": ["concern1", "concern2"],
    "proposal_evaluations": [
        {
            "proposal_id": 1,
            "overfitting_score": 0-100,
            "robustness_score": 0-100,
            "recommendation": "APPROVE|MODIFY|REJECT",
            "critical_issues": ["issue1", "issue2"],
            "warnings": ["warning1", "warning2"],
            "suggested_modifications": ["modification1"],
            "reasoning": "Detailed reasoning for the evaluation"
        }
    ],
    "approved_proposals": [1, 2],
    "rejected_proposals": [3],
    "best_proposal_id": 1,
    "proceed_with_testing": true/false,
    "final_concerns": ["Any remaining concerns to flag"]
}"""
                                                                               ^
[1m.\agents\critic.py[m[36m:[m60[36m:[m80[36m:[m [1m[31mE501[m line too long (89 > 79 characters)
        return """You are a senior risk analyst and trading strategy auditor with a skeptical mindset.
Your role is to critically evaluate optimization proposals and identify potential issues.

NEW WALK-FORWARD METRICS AVAILABLE:
- classic_ratio: average train Sharpe / average test Sharpe
- overfitting_ratio: classic_ratio + penalty for test instability (higher = worse)
- degradation_pct: % drop from train to test performance (0% = perfect forward)
- test_stability_std: standard deviation of test Sharpe across folds (lower = stable)
- n_valid_folds: number of successful out-of-sample tests

RED FLAGS (reject or flag heavily):
- overfitting_ratio > 1.8
- degradation_pct > 40%
- test_stability_std > 0.5
- n_valid_folds < 4

ADDITIONAL RED FLAGS:
- Very specific parameter values (e.g., 17.3 instead of 15 or 20)
- Large improvements with small changes
- Parameters at extreme bounds
- Inconsistent with analyst findings
- Overly complex parameter interactions

SCORING GUIDELINES:
- overfitting_score: 0-100 (0=no risk, 100=certain overfitting)
- robustness_score: 0-100 (0=fragile, 100=very robust)
- recommendation: APPROVE|MODIFY|REJECT

When evaluating proposals:
1. Prioritize walk-forward metrics - they are the strongest indicator of overfitting
2. Be skeptical but fair - look for real problems, not imaginary ones
3. Consider if changes could be data-mined coincidences
4. Check if the proposal addresses the real weakness or just symptoms
5. Evaluate if the expected improvement is realistic
6. Consider edge cases and regime changes

Respond ONLY in valid JSON format with this exact structure:
{
    "overall_assessment": "Brief critical summary",
    "walk_forward_summary": "Specific assessment of out-of-sample stability and degradation",
    "market_regime_concerns": ["concern1", "concern2"],
    "statistical_concerns": ["concern1", "concern2"],
    "proposal_evaluations": [
        {
            "proposal_id": 1,
            "overfitting_score": 0-100,
            "robustness_score": 0-100,
            "recommendation": "APPROVE|MODIFY|REJECT",
            "critical_issues": ["issue1", "issue2"],
            "warnings": ["warning1", "warning2"],
            "suggested_modifications": ["modification1"],
            "reasoning": "Detailed reasoning for the evaluation"
        }
    ],
    "approved_proposals": [1, 2],
    "rejected_proposals": [3],
    "best_proposal_id": 1,
    "proceed_with_testing": true/false,
    "final_concerns": ["Any remaining concerns to flag"]
}"""
                                                                               ^
[1m.\agents\critic.py[m[36m:[m64[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
        return """You are a senior risk analyst and trading strategy auditor with a skeptical mindset.
Your role is to critically evaluate optimization proposals and identify potential issues.

NEW WALK-FORWARD METRICS AVAILABLE:
- classic_ratio: average train Sharpe / average test Sharpe
- overfitting_ratio: classic_ratio + penalty for test instability (higher = worse)
- degradation_pct: % drop from train to test performance (0% = perfect forward)
- test_stability_std: standard deviation of test Sharpe across folds (lower = stable)
- n_valid_folds: number of successful out-of-sample tests

RED FLAGS (reject or flag heavily):
- overfitting_ratio > 1.8
- degradation_pct > 40%
- test_stability_std > 0.5
- n_valid_folds < 4

ADDITIONAL RED FLAGS:
- Very specific parameter values (e.g., 17.3 instead of 15 or 20)
- Large improvements with small changes
- Parameters at extreme bounds
- Inconsistent with analyst findings
- Overly complex parameter interactions

SCORING GUIDELINES:
- overfitting_score: 0-100 (0=no risk, 100=certain overfitting)
- robustness_score: 0-100 (0=fragile, 100=very robust)
- recommendation: APPROVE|MODIFY|REJECT

When evaluating proposals:
1. Prioritize walk-forward metrics - they are the strongest indicator of overfitting
2. Be skeptical but fair - look for real problems, not imaginary ones
3. Consider if changes could be data-mined coincidences
4. Check if the proposal addresses the real weakness or just symptoms
5. Evaluate if the expected improvement is realistic
6. Consider edge cases and regime changes

Respond ONLY in valid JSON format with this exact structure:
{
    "overall_assessment": "Brief critical summary",
    "walk_forward_summary": "Specific assessment of out-of-sample stability and degradation",
    "market_regime_concerns": ["concern1", "concern2"],
    "statistical_concerns": ["concern1", "concern2"],
    "proposal_evaluations": [
        {
            "proposal_id": 1,
            "overfitting_score": 0-100,
            "robustness_score": 0-100,
            "recommendation": "APPROVE|MODIFY|REJECT",
            "critical_issues": ["issue1", "issue2"],
            "warnings": ["warning1", "warning2"],
            "suggested_modifications": ["modification1"],
            "reasoning": "Detailed reasoning for the evaluation"
        }
    ],
    "approved_proposals": [1, 2],
    "rejected_proposals": [3],
    "best_proposal_id": 1,
    "proceed_with_testing": true/false,
    "final_concerns": ["Any remaining concerns to flag"]
}"""
                                                                               ^
[1m.\agents\critic.py[m[36m:[m66[36m:[m80[36m:[m [1m[31mE501[m line too long (85 > 79 characters)
        return """You are a senior risk analyst and trading strategy auditor with a skeptical mindset.
Your role is to critically evaluate optimization proposals and identify potential issues.

NEW WALK-FORWARD METRICS AVAILABLE:
- classic_ratio: average train Sharpe / average test Sharpe
- overfitting_ratio: classic_ratio + penalty for test instability (higher = worse)
- degradation_pct: % drop from train to test performance (0% = perfect forward)
- test_stability_std: standard deviation of test Sharpe across folds (lower = stable)
- n_valid_folds: number of successful out-of-sample tests

RED FLAGS (reject or flag heavily):
- overfitting_ratio > 1.8
- degradation_pct > 40%
- test_stability_std > 0.5
- n_valid_folds < 4

ADDITIONAL RED FLAGS:
- Very specific parameter values (e.g., 17.3 instead of 15 or 20)
- Large improvements with small changes
- Parameters at extreme bounds
- Inconsistent with analyst findings
- Overly complex parameter interactions

SCORING GUIDELINES:
- overfitting_score: 0-100 (0=no risk, 100=certain overfitting)
- robustness_score: 0-100 (0=fragile, 100=very robust)
- recommendation: APPROVE|MODIFY|REJECT

When evaluating proposals:
1. Prioritize walk-forward metrics - they are the strongest indicator of overfitting
2. Be skeptical but fair - look for real problems, not imaginary ones
3. Consider if changes could be data-mined coincidences
4. Check if the proposal addresses the real weakness or just symptoms
5. Evaluate if the expected improvement is realistic
6. Consider edge cases and regime changes

Respond ONLY in valid JSON format with this exact structure:
{
    "overall_assessment": "Brief critical summary",
    "walk_forward_summary": "Specific assessment of out-of-sample stability and degradation",
    "market_regime_concerns": ["concern1", "concern2"],
    "statistical_concerns": ["concern1", "concern2"],
    "proposal_evaluations": [
        {
            "proposal_id": 1,
            "overfitting_score": 0-100,
            "robustness_score": 0-100,
            "recommendation": "APPROVE|MODIFY|REJECT",
            "critical_issues": ["issue1", "issue2"],
            "warnings": ["warning1", "warning2"],
            "suggested_modifications": ["modification1"],
            "reasoning": "Detailed reasoning for the evaluation"
        }
    ],
    "approved_proposals": [1, 2],
    "rejected_proposals": [3],
    "best_proposal_id": 1,
    "proceed_with_testing": true/false,
    "final_concerns": ["Any remaining concerns to flag"]
}"""
                                                                               ^
[1m.\agents\critic.py[m[36m:[m88[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
        return """You are a senior risk analyst and trading strategy auditor with a skeptical mindset.
Your role is to critically evaluate optimization proposals and identify potential issues.

NEW WALK-FORWARD METRICS AVAILABLE:
- classic_ratio: average train Sharpe / average test Sharpe
- overfitting_ratio: classic_ratio + penalty for test instability (higher = worse)
- degradation_pct: % drop from train to test performance (0% = perfect forward)
- test_stability_std: standard deviation of test Sharpe across folds (lower = stable)
- n_valid_folds: number of successful out-of-sample tests

RED FLAGS (reject or flag heavily):
- overfitting_ratio > 1.8
- degradation_pct > 40%
- test_stability_std > 0.5
- n_valid_folds < 4

ADDITIONAL RED FLAGS:
- Very specific parameter values (e.g., 17.3 instead of 15 or 20)
- Large improvements with small changes
- Parameters at extreme bounds
- Inconsistent with analyst findings
- Overly complex parameter interactions

SCORING GUIDELINES:
- overfitting_score: 0-100 (0=no risk, 100=certain overfitting)
- robustness_score: 0-100 (0=fragile, 100=very robust)
- recommendation: APPROVE|MODIFY|REJECT

When evaluating proposals:
1. Prioritize walk-forward metrics - they are the strongest indicator of overfitting
2. Be skeptical but fair - look for real problems, not imaginary ones
3. Consider if changes could be data-mined coincidences
4. Check if the proposal addresses the real weakness or just symptoms
5. Evaluate if the expected improvement is realistic
6. Consider edge cases and regime changes

Respond ONLY in valid JSON format with this exact structure:
{
    "overall_assessment": "Brief critical summary",
    "walk_forward_summary": "Specific assessment of out-of-sample stability and degradation",
    "market_regime_concerns": ["concern1", "concern2"],
    "statistical_concerns": ["concern1", "concern2"],
    "proposal_evaluations": [
        {
            "proposal_id": 1,
            "overfitting_score": 0-100,
            "robustness_score": 0-100,
            "recommendation": "APPROVE|MODIFY|REJECT",
            "critical_issues": ["issue1", "issue2"],
            "warnings": ["warning1", "warning2"],
            "suggested_modifications": ["modification1"],
            "reasoning": "Detailed reasoning for the evaluation"
        }
    ],
    "approved_proposals": [1, 2],
    "rejected_proposals": [3],
    "best_proposal_id": 1,
    "proceed_with_testing": true/false,
    "final_concerns": ["Any remaining concerns to flag"]
}"""
                                                                               ^
[1m.\agents\critic.py[m[36m:[m98[36m:[m80[36m:[m [1m[31mE501[m line too long (93 > 79 characters)
        return """You are a senior risk analyst and trading strategy auditor with a skeptical mindset.
Your role is to critically evaluate optimization proposals and identify potential issues.

NEW WALK-FORWARD METRICS AVAILABLE:
- classic_ratio: average train Sharpe / average test Sharpe
- overfitting_ratio: classic_ratio + penalty for test instability (higher = worse)
- degradation_pct: % drop from train to test performance (0% = perfect forward)
- test_stability_std: standard deviation of test Sharpe across folds (lower = stable)
- n_valid_folds: number of successful out-of-sample tests

RED FLAGS (reject or flag heavily):
- overfitting_ratio > 1.8
- degradation_pct > 40%
- test_stability_std > 0.5
- n_valid_folds < 4

ADDITIONAL RED FLAGS:
- Very specific parameter values (e.g., 17.3 instead of 15 or 20)
- Large improvements with small changes
- Parameters at extreme bounds
- Inconsistent with analyst findings
- Overly complex parameter interactions

SCORING GUIDELINES:
- overfitting_score: 0-100 (0=no risk, 100=certain overfitting)
- robustness_score: 0-100 (0=fragile, 100=very robust)
- recommendation: APPROVE|MODIFY|REJECT

When evaluating proposals:
1. Prioritize walk-forward metrics - they are the strongest indicator of overfitting
2. Be skeptical but fair - look for real problems, not imaginary ones
3. Consider if changes could be data-mined coincidences
4. Check if the proposal addresses the real weakness or just symptoms
5. Evaluate if the expected improvement is realistic
6. Consider edge cases and regime changes

Respond ONLY in valid JSON format with this exact structure:
{
    "overall_assessment": "Brief critical summary",
    "walk_forward_summary": "Specific assessment of out-of-sample stability and degradation",
    "market_regime_concerns": ["concern1", "concern2"],
    "statistical_concerns": ["concern1", "concern2"],
    "proposal_evaluations": [
        {
            "proposal_id": 1,
            "overfitting_score": 0-100,
            "robustness_score": 0-100,
            "recommendation": "APPROVE|MODIFY|REJECT",
            "critical_issues": ["issue1", "issue2"],
            "warnings": ["warning1", "warning2"],
            "suggested_modifications": ["modification1"],
            "reasoning": "Detailed reasoning for the evaluation"
        }
    ],
    "approved_proposals": [1, 2],
    "rejected_proposals": [3],
    "best_proposal_id": 1,
    "proceed_with_testing": true/false,
    "final_concerns": ["Any remaining concerns to flag"]
}"""
                                                                               ^
[1m.\agents\critic.py[m[36m:[m170[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
            logger.warning(f"Critique partiellement invalide: {validation_errors}")
                                                                               ^
[1m.\agents\critic.py[m[36m:[m207[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
                "proceed_with_testing": critique.get("proceed_with_testing", False),
                                                                               ^
[1m.\agents\critic.py[m[36m:[m209[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
                "proposal_evaluations": critique.get("proposal_evaluations", []),
                                                                               ^
[1m.\agents\critic.py[m[36m:[m235[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
            "walk_forward_windows": getattr(context, "walk_forward_windows", None),
                                                                               ^
[1m.\agents\critic.py[m[36m:[m276[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
            elif eval_data["recommendation"] not in ["APPROVE", "MODIFY", "REJECT"]:
                                                                               ^
[1m.\agents\critic.py[m[36m:[m277[36m:[m80[36m:[m [1m[31mE501[m line too long (88 > 79 characters)
                errors.append(f"recommendation invalide: {eval_data['recommendation']}")
                                                                               ^
[1m.\agents\indicator_context.py[m[36m:[m4[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
"""
Module-ID: agents.indicator_context

Purpose: Construire un contexte indicateurs (strat√©gie vs lecture seule) pour LLM.

Role in pipeline: orchestration support

Key components: build_indicator_context, DEFAULT_READ_ONLY_INDICATORS

Inputs: DataFrame OHLCV, strat√©gie, param√®tres courants

Outputs: Dict avec sections texte + warnings

Dependencies: numpy, pandas, indicators.registry, strategies.*
"""
   
                                   

                                      ^
[1m.\agents\indicator_context.py[m[36m:[m38[36m:[m80[36m:[m [1m[31mE501[m line too long (122 > 79 characters)
    ("stoch_rsi", {"rsi_period": 14, "stoch_period": 14, "k_smooth": 3, "d_smooth": 3, "oversold": 20, "overbought": 80}),
                                                                               ^
[1m.\agents\indicator_context.py[m[36m:[m47[36m:[m80[36m:[m [1m[31mE501[m line too long (102 > 79 characters)
    ("ichimoku", {"tenkan_period": 9, "kijun_period": 26, "senkou_b_period": 52, "displacement": 26}),
                                                                               ^
[1m.\agents\indicator_context.py[m[36m:[m55[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
    ("volume_oscillator", {"short_period": 14, "long_period": 28, "method": "ema"}),
                                                                               ^
[1m.\agents\indicator_context.py[m[36m:[m75[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
    read_only_indicators: Optional[Iterable[Tuple[str, Dict[str, Any]]]] = None,
                                                                               ^
[1m.\agents\indicator_context.py[m[36m:[m79[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
    """
    Construit un contexte indicateurs s√©par√© en:
    - strategy_indicators: indicateurs li√©s √† la strat√©gie (modifiables via params)
    - read_only_indicators: indicateurs contexte (lecture seule)
    """
       
                                                
                      ^
[1m.\agents\indicator_context.py[m[36m:[m93[36m:[m80[36m:[m [1m[31mE501[m line too long (89 > 79 characters)
            "warnings": [f"Impossible de charger la strat√©gie '{strategy_name}': {exc}"],
                                                                               ^
[1m.\agents\indicator_context.py[m[36m:[m119[36m:[m80[36m:[m [1m[31mE501[m line too long (105 > 79 characters)
    ro_specs = list(read_only_indicators) if read_only_indicators else list(DEFAULT_READ_ONLY_INDICATORS)
                                                                               ^
[1m.\agents\indicator_context.py[m[36m:[m157[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
            indicator_params = strategy.get_indicator_params(indicator_name, params)
                                                                               ^
[1m.\agents\indicator_context.py[m[36m:[m170[36m:[m80[36m:[m [1m[31mE501[m line too long (97 > 79 characters)
                    df, indicator_name, {"period": int(fast)}, f"{indicator_name}_fast", warnings
                                                                               ^
[1m.\agents\indicator_context.py[m[36m:[m176[36m:[m80[36m:[m [1m[31mE501[m line too long (97 > 79 characters)
                    df, indicator_name, {"period": int(slow)}, f"{indicator_name}_slow", warnings
                                                                               ^
[1m.\agents\indicator_context.py[m[36m:[m218[36m:[m80[36m:[m [1m[31mE501[m line too long (97 > 79 characters)
        key_labels = TUPLE_LABELS.get(indicator_name, tuple(f"v{i}" for i in range(len(result))))
                                                                               ^
[1m.\agents\indicator_context.py[m[36m:[m304[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
def _first_param(params: Dict[str, Any], keys: Iterable[str]) -> Optional[float]:
                                                                               ^
[1m.\agents\integration.py[m[36m:[m4[36m:[m80[36m:[m [1m[31mE501[m line too long (113 > 79 characters)
"""
Module-ID: agents.integration

Purpose: Relier les agents LLM (abstraits) au moteur de backtest concret (BacktestEngine + WalkForwardValidator).

Role in pipeline: orchestration

Key components: run_backtest_for_agent, run_walk_forward_for_agent, create_optimizer_from_engine, create_orchestrator_with_backtest, validate_walk_forward_period

Inputs: DataFrame OHLCV, Config, strat√©gie (key/name), LLMConfig/RoleModelConfig, param√®tres et options walk-forward

Outputs: R√©sultats de backtest/walk-forward adapt√©s aux agents, factories d‚Äôoptimiseurs/orchestrator pr√™ts √† l‚Äôemploi

Dependencies: backtest.engine, backtest.validation, strategies.base, utils.config, utils.observability, agents.backtest_executor

Conventions: MIN_DAYS_FOR_WALK_FORWARD=180; timestamps d√©tect√©s (index datetime ou colonne 'timestamp'); WF peut √™tre d√©sactiv√© si p√©riode insuffisante.

Read-if: Vous modifiez le wiring agents‚Üîengine (run_backtest, walk-forward, factories).

Skip-if: Vous ne changez que les strat√©gies/indicateurs ou la UI.
"""
   
                             

                                            ^
[1m.\agents\integration.py[m[36m:[m8[36m:[m80[36m:[m [1m[31mE501[m line too long (161 > 79 characters)
"""
Module-ID: agents.integration

Purpose: Relier les agents LLM (abstraits) au moteur de backtest concret (BacktestEngine + WalkForwardValidator).

Role in pipeline: orchestration

Key components: run_backtest_for_agent, run_walk_forward_for_agent, create_optimizer_from_engine, create_orchestrator_with_backtest, validate_walk_forward_period

Inputs: DataFrame OHLCV, Config, strat√©gie (key/name), LLMConfig/RoleModelConfig, param√®tres et options walk-forward

Outputs: R√©sultats de backtest/walk-forward adapt√©s aux agents, factories d‚Äôoptimiseurs/orchestrator pr√™ts √† l‚Äôemploi

Dependencies: backtest.engine, backtest.validation, strategies.base, utils.config, utils.observability, agents.backtest_executor

Conventions: MIN_DAYS_FOR_WALK_FORWARD=180; timestamps d√©tect√©s (index datetime ou colonne 'timestamp'); WF peut √™tre d√©sactiv√© si p√©riode insuffisante.

Read-if: Vous modifiez le wiring agents‚Üîengine (run_backtest, walk-forward, factories).

Skip-if: Vous ne changez que les strat√©gies/indicateurs ou la UI.
"""
   
                             

                                            ^
[1m.\agents\integration.py[m[36m:[m10[36m:[m80[36m:[m [1m[31mE501[m line too long (116 > 79 characters)
"""
Module-ID: agents.integration

Purpose: Relier les agents LLM (abstraits) au moteur de backtest concret (BacktestEngine + WalkForwardValidator).

Role in pipeline: orchestration

Key components: run_backtest_for_agent, run_walk_forward_for_agent, create_optimizer_from_engine, create_orchestrator_with_backtest, validate_walk_forward_period

Inputs: DataFrame OHLCV, Config, strat√©gie (key/name), LLMConfig/RoleModelConfig, param√®tres et options walk-forward

Outputs: R√©sultats de backtest/walk-forward adapt√©s aux agents, factories d‚Äôoptimiseurs/orchestrator pr√™ts √† l‚Äôemploi

Dependencies: backtest.engine, backtest.validation, strategies.base, utils.config, utils.observability, agents.backtest_executor

Conventions: MIN_DAYS_FOR_WALK_FORWARD=180; timestamps d√©tect√©s (index datetime ou colonne 'timestamp'); WF peut √™tre d√©sactiv√© si p√©riode insuffisante.

Read-if: Vous modifiez le wiring agents‚Üîengine (run_backtest, walk-forward, factories).

Skip-if: Vous ne changez que les strat√©gies/indicateurs ou la UI.
"""
   
                             

                                            ^
[1m.\agents\integration.py[m[36m:[m12[36m:[m80[36m:[m [1m[31mE501[m line too long (117 > 79 characters)
"""
Module-ID: agents.integration

Purpose: Relier les agents LLM (abstraits) au moteur de backtest concret (BacktestEngine + WalkForwardValidator).

Role in pipeline: orchestration

Key components: run_backtest_for_agent, run_walk_forward_for_agent, create_optimizer_from_engine, create_orchestrator_with_backtest, validate_walk_forward_period

Inputs: DataFrame OHLCV, Config, strat√©gie (key/name), LLMConfig/RoleModelConfig, param√®tres et options walk-forward

Outputs: R√©sultats de backtest/walk-forward adapt√©s aux agents, factories d‚Äôoptimiseurs/orchestrator pr√™ts √† l‚Äôemploi

Dependencies: backtest.engine, backtest.validation, strategies.base, utils.config, utils.observability, agents.backtest_executor

Conventions: MIN_DAYS_FOR_WALK_FORWARD=180; timestamps d√©tect√©s (index datetime ou colonne 'timestamp'); WF peut √™tre d√©sactiv√© si p√©riode insuffisante.

Read-if: Vous modifiez le wiring agents‚Üîengine (run_backtest, walk-forward, factories).

Skip-if: Vous ne changez que les strat√©gies/indicateurs ou la UI.
"""
   
                             

                                            ^
[1m.\agents\integration.py[m[36m:[m14[36m:[m80[36m:[m [1m[31mE501[m line too long (128 > 79 characters)
"""
Module-ID: agents.integration

Purpose: Relier les agents LLM (abstraits) au moteur de backtest concret (BacktestEngine + WalkForwardValidator).

Role in pipeline: orchestration

Key components: run_backtest_for_agent, run_walk_forward_for_agent, create_optimizer_from_engine, create_orchestrator_with_backtest, validate_walk_forward_period

Inputs: DataFrame OHLCV, Config, strat√©gie (key/name), LLMConfig/RoleModelConfig, param√®tres et options walk-forward

Outputs: R√©sultats de backtest/walk-forward adapt√©s aux agents, factories d‚Äôoptimiseurs/orchestrator pr√™ts √† l‚Äôemploi

Dependencies: backtest.engine, backtest.validation, strategies.base, utils.config, utils.observability, agents.backtest_executor

Conventions: MIN_DAYS_FOR_WALK_FORWARD=180; timestamps d√©tect√©s (index datetime ou colonne 'timestamp'); WF peut √™tre d√©sactiv√© si p√©riode insuffisante.

Read-if: Vous modifiez le wiring agents‚Üîengine (run_backtest, walk-forward, factories).

Skip-if: Vous ne changez que les strat√©gies/indicateurs ou la UI.
"""
   
                             

                                            ^
[1m.\agents\integration.py[m[36m:[m16[36m:[m80[36m:[m [1m[31mE501[m line too long (152 > 79 characters)
"""
Module-ID: agents.integration

Purpose: Relier les agents LLM (abstraits) au moteur de backtest concret (BacktestEngine + WalkForwardValidator).

Role in pipeline: orchestration

Key components: run_backtest_for_agent, run_walk_forward_for_agent, create_optimizer_from_engine, create_orchestrator_with_backtest, validate_walk_forward_period

Inputs: DataFrame OHLCV, Config, strat√©gie (key/name), LLMConfig/RoleModelConfig, param√®tres et options walk-forward

Outputs: R√©sultats de backtest/walk-forward adapt√©s aux agents, factories d‚Äôoptimiseurs/orchestrator pr√™ts √† l‚Äôemploi

Dependencies: backtest.engine, backtest.validation, strategies.base, utils.config, utils.observability, agents.backtest_executor

Conventions: MIN_DAYS_FOR_WALK_FORWARD=180; timestamps d√©tect√©s (index datetime ou colonne 'timestamp'); WF peut √™tre d√©sactiv√© si p√©riode insuffisante.

Read-if: Vous modifiez le wiring agents‚Üîengine (run_backtest, walk-forward, factories).

Skip-if: Vous ne changez que les strat√©gies/indicateurs ou la UI.
"""
   
                             

                                            ^
[1m.\agents\integration.py[m[36m:[m18[36m:[m80[36m:[m [1m[31mE501[m line too long (87 > 79 characters)
"""
Module-ID: agents.integration

Purpose: Relier les agents LLM (abstraits) au moteur de backtest concret (BacktestEngine + WalkForwardValidator).

Role in pipeline: orchestration

Key components: run_backtest_for_agent, run_walk_forward_for_agent, create_optimizer_from_engine, create_orchestrator_with_backtest, validate_walk_forward_period

Inputs: DataFrame OHLCV, Config, strat√©gie (key/name), LLMConfig/RoleModelConfig, param√®tres et options walk-forward

Outputs: R√©sultats de backtest/walk-forward adapt√©s aux agents, factories d‚Äôoptimiseurs/orchestrator pr√™ts √† l‚Äôemploi

Dependencies: backtest.engine, backtest.validation, strategies.base, utils.config, utils.observability, agents.backtest_executor

Conventions: MIN_DAYS_FOR_WALK_FORWARD=180; timestamps d√©tect√©s (index datetime ou colonne 'timestamp'); WF peut √™tre d√©sactiv√© si p√©riode insuffisante.

Read-if: Vous modifiez le wiring agents‚Üîengine (run_backtest, walk-forward, factories).

Skip-if: Vous ne changez que les strat√©gies/indicateurs ou la UI.
"""
   
                             

                                            ^
[1m.\agents\integration.py[m[36m:[m26[36m:[m80[36m:[m [1m[31mE501[m line too long (93 > 79 characters)
from typing import TYPE_CHECKING, Any, Dict, List, Mapping, Optional, Tuple, TypedDict, Union
                                                                               ^
[1m.\agents\integration.py[m[36m:[m34[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
from strategies.base import get_strategy, get_strategy_overview, list_strategies
                                                                               ^
[1m.\agents\integration.py[m[36m:[m151[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
    """
    Valide si la p√©riode de donn√©es est suffisante pour une walk-forward validation.

    La walk-forward n√©cessite une p√©riode minimale pour avoir une signification
    statistique. En dessous de 6 mois, les folds sont trop courts et les r√©sultats
    sont domin√©s par le bruit statistique.

    Args:
        data: DataFrame OHLCV avec index datetime ou colonne 'timestamp'
        min_days: Nombre de jours minimum requis (d√©faut: 180 = 6 mois)

    Returns:
        Tuple (is_valid, duration_days, message)
        - is_valid: True si p√©riode suffisante, False sinon
        - duration_days: Dur√©e en jours de la p√©riode
        - message: Message explicatif

    Exemples:
        >>> is_valid, days, msg = validate_walk_forward_period(df)
        >>> if not is_valid:
        ...     print(f"‚ö†Ô∏è {msg}")
        ...     # D√©sactiver walk-forward
    """
       
                                                                       ^
[1m.\agents\integration.py[m[36m:[m154[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
    """
    Valide si la p√©riode de donn√©es est suffisante pour une walk-forward validation.

    La walk-forward n√©cessite une p√©riode minimale pour avoir une signification
    statistique. En dessous de 6 mois, les folds sont trop courts et les r√©sultats
    sont domin√©s par le bruit statistique.

    Args:
        data: DataFrame OHLCV avec index datetime ou colonne 'timestamp'
        min_days: Nombre de jours minimum requis (d√©faut: 180 = 6 mois)

    Returns:
        Tuple (is_valid, duration_days, message)
        - is_valid: True si p√©riode suffisante, False sinon
        - duration_days: Dur√©e en jours de la p√©riode
        - message: Message explicatif

    Exemples:
        >>> is_valid, days, msg = validate_walk_forward_period(df)
        >>> if not is_valid:
        ...     print(f"‚ö†Ô∏è {msg}")
        ...     # D√©sactiver walk-forward
    """
       
                                                                       ^
[1m.\agents\integration.py[m[36m:[m185[36m:[m80[36m:[m [1m[31mE501[m line too long (104 > 79 characters)
            f"{duration} jours ({months:.1f} mois) < {min_days} jours ({min_months:.0f} mois minimum). "
                                                                               ^
[1m.\agents\integration.py[m[36m:[m186[36m:[m80[36m:[m [1m[31mE501[m line too long (98 > 79 characters)
            f"Walk-forward D√âSACTIV√â automatiquement pour √©viter des r√©sultats non significatifs."
                                                                               ^
[1m.\agents\integration.py[m[36m:[m313[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
    """
    Ex√©cute une validation walk-forward et retourne les m√©triques.

    Configuration optimis√©e pour 2 ans de donn√©es :
    - 6 fen√™tres ‚Üí ~4 mois de test par fen√™tre
    - 75% train ‚Üí 18 mois d'entra√Ænement, 6 mois de test
    - 2% embargo ‚Üí √©vite le leakage entre train et test

    Args:
        strategy_name: Nom de la strat√©gie
        params: Param√®tres de la strat√©gie
        data: DataFrame OHLCV
        n_windows: Nombre de fen√™tres de validation
        train_ratio: Ratio train/total (1 - test_ratio)
        initial_capital: Capital de d√©part
        config: Configuration optionnelle
        n_workers: Nombre de workers pour parall√©lisation (1 = s√©quentiel)

    Returns:
        Dict avec train_sharpe, test_sharpe, overfitting_ratio, m√©triques robustes
    """
       
                                                                  

   ^
[1m.\agents\integration.py[m[36m:[m327[36m:[m80[36m:[m [1m[31mE501[m line too long (89 > 79 characters)
        # Cr√©er une instance d'engine par thread pour √©viter les probl√®mes de concurrence
                                                                               ^
[1m.\agents\integration.py[m[36m:[m347[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
            fold.train_metrics = _normalize_engine_metrics(train_result.metrics)
                                                                               ^
[1m.\agents\integration.py[m[36m:[m361[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
        # Mode parall√®le - utiliser ThreadPoolExecutor pour parall√©liser les folds
                                                                               ^
[1m.\agents\integration.py[m[36m:[m364[36m:[m80[36m:[m [1m[31mE501[m line too long (95 > 79 characters)
        _logger.info(f"Walk-forward parall√®le avec {n_workers} workers sur {len(folds)} folds")
                                                                               ^
[1m.\agents\integration.py[m[36m:[m374[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
                        _logger.warning(f"Fold {original_fold.fold_id} a √©chou√©")
                                                                               ^
[1m.\agents\integration.py[m[36m:[m376[36m:[m80[36m:[m [1m[31mE501[m line too long (103 > 79 characters)
                    _logger.warning(f"Erreur lors de l'ex√©cution du fold {original_fold.fold_id}: {e}")
                                                                               ^
[1m.\agents\integration.py[m[36m:[m408[36m:[m80[36m:[m [1m[31mE501[m line too long (93 > 79 characters)
    degradation_pct = (avg_train - avg_test) / avg_train * 100 if avg_train > 1e-6 else 100.0
                                                                               ^
[1m.\agents\integration.py[m[36m:[m451[36m:[m80[36m:[m [1m[31mE501[m line too long (89 > 79 characters)
    """
    Factory compl√®te pour cr√©er un optimiseur autonome connect√© au vrai moteur.

    C'est LA fonction √† utiliser pour une optimisation autonome fonctionnelle.

    Args:
        llm_config: Configuration du LLM (Ollama ou OpenAI)
        strategy_name: Nom de la strat√©gie √† optimiser
        data: DataFrame OHLCV
        initial_capital: Capital de d√©part
        config: Configuration du backtest
        use_walk_forward: Activer validation walk-forward
        verbose: Logs d√©taill√©s
        unload_llm_during_backtest: Si True, d√©charge le LLM du GPU pendant les backtests
            pour lib√©rer la VRAM. Si None, utilise la variable d'environnement
            UNLOAD_LLM_DURING_BACKTEST (d√©faut: False pour compatibilit√© CPU-only)
        orchestration_logger: Logger pour enregistrer les actions d'orchestration

    Returns:
        (AutonomousStrategist, BacktestExecutor) pr√™ts √† l'emploi

    Example:
        >>> from agents.integration import create_optimizer_from_engine
        >>> from agents.llm_client import LLMConfig, LLMProvider
        >>>
        >>> config = LLMConfig(provider=LLMProvider.OLLAMA, model="llama3.2")
        >>>
        >>> strategist, executor = create_optimizer_from_engine(
        ...     llm_config=config,
        ...     strategy_name="ema_cross",
        ...     data=ohlcv_df,
        ... )
        >>>
        >>> session = strategist.optimize(
        ...     executor=executor,
        ...     initial_params={"fast_period": 10, "slow_period": 21},
        ...     param_bounds={"fast_period": (5, 20), "slow_period": (15, 50)},
        ...     max_iterations=10,
        ... )
        >>>
        >>> print(f"Best Sharpe: {session.best_result.sharpe_ratio}")
        >>> print(f"Best Params: {session.best_result.request.parameters}")
    """
       
                                                                       ^
[1m.\agents\integration.py[m[36m:[m453[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
    """
    Factory compl√®te pour cr√©er un optimiseur autonome connect√© au vrai moteur.

    C'est LA fonction √† utiliser pour une optimisation autonome fonctionnelle.

    Args:
        llm_config: Configuration du LLM (Ollama ou OpenAI)
        strategy_name: Nom de la strat√©gie √† optimiser
        data: DataFrame OHLCV
        initial_capital: Capital de d√©part
        config: Configuration du backtest
        use_walk_forward: Activer validation walk-forward
        verbose: Logs d√©taill√©s
        unload_llm_during_backtest: Si True, d√©charge le LLM du GPU pendant les backtests
            pour lib√©rer la VRAM. Si None, utilise la variable d'environnement
            UNLOAD_LLM_DURING_BACKTEST (d√©faut: False pour compatibilit√© CPU-only)
        orchestration_logger: Logger pour enregistrer les actions d'orchestration

    Returns:
        (AutonomousStrategist, BacktestExecutor) pr√™ts √† l'emploi

    Example:
        >>> from agents.integration import create_optimizer_from_engine
        >>> from agents.llm_client import LLMConfig, LLMProvider
        >>>
        >>> config = LLMConfig(provider=LLMProvider.OLLAMA, model="llama3.2")
        >>>
        >>> strategist, executor = create_optimizer_from_engine(
        ...     llm_config=config,
        ...     strategy_name="ema_cross",
        ...     data=ohlcv_df,
        ... )
        >>>
        >>> session = strategist.optimize(
        ...     executor=executor,
        ...     initial_params={"fast_period": 10, "slow_period": 21},
        ...     param_bounds={"fast_period": (5, 20), "slow_period": (15, 50)},
        ...     max_iterations=10,
        ... )
        >>>
        >>> print(f"Best Sharpe: {session.best_result.sharpe_ratio}")
        >>> print(f"Best Params: {session.best_result.request.parameters}")
    """
       
                                                                       ^
[1m.\agents\integration.py[m[36m:[m454[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
    """
    Factory compl√®te pour cr√©er un optimiseur autonome connect√© au vrai moteur.

    C'est LA fonction √† utiliser pour une optimisation autonome fonctionnelle.

    Args:
        llm_config: Configuration du LLM (Ollama ou OpenAI)
        strategy_name: Nom de la strat√©gie √† optimiser
        data: DataFrame OHLCV
        initial_capital: Capital de d√©part
        config: Configuration du backtest
        use_walk_forward: Activer validation walk-forward
        verbose: Logs d√©taill√©s
        unload_llm_during_backtest: Si True, d√©charge le LLM du GPU pendant les backtests
            pour lib√©rer la VRAM. Si None, utilise la variable d'environnement
            UNLOAD_LLM_DURING_BACKTEST (d√©faut: False pour compatibilit√© CPU-only)
        orchestration_logger: Logger pour enregistrer les actions d'orchestration

    Returns:
        (AutonomousStrategist, BacktestExecutor) pr√™ts √† l'emploi

    Example:
        >>> from agents.integration import create_optimizer_from_engine
        >>> from agents.llm_client import LLMConfig, LLMProvider
        >>>
        >>> config = LLMConfig(provider=LLMProvider.OLLAMA, model="llama3.2")
        >>>
        >>> strategist, executor = create_optimizer_from_engine(
        ...     llm_config=config,
        ...     strategy_name="ema_cross",
        ...     data=ohlcv_df,
        ... )
        >>>
        >>> session = strategist.optimize(
        ...     executor=executor,
        ...     initial_params={"fast_period": 10, "slow_period": 21},
        ...     param_bounds={"fast_period": (5, 20), "slow_period": (15, 50)},
        ...     max_iterations=10,
        ... )
        >>>
        >>> print(f"Best Sharpe: {session.best_result.sharpe_ratio}")
        >>> print(f"Best Params: {session.best_result.request.parameters}")
    """
       
                                                                       ^
[1m.\agents\integration.py[m[36m:[m494[36m:[m80[36m:[m [1m[31mE501[m line too long (88 > 79 characters)
                "walk_forward_auto_disabled duration_days=%s reason='period_too_short'",
                                                                               ^
[1m.\agents\integration.py[m[36m:[m747[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
    """
    Cr√©e un Orchestrator multi-agents branch√© sur le vrai backtest.

    L'Orchestrator par d√©faut n√©cessite un callback `on_backtest_needed`.
    Cette fonction le configure automatiquement avec `run_backtest_for_agent()`.

    Args:
        strategy_name: Nom de la strat√©gie
        data: DataFrame OHLCV
        initial_params: Param√®tres initiaux
        data_symbol: Symbole (ex: "BTCUSDC")
        data_timeframe: Timeframe (ex: "1h")
        llm_config: Configuration LLM (optionnel, d√©faut depuis env)
        role_model_config: Configuration multi-modeles par role
        use_walk_forward: Activer la validation walk-forward (si possible)
        orchestration_logger: Logger d'orchestration (UI live/persistance)
        session_id: Forcer l'ID de session (corr√©lation UI)
        n_workers: Nombre de workers pour parall√©liser les backtests de propositions
        max_iterations: Maximum d'it√©rations
        initial_capital: Capital de d√©part
        config: Configuration du backtest

    Returns:
        Orchestrator configur√© et pr√™t √† ex√©cuter

    Example:
        >>> orchestrator = create_orchestrator_with_backtest(
        ...     strategy_name="ema_cross",
        ...     data=df,
        ...     initial_params={"fast_period": 12, "slow_period": 26},
        ... )
        >>> result = orchestrator.run()
        >>> if result.success:
        ...     print(f"Meilleurs params: {result.final_params}")
    """
       
                                                                   

  ^
[1m.\agents\integration.py[m[36m:[m760[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
    """
    Cr√©e un Orchestrator multi-agents branch√© sur le vrai backtest.

    L'Orchestrator par d√©faut n√©cessite un callback `on_backtest_needed`.
    Cette fonction le configure automatiquement avec `run_backtest_for_agent()`.

    Args:
        strategy_name: Nom de la strat√©gie
        data: DataFrame OHLCV
        initial_params: Param√®tres initiaux
        data_symbol: Symbole (ex: "BTCUSDC")
        data_timeframe: Timeframe (ex: "1h")
        llm_config: Configuration LLM (optionnel, d√©faut depuis env)
        role_model_config: Configuration multi-modeles par role
        use_walk_forward: Activer la validation walk-forward (si possible)
        orchestration_logger: Logger d'orchestration (UI live/persistance)
        session_id: Forcer l'ID de session (corr√©lation UI)
        n_workers: Nombre de workers pour parall√©liser les backtests de propositions
        max_iterations: Maximum d'it√©rations
        initial_capital: Capital de d√©part
        config: Configuration du backtest

    Returns:
        Orchestrator configur√© et pr√™t √† ex√©cuter

    Example:
        >>> orchestrator = create_orchestrator_with_backtest(
        ...     strategy_name="ema_cross",
        ...     data=df,
        ...     initial_params={"fast_period": 12, "slow_period": 26},
        ... )
        >>> result = orchestrator.run()
        >>> if result.success:
        ...     print(f"Meilleurs params: {result.final_params}")
    """
       
                                                                   

  ^
[1m.\agents\integration.py[m[36m:[m788[36m:[m80[36m:[m [1m[31mE501[m line too long (88 > 79 characters)
                "walk_forward_auto_disabled duration_days=%s reason='period_too_short'",
                                                                               ^
[1m.\agents\integration.py[m[36m:[m930[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
        summary += f"{i}. Sharpe={sharpe:.2f}, Return={ret:.1f}% | {params_str}\n"
                                                                               ^
[1m.\agents\integration.py[m[36m:[m936[36m:[m80[36m:[m [1m[31mE501[m line too long (93 > 79 characters)
        summary += f"- {param_name}: tested range [{range_def['min']}, {range_def['max']}]\n"
                                                                               ^
[1m.\agents\integration.py[m[36m:[m983[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
    from utils.parameters import compute_search_space_stats, normalize_param_ranges
                                                                               ^
[1m.\agents\integration.py[m[36m:[m987[36m:[m80[36m:[m [1m[31mE501[m line too long (86 > 79 characters)
        f"ranges={range_proposal.ranges} max_combos={range_proposal.max_combinations}"
                                                                               ^
[1m.\agents\integration.py[m[36m:[m1012[36m:[m80[36m:[m [1m[31mE501[m line too long (100 > 79 characters)
            f"{range_proposal.max_combinations}). R√©duire les ranges ou augmenter max_combinations."
                                                                               ^
[1m.\agents\integration.py[m[36m:[m1036[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
    top_k = df_results.nlargest(10, range_proposal.optimize_for).to_dict('records')
                                                                               ^
[1m.\agents\integration.py[m[36m:[m1043[36m:[m80[36m:[m [1m[31mE501[m line too long (114 > 79 characters)
        f"best_{range_proposal.optimize_for}={sweep_results.best_metrics.get(range_proposal.optimize_for, 0):.3f}"
                                                                               ^
[1m.\agents\llm_client.py[m[36m:[m4[36m:[m80[36m:[m [1m[31mE501[m line too long (96 > 79 characters)
"""
Module-ID: agents.llm_client

Purpose: Client LLM unifi√© supportant Ollama (local) et OpenAI (cloud) avec abstraction commune.

Role in pipeline: orchestration

Key components: LLMClient (abstract), OllamaClient, OpenAIClient, LLMConfig, LLMMessage, LLMResponse

Inputs: LLMConfig (provider, model, params), messages, syst√®me prompt

Outputs: LLMResponse (texte/JSON, usage tokens, timing)

Dependencies: httpx, pydantic, utils.log

Conventions: json_mode force JSON strict; parse_json g√®re blocs ```json ``` et inline; timeout adaptatif pour reasoning models (deepseek-r1, o1); fallback parsing si JSON mode √©choue.

Read-if: Ajout providers, modification parsing, ou gestion erreurs LLM.

Skip-if: Vous appelez juste le client via create_llm_client().
"""
   
                            

                                             ^
[1m.\agents\llm_client.py[m[36m:[m8[36m:[m80[36m:[m [1m[31mE501[m line too long (100 > 79 characters)
"""
Module-ID: agents.llm_client

Purpose: Client LLM unifi√© supportant Ollama (local) et OpenAI (cloud) avec abstraction commune.

Role in pipeline: orchestration

Key components: LLMClient (abstract), OllamaClient, OpenAIClient, LLMConfig, LLMMessage, LLMResponse

Inputs: LLMConfig (provider, model, params), messages, syst√®me prompt

Outputs: LLMResponse (texte/JSON, usage tokens, timing)

Dependencies: httpx, pydantic, utils.log

Conventions: json_mode force JSON strict; parse_json g√®re blocs ```json ``` et inline; timeout adaptatif pour reasoning models (deepseek-r1, o1); fallback parsing si JSON mode √©choue.

Read-if: Ajout providers, modification parsing, ou gestion erreurs LLM.

Skip-if: Vous appelez juste le client via create_llm_client().
"""
   
                            

                                             ^
[1m.\agents\llm_client.py[m[36m:[m16[36m:[m80[36m:[m [1m[31mE501[m line too long (183 > 79 characters)
"""
Module-ID: agents.llm_client

Purpose: Client LLM unifi√© supportant Ollama (local) et OpenAI (cloud) avec abstraction commune.

Role in pipeline: orchestration

Key components: LLMClient (abstract), OllamaClient, OpenAIClient, LLMConfig, LLMMessage, LLMResponse

Inputs: LLMConfig (provider, model, params), messages, syst√®me prompt

Outputs: LLMResponse (texte/JSON, usage tokens, timing)

Dependencies: httpx, pydantic, utils.log

Conventions: json_mode force JSON strict; parse_json g√®re blocs ```json ``` et inline; timeout adaptatif pour reasoning models (deepseek-r1, o1); fallback parsing si JSON mode √©choue.

Read-if: Ajout providers, modification parsing, ou gestion erreurs LLM.

Skip-if: Vous appelez juste le client via create_llm_client().
"""
   
                            

                                             ^
[1m.\agents\llm_client.py[m[36m:[m75[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
        provider_str = os.environ.get("BACKTEST_LLM_PROVIDER", "ollama").lower()
                                                                               ^
[1m.\agents\llm_client.py[m[36m:[m76[36m:[m80[36m:[m [1m[31mE501[m line too long (89 > 79 characters)
        provider = LLMProvider.OPENAI if provider_str == "openai" else LLMProvider.OLLAMA
                                                                               ^
[1m.\agents\llm_client.py[m[36m:[m81[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
            ollama_host=os.environ.get("OLLAMA_HOST", "http://localhost:11434"),
                                                                               ^
[1m.\agents\llm_client.py[m[36m:[m83[36m:[m80[36m:[m [1m[31mE501[m line too long (91 > 79 characters)
            openai_base_url=os.environ.get("OPENAI_BASE_URL", "https://api.openai.com/v1"),
                                                                               ^
[1m.\agents\llm_client.py[m[36m:[m84[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
            temperature=float(os.environ.get("BACKTEST_LLM_TEMPERATURE", "0.7")),
                                                                               ^
[1m.\agents\llm_client.py[m[36m:[m237[36m:[m80[36m:[m [1m[31mE501[m line too long (86 > 79 characters)
    """
    D√©tecte si un mod√®le est un mod√®le de raisonnement qui peut prendre plus de temps.

    Les mod√®les de raisonnement comme deepseek-r1, qwq, o1, etc. peuvent prendre
    5-15 minutes pour raisonner sur des t√¢ches complexes.
    """
       
                                                                       ^
[1m.\agents\llm_client.py[m[36m:[m239[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
    """
    D√©tecte si un mod√®le est un mod√®le de raisonnement qui peut prendre plus de temps.

    Les mod√®les de raisonnement comme deepseek-r1, qwq, o1, etc. peuvent prendre
    5-15 minutes pour raisonner sur des t√¢ches complexes.
    """
       
                                                                       ^
[1m.\agents\llm_client.py[m[36m:[m262[36m:[m80[36m:[m [1m[31mE501[m line too long (98 > 79 characters)
        logger.info(f"üß† Mod√®le de raisonnement d√©tect√© ({config.model}): timeout √©tendu √† 15 min")
                                                                               ^
[1m.\agents\llm_client.py[m[36m:[m277[36m:[m80[36m:[m [1m[31mE501[m line too long (86 > 79 characters)
    def _messages_to_prompt(self, messages: List[LLMMessage], json_mode: bool) -> str:
                                                                               ^
[1m.\agents\llm_client.py[m[36m:[m303[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
        """Fallback Ollama via /api/generate quand /api/chat est indisponible."""
                                                                               ^
[1m.\agents\llm_client.py[m[36m:[m370[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
            response = self._http_client.get(f"{self.config.ollama_host}/api/tags")
                                                                               ^
[1m.\agents\llm_client.py[m[36m:[m411[36m:[m80[36m:[m [1m[31mE501[m line too long (106 > 79 characters)
                        f"ü§ñ Interrogation {self.config.model} (timeout: {self._adaptive_timeout:.0f}s)..."
                                                                               ^
[1m.\agents\llm_client.py[m[36m:[m415[36m:[m80[36m:[m [1m[31mE501[m line too long (96 > 79 characters)
                    return self._chat_via_generate(messages, temperature, max_tokens, json_mode)
                                                                               ^
[1m.\agents\llm_client.py[m[36m:[m424[36m:[m80[36m:[m [1m[31mE501[m line too long (90 > 79 characters)
                        "Ollama /api/chat introuvable (404). Fallback vers /api/generate."
                                                                               ^
[1m.\agents\llm_client.py[m[36m:[m427[36m:[m80[36m:[m [1m[31mE501[m line too long (96 > 79 characters)
                    return self._chat_via_generate(messages, temperature, max_tokens, json_mode)
                                                                               ^
[1m.\agents\llm_client.py[m[36m:[m465[36m:[m80[36m:[m [1m[31mE501[m line too long (93 > 79 characters)
                    f"üí° Le mod√®le {self.config.model} peut prendre du temps pour raisonner. "
                                                                               ^
[1m.\agents\llm_client.py[m[36m:[m559[36m:[m80[36m:[m [1m[31mE501[m line too long (86 > 79 characters)
                    content = data["choices"][0].get("message", {}).get("content", "")
                                                                               ^
[1m.\agents\llm_client.py[m[36m:[m579[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
                    wait_time = self.config.retry_delay_seconds * (2 ** attempt)
                                                                               ^
[1m.\agents\model_config.py[m[36m:[m4[36m:[m80[36m:[m [1m[31mE501[m line too long (111 > 79 characters)
"""
Module-ID: agents.model_config

Purpose: Configuration multi-mod√®les par r√¥le d'agent avec s√©lection intelligente (rapide/lourd par it√©ration).

Role in pipeline: orchestration

Key components: RoleModelConfig, ModelCategory, KNOWN_MODELS, get_model

Inputs: role (analyst/strategist/critic/validator), iteration, allow_heavy flag

Outputs: Mod√®le s√©lectionn√© (al√©atoire parmi configur√©s), fallback si non dispo

Dependencies: utils.log, httpx (Ollama discovery)

Conventions: ANALYST=rapide, STRATEGIST=moyen, CRITIC/VALIDATOR=lourd optionnel; early iterations excluent mod√®les lourds; fallback cascade si mod√®le absent.

Read-if: Ajout mod√®les, configuration par r√¥le, ou r√®gles de s√©lection it√©rative.

Skip-if: Vous utilisez la config par d√©faut.
"""
   
                              

                                           ^
[1m.\agents\model_config.py[m[36m:[m16[36m:[m80[36m:[m [1m[31mE501[m line too long (157 > 79 characters)
"""
Module-ID: agents.model_config

Purpose: Configuration multi-mod√®les par r√¥le d'agent avec s√©lection intelligente (rapide/lourd par it√©ration).

Role in pipeline: orchestration

Key components: RoleModelConfig, ModelCategory, KNOWN_MODELS, get_model

Inputs: role (analyst/strategist/critic/validator), iteration, allow_heavy flag

Outputs: Mod√®le s√©lectionn√© (al√©atoire parmi configur√©s), fallback si non dispo

Dependencies: utils.log, httpx (Ollama discovery)

Conventions: ANALYST=rapide, STRATEGIST=moyen, CRITIC/VALIDATOR=lourd optionnel; early iterations excluent mod√®les lourds; fallback cascade si mod√®le absent.

Read-if: Ajout mod√®les, configuration par r√¥le, ou r√®gles de s√©lection it√©rative.

Skip-if: Vous utilisez la config par d√©faut.
"""
   
                              

                                           ^
[1m.\agents\model_config.py[m[36m:[m18[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
"""
Module-ID: agents.model_config

Purpose: Configuration multi-mod√®les par r√¥le d'agent avec s√©lection intelligente (rapide/lourd par it√©ration).

Role in pipeline: orchestration

Key components: RoleModelConfig, ModelCategory, KNOWN_MODELS, get_model

Inputs: role (analyst/strategist/critic/validator), iteration, allow_heavy flag

Outputs: Mod√®le s√©lectionn√© (al√©atoire parmi configur√©s), fallback si non dispo

Dependencies: utils.log, httpx (Ollama discovery)

Conventions: ANALYST=rapide, STRATEGIST=moyen, CRITIC/VALIDATOR=lourd optionnel; early iterations excluent mod√®les lourds; fallback cascade si mod√®le absent.

Read-if: Ajout mod√®les, configuration par r√¥le, ou r√®gles de s√©lection it√©rative.

Skip-if: Vous utilisez la config par d√©faut.
"""
   
                              

                                           ^
[1m.\agents\model_config.py[m[36m:[m53[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
    """R√©cup√®re /api/tags avec retries/backoff (Ollama peut d√©marrer lentement)."""
                                                                               ^
[1m.\agents\model_config.py[m[36m:[m70[36m:[m80[36m:[m [1m[31mE501[m line too long (93 > 79 characters)
        logger.warning("Impossible de lister les modeles Ollama apres retries: %s", last_exc)
                                                                               ^
[1m.\agents\model_config.py[m[36m:[m94[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
def _model_info_from_library_entry(entry: Dict[str, Any]) -> Optional[ModelInfo]:
                                                                               ^
[1m.\agents\model_config.py[m[36m:[m104[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
    description = entry.get("description") or f"Modele {name} ({size_gb:.1f} GB)"
                                                                               ^
[1m.\agents\model_config.py[m[36m:[m115[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
    """Normalise un nom de mod√®le (supprime le tag latest et garde le complet)."""
                                                                               ^
[1m.\agents\model_config.py[m[36m:[m138[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
    recommended_for: List[str] = field(default_factory=list)  # R√¥les recommand√©s
                                                                               ^
[1m.\agents\model_config.py[m[36m:[m259[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
        description="Llama 3.3 70B Instruct Q4 - Multi-GPU, raisonnement avanc√©",
                                                                               ^
[1m.\agents\model_config.py[m[36m:[m273[36m:[m80[36m:[m [1m[31mE501[m line too long (91 > 79 characters)
        description="Llama 3.3 70B Multi-GPU (2 GPUs) - Optimis√© pour RTX 5080 + RTX 2060",
                                                                               ^
[1m.\agents\model_config.py[m[36m:[m286[36m:[m80[36m:[m [1m[31mE501[m line too long (96 > 79 characters)
    allow_heavy_after_iteration: int = 3  # N'autoriser les mod√®les lourds qu'apr√®s N it√©rations
                                                                               ^
[1m.\agents\model_config.py[m[36m:[m287[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
    prefer_specialized: bool = True  # Pr√©f√©rer les mod√®les sp√©cialis√©s pour ce r√¥le
                                                                               ^
[1m.\agents\model_config.py[m[36m:[m317[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
                if not allow_heavy and iteration < self.allow_heavy_after_iteration:
                                                                               ^
[1m.\agents\model_config.py[m[36m:[m335[36m:[m80[36m:[m [1m[31mE501[m line too long (85 > 79 characters)
    analyst: RoleModelAssignment = field(default_factory=lambda: RoleModelAssignment(
                                                                               ^
[1m.\agents\model_config.py[m[36m:[m337[36m:[m80[36m:[m [1m[31mE501[m line too long (108 > 79 characters)
        models=["deepseek-r1:8b", "mistral:7b-instruct", "martain7r/finance-llama-8b:q4_k_m", "gemma3:12b"],
                                                                               ^
[1m.\agents\model_config.py[m[36m:[m341[36m:[m80[36m:[m [1m[31mE501[m line too long (88 > 79 characters)
    strategist: RoleModelAssignment = field(default_factory=lambda: RoleModelAssignment(
                                                                               ^
[1m.\agents\model_config.py[m[36m:[m343[36m:[m80[36m:[m [1m[31mE501[m line too long (90 > 79 characters)
        models=["deepseek-r1:8b", "gemma3:12b", "deepseek-r1-distill:14b", "mistral:22b"],
                                                                               ^
[1m.\agents\model_config.py[m[36m:[m347[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
    critic: RoleModelAssignment = field(default_factory=lambda: RoleModelAssignment(
                                                                               ^
[1m.\agents\model_config.py[m[36m:[m349[36m:[m80[36m:[m [1m[31mE501[m line too long (128 > 79 characters)
        models=["deepseek-r1-distill:14b", "mistral:22b", "gemma3:27b", "deepseek-r1:32b", "qwq:32b", "llama3.3-70b-optimized"],
                                                                               ^
[1m.\agents\model_config.py[m[36m:[m353[36m:[m80[36m:[m [1m[31mE501[m line too long (87 > 79 characters)
    validator: RoleModelAssignment = field(default_factory=lambda: RoleModelAssignment(
                                                                               ^
[1m.\agents\model_config.py[m[36m:[m355[36m:[m80[36m:[m [1m[31mE501[m line too long (113 > 79 characters)
        models=["deepseek-r1-distill:14b", "gemma3:27b", "deepseek-r1:32b", "qwq:32b", "llama3.3-70b-optimized"],
                                                                               ^
[1m.\agents\model_config.py[m[36m:[m380[36m:[m80[36m:[m [1m[31mE501[m line too long (94 > 79 characters)
        # 2) Fallback: models.json (permet d'afficher quelque chose si l'API est indisponible)
                                                                               ^
[1m.\agents\model_config.py[m[36m:[m390[36m:[m80[36m:[m [1m[31mE501[m line too long (91 > 79 characters)
        logger.debug("Modeles consideres comme installes: %s", len(self._installed_models))
                                                                               ^
[1m.\agents\model_config.py[m[36m:[m430[36m:[m80[36m:[m [1m[31mE501[m line too long (88 > 79 characters)
        """
        Obtient un mod√®le pour un r√¥le donn√©.

        Args:
            role: Nom du r√¥le (analyst, strategist, critic, validator)
            iteration: Num√©ro d'it√©ration actuel
            allow_heavy: Forcer l'autorisation des mod√®les lourds
            random_selection: Si True, s√©lection al√©atoire parmi les mod√®les disponibles

        Returns:
            Nom du mod√®le ou None si aucun disponible
        """
           
                                             

             
      ^
[1m.\agents\model_config.py[m[36m:[m445[36m:[m80[36m:[m [1m[31mE501[m line too long (106 > 79 characters)
            return random.choice(available) if (random_selection and len(available) > 1) else available[0]
                                                                               ^
[1m.\agents\model_config.py[m[36m:[m447[36m:[m80[36m:[m [1m[31mE501[m line too long (88 > 79 characters)
        # Niveau 2: fallback sur la config du role, meme si Ollama est down / liste vide
                                                                               ^
[1m.\agents\model_config.py[m[36m:[m464[36m:[m80[36m:[m [1m[31mE501[m line too long (89 > 79 characters)
        logger.warning("Aucun modele disponible pour %s (iteration=%s)", role, iteration)
                                                                               ^
[1m.\agents\model_config.py[m[36m:[m482[36m:[m80[36m:[m [1m[31mE501[m line too long (88 > 79 characters)
                "allow_heavy_after_iteration": self.analyst.allow_heavy_after_iteration,
                                                                               ^
[1m.\agents\model_config.py[m[36m:[m486[36m:[m80[36m:[m [1m[31mE501[m line too long (91 > 79 characters)
                "allow_heavy_after_iteration": self.strategist.allow_heavy_after_iteration,
                                                                               ^
[1m.\agents\model_config.py[m[36m:[m490[36m:[m80[36m:[m [1m[31mE501[m line too long (87 > 79 characters)
                "allow_heavy_after_iteration": self.critic.allow_heavy_after_iteration,
                                                                               ^
[1m.\agents\model_config.py[m[36m:[m494[36m:[m80[36m:[m [1m[31mE501[m line too long (90 > 79 characters)
                "allow_heavy_after_iteration": self.validator.allow_heavy_after_iteration,
                                                                               ^
[1m.\agents\model_config.py[m[36m:[m550[36m:[m80[36m:[m [1m[31mE501[m line too long (88 > 79 characters)
        # Fallback: retourner les mod√®les connus (utile pour l'UI quand Ollama est lent)
                                                                               ^
[1m.\agents\ollama_manager.py[m[36m:[m4[36m:[m80[36m:[m [1m[31mE501[m line too long (89 > 79 characters)
"""
Module-ID: agents.ollama_manager

Purpose: G√©rer Ollama (auto-d√©marrage, listage mod√®les, d√©chargement GPU, health checks).

Role in pipeline: orchestration / performance

Key components: LLMMemoryState, GPUMemoryManager, ensure_ollama_running, gpu_compute_context, list_ollama_models

Inputs: Mod√®le name, timeouts, max_attempts

Outputs: √âtat Ollama, mod√®les disponibles, gestion m√©moire GPU (unload/reload)

Dependencies: subprocess, httpx, utils.log, contextlib

Conventions: Ollama lanc√© via subprocess `ollama serve`; retries avec backoff exponentiel; gpu_compute_context d√©charge LLM avant calculs NumPy/CuPy; recharge auto apr√®s.

Read-if: Configuration Ollama, gestion GPU memory, ou troubleshooting service.

Skip-if: Vous utilisez seulement OpenAI.
"""
   
                                

                                         ^
[1m.\agents\ollama_manager.py[m[36m:[m8[36m:[m80[36m:[m [1m[31mE501[m line too long (112 > 79 characters)
"""
Module-ID: agents.ollama_manager

Purpose: G√©rer Ollama (auto-d√©marrage, listage mod√®les, d√©chargement GPU, health checks).

Role in pipeline: orchestration / performance

Key components: LLMMemoryState, GPUMemoryManager, ensure_ollama_running, gpu_compute_context, list_ollama_models

Inputs: Mod√®le name, timeouts, max_attempts

Outputs: √âtat Ollama, mod√®les disponibles, gestion m√©moire GPU (unload/reload)

Dependencies: subprocess, httpx, utils.log, contextlib

Conventions: Ollama lanc√© via subprocess `ollama serve`; retries avec backoff exponentiel; gpu_compute_context d√©charge LLM avant calculs NumPy/CuPy; recharge auto apr√®s.

Read-if: Configuration Ollama, gestion GPU memory, ou troubleshooting service.

Skip-if: Vous utilisez seulement OpenAI.
"""
   
                                

                                         ^
[1m.\agents\ollama_manager.py[m[36m:[m16[36m:[m80[36m:[m [1m[31mE501[m line too long (170 > 79 characters)
"""
Module-ID: agents.ollama_manager

Purpose: G√©rer Ollama (auto-d√©marrage, listage mod√®les, d√©chargement GPU, health checks).

Role in pipeline: orchestration / performance

Key components: LLMMemoryState, GPUMemoryManager, ensure_ollama_running, gpu_compute_context, list_ollama_models

Inputs: Mod√®le name, timeouts, max_attempts

Outputs: √âtat Ollama, mod√®les disponibles, gestion m√©moire GPU (unload/reload)

Dependencies: subprocess, httpx, utils.log, contextlib

Conventions: Ollama lanc√© via subprocess `ollama serve`; retries avec backoff exponentiel; gpu_compute_context d√©charge LLM avant calculs NumPy/CuPy; recharge auto apr√®s.

Read-if: Configuration Ollama, gestion GPU memory, ou troubleshooting service.

Skip-if: Vous utilisez seulement OpenAI.
"""
   
                                

                                         ^
[1m.\agents\ollama_manager.py[m[36m:[m117[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
                    if m.get("name", "").startswith(self.model_name.split(":")[0]):
                                                                               ^
[1m.\agents\ollama_manager.py[m[36m:[m123[36m:[m80[36m:[m [1m[31mE501[m line too long (86 > 79 characters)
    def unload(self, context_messages: Optional[List[dict]] = None) -> LLMMemoryState:
                                                                               ^
[1m.\agents\ollama_manager.py[m[36m:[m158[36m:[m80[36m:[m [1m[31mE501[m line too long (86 > 79 characters)
                            f"({state.unload_time_ms:.0f}ms) ‚Üí GPU libre pour calculs"
                                                                               ^
[1m.\agents\ollama_manager.py[m[36m:[m164[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
                logger.debug(f"üìù LLM {self.model_name} pas en m√©moire, skip unload")
                                                                               ^
[1m.\agents\ollama_manager.py[m[36m:[m191[36m:[m80[36m:[m [1m[31mE501[m line too long (88 > 79 characters)
                logger.debug(f"üìù LLM {self.model_name} n'√©tait pas charg√©, skip reload")
                                                                               ^
[1m.\agents\ollama_manager.py[m[36m:[m202[36m:[m80[36m:[m [1m[31mE501[m line too long (88 > 79 characters)
                    f"Previous context summary: We were optimizing a trading strategy. "
                                                                               ^
[1m.\agents\ollama_manager.py[m[36m:[m227[36m:[m80[36m:[m [1m[31mE501[m line too long (85 > 79 characters)
                logger.warning(f"‚ö†Ô∏è √âchec reload LLM: status {response.status_code}")
                                                                               ^
[1m.\agents\ollama_manager.py[m[36m:[m328[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
                response = httpx.get("http://127.0.0.1:11434/api/tags", timeout=1.0)
                                                                               ^
[1m.\agents\ollama_manager.py[m[36m:[m414[36m:[m80[36m:[m [1m[31mE501[m line too long (93 > 79 characters)
                f"‚ö†Ô∏è Impossible de lister les mod√®les Ollama (status={response.status_code})"
                                                                               ^
[1m.\agents\ollama_manager.py[m[36m:[m429[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
        logger.warning(f"‚ö†Ô∏è Erreur lors de la r√©cup√©ration des mod√®les Ollama: {e}")
                                                                               ^
[1m.\agents\orchestration_logger.py[m[36m:[m4[36m:[m80[36m:[m [1m[31mE501[m line too long (101 > 79 characters)
"""
Module-ID: agents.orchestration_logger

Purpose: Tracer toutes les actions des agents LLM en JSONL avec auto-save thread-safe et callback UI.

Role in pipeline: orchestration / monitoring

Key components: OrchestrationLogger, OrchestrationLogEntry, OrchestrationActionType, get_orchestration_logger

Inputs: action_type, donn√©es contexte, session_id

Outputs: Logs JSONL dans runs/<session>/trace.jsonl, callbacks UI optionnels

Dependencies: pathlib, json, threading, utils.log

Conventions: JSONL auto-flush toutes les N entr√©es; thread-safe via Lock; singleton global; timestamps UTC; callback optionnel pour UI temps r√©el.

Read-if: Ajout types actions, modification format JSONL, ou int√©gration UI.

Skip-if: Vous ne debuggez pas l'orchestration.
"""
   
                                      

                                   ^
[1m.\agents\orchestration_logger.py[m[36m:[m8[36m:[m80[36m:[m [1m[31mE501[m line too long (109 > 79 characters)
"""
Module-ID: agents.orchestration_logger

Purpose: Tracer toutes les actions des agents LLM en JSONL avec auto-save thread-safe et callback UI.

Role in pipeline: orchestration / monitoring

Key components: OrchestrationLogger, OrchestrationLogEntry, OrchestrationActionType, get_orchestration_logger

Inputs: action_type, donn√©es contexte, session_id

Outputs: Logs JSONL dans runs/<session>/trace.jsonl, callbacks UI optionnels

Dependencies: pathlib, json, threading, utils.log

Conventions: JSONL auto-flush toutes les N entr√©es; thread-safe via Lock; singleton global; timestamps UTC; callback optionnel pour UI temps r√©el.

Read-if: Ajout types actions, modification format JSONL, ou int√©gration UI.

Skip-if: Vous ne debuggez pas l'orchestration.
"""
   
                                      

                                   ^
[1m.\agents\orchestration_logger.py[m[36m:[m16[36m:[m80[36m:[m [1m[31mE501[m line too long (146 > 79 characters)
"""
Module-ID: agents.orchestration_logger

Purpose: Tracer toutes les actions des agents LLM en JSONL avec auto-save thread-safe et callback UI.

Role in pipeline: orchestration / monitoring

Key components: OrchestrationLogger, OrchestrationLogEntry, OrchestrationActionType, get_orchestration_logger

Inputs: action_type, donn√©es contexte, session_id

Outputs: Logs JSONL dans runs/<session>/trace.jsonl, callbacks UI optionnels

Dependencies: pathlib, json, threading, utils.log

Conventions: JSONL auto-flush toutes les N entr√©es; thread-safe via Lock; singleton global; timestamps UTC; callback optionnel pour UI temps r√©el.

Read-if: Ajout types actions, modification format JSONL, ou int√©gration UI.

Skip-if: Vous ne debuggez pas l'orchestration.
"""
   
                                      

                                   ^
[1m.\agents\orchestration_logger.py[m[36m:[m208[36m:[m80[36m:[m [1m[31mE501[m line too long (96 > 79 characters)
        """
        Initialize le logger d'orchestration.

        Args:
            session_id: ID unique de session (g√©n√©r√© auto si None)
            auto_save: Si True, sauvegarde auto toutes les 10 entr√©es
            save_path: Chemin personnalis√© pour les logs (d√©faut: runs/{session_id}/trace.jsonl)
            on_event: Callback appel√© √† chaque nouvel √©v√©nement (pour UI temps r√©el)
        """
           
                                             

             
      ^
[1m.\agents\orchestration_logger.py[m[36m:[m209[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
        """
        Initialize le logger d'orchestration.

        Args:
            session_id: ID unique de session (g√©n√©r√© auto si None)
            auto_save: Si True, sauvegarde auto toutes les 10 entr√©es
            save_path: Chemin personnalis√© pour les logs (d√©faut: runs/{session_id}/trace.jsonl)
            on_event: Callback appel√© √† chaque nouvel √©v√©nement (pour UI temps r√©el)
        """
           
                                             

             
      ^
[1m.\agents\orchestration_logger.py[m[36m:[m216[36m:[m80[36m:[m [1m[31mE501[m line too long (85 > 79 characters)
        self._save_path = save_path or Path("runs") / self.session_id / "trace.jsonl"
                                                                               ^
[1m.\agents\orchestration_logger.py[m[36m:[m249[36m:[m80[36m:[m [1m[31mE501[m line too long (85 > 79 characters)
            # Garder current_iteration coh√©rent (utile si l'appelant passe iteration)
                                                                               ^
[1m.\agents\orchestration_logger.py[m[36m:[m251[36m:[m80[36m:[m [1m[31mE501[m line too long (90 > 79 characters)
                self.current_iteration = max(self.current_iteration, int(entry.iteration))
                                                                               ^
[1m.\agents\orchestration_logger.py[m[36m:[m269[36m:[m80[36m:[m [1m[31mE501[m line too long (87 > 79 characters)
        logger.info(f"[{agent}] Analysis started - Iteration {self.current_iteration}")
                                                                               ^
[1m.\agents\orchestration_logger.py[m[36m:[m332[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
        logger.info(f"[{agent}] Strategy changed: {old_strategy} ‚Üí {new_strategy}")
                                                                               ^
[1m.\agents\orchestration_logger.py[m[36m:[m393[36m:[m80[36m:[m [1m[31mE501[m line too long (92 > 79 characters)
        status = OrchestrationStatus.VALIDATED if is_valid else OrchestrationStatus.REJECTED
                                                                               ^
[1m.\agents\orchestration_logger.py[m[36m:[m432[36m:[m80[36m:[m [1m[31mE501[m line too long (90 > 79 characters)
        logger.info(f"[{agent}] Backtest launched: {combination_id}/{total_combinations}")
                                                                               ^
[1m.\agents\orchestration_logger.py[m[36m:[m460[36m:[m80[36m:[m [1m[31mE501[m line too long (108 > 79 characters)
        logger.info(f"[{agent}] Backtest #{combination_id} complete - PnL: {pnl:.2f}, Sharpe: {sharpe:.2f}")
                                                                               ^
[1m.\agents\orchestration_logger.py[m[36m:[m497[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
            "change_approach": OrchestrationActionType.DECISION_CHANGE_APPROACH,
                                                                               ^
[1m.\agents\orchestration_logger.py[m[36m:[m502[36m:[m80[36m:[m [1m[31mE501[m line too long (97 > 79 characters)
            action_type=action_map.get(decision_type, OrchestrationActionType.DECISION_CONTINUE),
                                                                               ^
[1m.\agents\orchestration_logger.py[m[36m:[m568[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
    def get_logs_for_iteration(self, iteration: int) -> List[OrchestrationLogEntry]:
                                                                               ^
[1m.\agents\orchestration_logger.py[m[36m:[m576[36m:[m80[36m:[m [1m[31mE501[m line too long (100 > 79 characters)
    def get_logs_by_type(self, action_type: OrchestrationActionType) -> List[OrchestrationLogEntry]:
                                                                               ^
[1m.\agents\orchestration_logger.py[m[36m:[m582[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
        """
        Sauvegarde les logs dans un fichier JSON (legacy, pr√©f√©rer save_to_jsonl).

        Args:
            filepath: Chemin du fichier JSON (d√©faut: orchestration_logs_{session}.json)
        """
           
                                                                   ^
[1m.\agents\orchestration_logger.py[m[36m:[m585[36m:[m80[36m:[m [1m[31mE501[m line too long (88 > 79 characters)
        """
        Sauvegarde les logs dans un fichier JSON (legacy, pr√©f√©rer save_to_jsonl).

        Args:
            filepath: Chemin du fichier JSON (d√©faut: orchestration_logs_{session}.json)
        """
           
                                                                   ^
[1m.\agents\orchestration_logger.py[m[36m:[m607[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
        """
        Sauvegarde les logs en format JSONL (une ligne par √©v√©nement).

        Args:
            filepath: Chemin du fichier JSONL (d√©faut: runs/{session}/trace.jsonl)
        """
           
                                                                   ^
[1m.\agents\orchestration_logger.py[m[36m:[m653[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
        if filepath.suffix == ".jsonl" or first_line.startswith('{"event_type"'):
                                                                               ^
[1m.\agents\orchestration_logger.py[m[36m:[m764[36m:[m80[36m:[m [1m[31mE501[m line too long (86 > 79 characters)
def get_orchestration_logger(session_id: Optional[str] = None) -> OrchestrationLogger:
                                                                               ^
[1m.\agents\orchestrator.py[m[36m:[m4[36m:[m80[36m:[m [1m[31mE501[m line too long (119 > 79 characters)
"""
Module-ID: agents.orchestrator

Purpose: Orchestrer le workflow multi-agents (Analyst/Strategist/Critic/Validator) et piloter la boucle d‚Äôoptimisation.

Role in pipeline: orchestration

Key components: OrchestratorConfig, Orchestrator, StateMachine, ValidationResult, run_walk_forward_for_agent

Inputs: LLMConfig/clients, callbacks (on_backtest_needed), donn√©es (path/df), param√®tres initiaux et contraintes

Outputs: D√©cision finale (APPROVED/REJECTED/FAILED), historiques d‚Äôit√©rations, logs/m√©moire LLM, suivi param√®tres

Dependencies: agents.state_machine, agents.*Agent, agents.integration, agents.model_config, utils.llm_memory, utils.session_param_tracker

Conventions: √âtats INIT‚ÜíANALYZE‚ÜíPROPOSE‚ÜíCRITIQUE‚ÜíVALIDATE‚ÜíITERATE; ABORT mappe sur FAILED; timestamps en UTC si utilis√©s.

Read-if: Vous touchez aux transitions, crit√®res d‚Äôarr√™t, m√©moire/logs, ou au wiring des agents.

Skip-if: Vous ne modifiez qu‚Äôun agent isol√© ou le moteur de backtest pur.
"""
   
                              

                                           ^
[1m.\agents\orchestrator.py[m[36m:[m8[36m:[m80[36m:[m [1m[31mE501[m line too long (108 > 79 characters)
"""
Module-ID: agents.orchestrator

Purpose: Orchestrer le workflow multi-agents (Analyst/Strategist/Critic/Validator) et piloter la boucle d‚Äôoptimisation.

Role in pipeline: orchestration

Key components: OrchestratorConfig, Orchestrator, StateMachine, ValidationResult, run_walk_forward_for_agent

Inputs: LLMConfig/clients, callbacks (on_backtest_needed), donn√©es (path/df), param√®tres initiaux et contraintes

Outputs: D√©cision finale (APPROVED/REJECTED/FAILED), historiques d‚Äôit√©rations, logs/m√©moire LLM, suivi param√®tres

Dependencies: agents.state_machine, agents.*Agent, agents.integration, agents.model_config, utils.llm_memory, utils.session_param_tracker

Conventions: √âtats INIT‚ÜíANALYZE‚ÜíPROPOSE‚ÜíCRITIQUE‚ÜíVALIDATE‚ÜíITERATE; ABORT mappe sur FAILED; timestamps en UTC si utilis√©s.

Read-if: Vous touchez aux transitions, crit√®res d‚Äôarr√™t, m√©moire/logs, ou au wiring des agents.

Skip-if: Vous ne modifiez qu‚Äôun agent isol√© ou le moteur de backtest pur.
"""
   
                              

                                           ^
[1m.\agents\orchestrator.py[m[36m:[m10[36m:[m80[36m:[m [1m[31mE501[m line too long (112 > 79 characters)
"""
Module-ID: agents.orchestrator

Purpose: Orchestrer le workflow multi-agents (Analyst/Strategist/Critic/Validator) et piloter la boucle d‚Äôoptimisation.

Role in pipeline: orchestration

Key components: OrchestratorConfig, Orchestrator, StateMachine, ValidationResult, run_walk_forward_for_agent

Inputs: LLMConfig/clients, callbacks (on_backtest_needed), donn√©es (path/df), param√®tres initiaux et contraintes

Outputs: D√©cision finale (APPROVED/REJECTED/FAILED), historiques d‚Äôit√©rations, logs/m√©moire LLM, suivi param√®tres

Dependencies: agents.state_machine, agents.*Agent, agents.integration, agents.model_config, utils.llm_memory, utils.session_param_tracker

Conventions: √âtats INIT‚ÜíANALYZE‚ÜíPROPOSE‚ÜíCRITIQUE‚ÜíVALIDATE‚ÜíITERATE; ABORT mappe sur FAILED; timestamps en UTC si utilis√©s.

Read-if: Vous touchez aux transitions, crit√®res d‚Äôarr√™t, m√©moire/logs, ou au wiring des agents.

Skip-if: Vous ne modifiez qu‚Äôun agent isol√© ou le moteur de backtest pur.
"""
   
                              

                                           ^
[1m.\agents\orchestrator.py[m[36m:[m12[36m:[m80[36m:[m [1m[31mE501[m line too long (113 > 79 characters)
"""
Module-ID: agents.orchestrator

Purpose: Orchestrer le workflow multi-agents (Analyst/Strategist/Critic/Validator) et piloter la boucle d‚Äôoptimisation.

Role in pipeline: orchestration

Key components: OrchestratorConfig, Orchestrator, StateMachine, ValidationResult, run_walk_forward_for_agent

Inputs: LLMConfig/clients, callbacks (on_backtest_needed), donn√©es (path/df), param√®tres initiaux et contraintes

Outputs: D√©cision finale (APPROVED/REJECTED/FAILED), historiques d‚Äôit√©rations, logs/m√©moire LLM, suivi param√®tres

Dependencies: agents.state_machine, agents.*Agent, agents.integration, agents.model_config, utils.llm_memory, utils.session_param_tracker

Conventions: √âtats INIT‚ÜíANALYZE‚ÜíPROPOSE‚ÜíCRITIQUE‚ÜíVALIDATE‚ÜíITERATE; ABORT mappe sur FAILED; timestamps en UTC si utilis√©s.

Read-if: Vous touchez aux transitions, crit√®res d‚Äôarr√™t, m√©moire/logs, ou au wiring des agents.

Skip-if: Vous ne modifiez qu‚Äôun agent isol√© ou le moteur de backtest pur.
"""
   
                              

                                           ^
[1m.\agents\orchestrator.py[m[36m:[m14[36m:[m80[36m:[m [1m[31mE501[m line too long (137 > 79 characters)
"""
Module-ID: agents.orchestrator

Purpose: Orchestrer le workflow multi-agents (Analyst/Strategist/Critic/Validator) et piloter la boucle d‚Äôoptimisation.

Role in pipeline: orchestration

Key components: OrchestratorConfig, Orchestrator, StateMachine, ValidationResult, run_walk_forward_for_agent

Inputs: LLMConfig/clients, callbacks (on_backtest_needed), donn√©es (path/df), param√®tres initiaux et contraintes

Outputs: D√©cision finale (APPROVED/REJECTED/FAILED), historiques d‚Äôit√©rations, logs/m√©moire LLM, suivi param√®tres

Dependencies: agents.state_machine, agents.*Agent, agents.integration, agents.model_config, utils.llm_memory, utils.session_param_tracker

Conventions: √âtats INIT‚ÜíANALYZE‚ÜíPROPOSE‚ÜíCRITIQUE‚ÜíVALIDATE‚ÜíITERATE; ABORT mappe sur FAILED; timestamps en UTC si utilis√©s.

Read-if: Vous touchez aux transitions, crit√®res d‚Äôarr√™t, m√©moire/logs, ou au wiring des agents.

Skip-if: Vous ne modifiez qu‚Äôun agent isol√© ou le moteur de backtest pur.
"""
   
                              

                                           ^
[1m.\agents\orchestrator.py[m[36m:[m16[36m:[m80[36m:[m [1m[31mE501[m line too long (121 > 79 characters)
"""
Module-ID: agents.orchestrator

Purpose: Orchestrer le workflow multi-agents (Analyst/Strategist/Critic/Validator) et piloter la boucle d‚Äôoptimisation.

Role in pipeline: orchestration

Key components: OrchestratorConfig, Orchestrator, StateMachine, ValidationResult, run_walk_forward_for_agent

Inputs: LLMConfig/clients, callbacks (on_backtest_needed), donn√©es (path/df), param√®tres initiaux et contraintes

Outputs: D√©cision finale (APPROVED/REJECTED/FAILED), historiques d‚Äôit√©rations, logs/m√©moire LLM, suivi param√®tres

Dependencies: agents.state_machine, agents.*Agent, agents.integration, agents.model_config, utils.llm_memory, utils.session_param_tracker

Conventions: √âtats INIT‚ÜíANALYZE‚ÜíPROPOSE‚ÜíCRITIQUE‚ÜíVALIDATE‚ÜíITERATE; ABORT mappe sur FAILED; timestamps en UTC si utilis√©s.

Read-if: Vous touchez aux transitions, crit√®res d‚Äôarr√™t, m√©moire/logs, ou au wiring des agents.

Skip-if: Vous ne modifiez qu‚Äôun agent isol√© ou le moteur de backtest pur.
"""
   
                              

                                           ^
[1m.\agents\orchestrator.py[m[36m:[m18[36m:[m80[36m:[m [1m[31mE501[m line too long (95 > 79 characters)
"""
Module-ID: agents.orchestrator

Purpose: Orchestrer le workflow multi-agents (Analyst/Strategist/Critic/Validator) et piloter la boucle d‚Äôoptimisation.

Role in pipeline: orchestration

Key components: OrchestratorConfig, Orchestrator, StateMachine, ValidationResult, run_walk_forward_for_agent

Inputs: LLMConfig/clients, callbacks (on_backtest_needed), donn√©es (path/df), param√®tres initiaux et contraintes

Outputs: D√©cision finale (APPROVED/REJECTED/FAILED), historiques d‚Äôit√©rations, logs/m√©moire LLM, suivi param√®tres

Dependencies: agents.state_machine, agents.*Agent, agents.integration, agents.model_config, utils.llm_memory, utils.session_param_tracker

Conventions: √âtats INIT‚ÜíANALYZE‚ÜíPROPOSE‚ÜíCRITIQUE‚ÜíVALIDATE‚ÜíITERATE; ABORT mappe sur FAILED; timestamps en UTC si utilis√©s.

Read-if: Vous touchez aux transitions, crit√®res d‚Äôarr√™t, m√©moire/logs, ou au wiring des agents.

Skip-if: Vous ne modifiez qu‚Äôun agent isol√© ou le moteur de backtest pur.
"""
   
                              

                                           ^
[1m.\agents\orchestrator.py[m[36m:[m48[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
from .base_agent import AgentContext, BaseAgent, MetricsSnapshot, ParameterConfig
                                                                               ^
[1m.\agents\orchestrator.py[m[36m:[m121[36m:[m80[36m:[m [1m[31mE501[m line too long (93 > 79 characters)
    walk_forward_disabled_reason: Optional[str] = None  # Raison si d√©sactiv√© automatiquement
                                                                               ^
[1m.\agents\orchestrator.py[m[36m:[m125[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
    on_iteration_complete: Optional[Callable[[int, Dict[str, Any]], None]] = None
                                                                               ^
[1m.\agents\orchestrator.py[m[36m:[m126[36m:[m80[36m:[m [1m[31mE501[m line too long (91 > 79 characters)
    on_backtest_needed: Optional[Callable[[Dict[str, Any]], "AgentBacktestMetrics"]] = None
                                                                               ^
[1m.\agents\orchestrator.py[m[36m:[m194[36m:[m80[36m:[m [1m[31mE501[m line too long (108 > 79 characters)
        elif config.orchestration_logger is not None and hasattr(config.orchestration_logger, "session_id"):
                                                                               ^
[1m.\agents\orchestrator.py[m[36m:[m195[36m:[m80[36m:[m [1m[31mE501[m line too long (85 > 79 characters)
            self.session_id = str(getattr(config.orchestration_logger, "session_id"))
                                                                               ^
[1m.\agents\orchestrator.py[m[36m:[m202[36m:[m80[36m:[m [1m[31mE501[m line too long (96 > 79 characters)
        self._max_iter_label = "‚àû" if self._unlimited_iterations else str(config.max_iterations)
                                                                               ^
[1m.\agents\orchestrator.py[m[36m:[m220[36m:[m80[36m:[m [1m[31mE501[m line too long (86 > 79 characters)
        self._total_combinations_tested = 0  # Compteur de budget (sweep + individual)
                                                                               ^
[1m.\agents\orchestrator.py[m[36m:[m236[36m:[m80[36m:[m [1m[31mE501[m line too long (87 > 79 characters)
        # Session Parameter Tracker - emp√™che les LLMs de retester les m√™mes param√®tres
                                                                               ^
[1m.\agents\orchestrator.py[m[36m:[m237[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
        self.param_tracker = SessionParameterTracker(session_id=self.session_id)
                                                                               ^
[1m.\agents\orchestrator.py[m[36m:[m240[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
        self._loaded_data: Optional["pd.DataFrame"] = getattr(config, "data", None)
                                                                               ^
[1m.\agents\orchestrator.py[m[36m:[m272[36m:[m80[36m:[m [1m[31mE501[m line too long (86 > 79 characters)
        """Initialise un logger d'orchestration s'il est disponible (non bloquant)."""
                                                                               ^
[1m.\agents\orchestrator.py[m[36m:[m279[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
            from .orchestration_logger import OrchestrationLogger  # type: ignore
                                                                               ^
[1m.\agents\orchestrator.py[m[36m:[m300[36m:[m80[36m:[m [1m[31mE501[m line too long (86 > 79 characters)
                self._orch_logger.log(event_type, entry)  # type: ignore[attr-defined]
                                                                               ^
[1m.\agents\orchestrator.py[m[36m:[m302[36m:[m80[36m:[m [1m[31mE501[m line too long (92 > 79 characters)
                self._orch_logger.add_event(event_type, entry)  # type: ignore[attr-defined]
                                                                               ^
[1m.\agents\orchestrator.py[m[36m:[m309[36m:[m43[36m:[m [1m[31mF821[m undefined name 'AgentResult'
    def _handle_llm_failure(self, result: AgentResult, role: str) -> bool:
                                          ^
[1m.\agents\orchestrator.py[m[36m:[m322[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
        if any("LLM n'a pas retourn√© de r√©ponse" in err for err in result.errors):
                                                                               ^
[1m.\agents\orchestrator.py[m[36m:[m336[36m:[m80[36m:[m [1m[31mE501[m line too long (86 > 79 characters)
        if self._consecutive_llm_failures >= self.config.max_consecutive_llm_failures:
                                                                               ^
[1m.\agents\orchestrator.py[m[36m:[m371[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
        symbol = self.config.data_symbol or self.context.data_symbol or "unknown"
                                                                               ^
[1m.\agents\orchestrator.py[m[36m:[m372[36m:[m80[36m:[m [1m[31mE501[m line too long (90 > 79 characters)
        timeframe = self.config.data_timeframe or self.context.data_timeframe or "unknown"
                                                                               ^
[1m.\agents\orchestrator.py[m[36m:[m385[36m:[m80[36m:[m [1m[31mE501[m line too long (85 > 79 characters)
            period_start, period_end = split_date_range(self.context.data_date_range)
                                                                               ^
[1m.\agents\orchestrator.py[m[36m:[m389[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
                self.context.data_date_range = f"{period_start} -> {period_end}"
                                                                               ^
[1m.\agents\orchestrator.py[m[36m:[m457[36m:[m80[36m:[m [1m[31mE501[m line too long (91 > 79 characters)
    def _build_history_entry(self, result: OrchestratorResult) -> Optional[Dict[str, Any]]:
                                                                               ^
[1m.\agents\orchestrator.py[m[36m:[m473[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
        model = self._role_models.get("validator") or self.llm_client.config.model
                                                                               ^
[1m.\agents\orchestrator.py[m[36m:[m485[36m:[m80[36m:[m [1m[31mE501[m line too long (110 > 79 characters)
            "timestamp": datetime.now(timezone.utc).replace(microsecond=0).isoformat().replace("+00:00", "Z"),
                                                                               ^
[1m.\agents\orchestrator.py[m[36m:[m500[36m:[m80[36m:[m [1m[31mE501[m line too long (88 > 79 characters)
            entry["validator_confidence"] = self._last_validation_data.get("confidence")
                                                                               ^
[1m.\agents\orchestrator.py[m[36m:[m574[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
        # - Docstring de module normalis√©e (LLM-friendly) et orient√©e orchestration
                                                                               ^
[1m.\agents\orchestrator.py[m[36m:[m575[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
        # - Conventions d‚Äô√©tats/terminaison explicit√©es pour √©viter les ambigu√Øt√©s
                                                                               ^
[1m.\agents\orchestrator.py[m[36m:[m606[36m:[m80[36m:[m [1m[31mE501[m line too long (86 > 79 characters)
                self.config.on_state_change(current, self.state_machine.current_state)
                                                                               ^
[1m.\agents\orchestrator.py[m[36m:[m621[36m:[m80[36m:[m [1m[31mE501[m line too long (105 > 79 characters)
            self._log_event("config_invalid", errors=validation.errors or [], message=validation.message)
                                                                               ^
[1m.\agents\orchestrator.py[m[36m:[m622[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
            self.state_machine.fail(f"Configuration invalide: {validation.message}")
                                                                               ^
[1m.\agents\orchestrator.py[m[36m:[m641[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
                    f"Backtest initial: Sharpe={initial_metrics.sharpe_ratio:.3f}, "
                                                                               ^
[1m.\agents\orchestrator.py[m[36m:[m646[36m:[m80[36m:[m [1m[31mE501[m line too long (85 > 79 characters)
                self._log_event("warning", message="Backtest initial sans m√©triques")
                                                                               ^
[1m.\agents\orchestrator.py[m[36m:[m654[36m:[m80[36m:[m [1m[31mE501[m line too long (97 > 79 characters)
            logger.warning("Backtest initial √©chou√©, utilisation de m√©triques par d√©faut (z√©ro)")
                                                                               ^
[1m.\agents\orchestrator.py[m[36m:[m665[36m:[m80[36m:[m [1m[31mE501[m line too long (90 > 79 characters)
            self._warnings.append("Utilisation de m√©triques par d√©faut (backtest √©chou√©)")
                                                                               ^
[1m.\agents\orchestrator.py[m[36m:[m666[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
            self._log_event("warning", message="M√©triques par d√©faut utilis√©es")
                                                                               ^
[1m.\agents\orchestrator.py[m[36m:[m672[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
        if not self._indicator_context_cached and self._loaded_data is not None:
                                                                               ^
[1m.\agents\orchestrator.py[m[36m:[m680[36m:[m80[36m:[m [1m[31mE501[m line too long (92 > 79 characters)
                self.context.strategy_indicators_context = indicator_ctx.get("strategy", "")
                                                                               ^
[1m.\agents\orchestrator.py[m[36m:[m681[36m:[m80[36m:[m [1m[31mE501[m line too long (93 > 79 characters)
                self.context.readonly_indicators_context = indicator_ctx.get("read_only", "")
                                                                               ^
[1m.\agents\orchestrator.py[m[36m:[m682[36m:[m80[36m:[m [1m[31mE501[m line too long (91 > 79 characters)
                self.context.indicator_context_warnings = indicator_ctx.get("warnings", [])
                                                                               ^
[1m.\agents\orchestrator.py[m[36m:[m686[36m:[m80[36m:[m [1m[31mE501[m line too long (89 > 79 characters)
                    strategy_indicators_context=self.context.strategy_indicators_context,
                                                                               ^
[1m.\agents\orchestrator.py[m[36m:[m687[36m:[m80[36m:[m [1m[31mE501[m line too long (89 > 79 characters)
                    readonly_indicators_context=self.context.readonly_indicators_context,
                                                                               ^
[1m.\agents\orchestrator.py[m[36m:[m691[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
                self._warnings.append(f"Contexte indicateurs indisponible: {exc}")
                                                                               ^
[1m.\agents\orchestrator.py[m[36m:[m710[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
            # Ajouter dynamiquement au contexte (pour ne pas modifier base_agent.py)
                                                                               ^
[1m.\agents\orchestrator.py[m[36m:[m717[36m:[m80[36m:[m [1m[31mE501[m line too long (92 > 79 characters)
        # Contexte indicateurs (strat√©gie vs lecture seule) - calcul√© une seule fois par run
                                                                               ^
[1m.\agents\orchestrator.py[m[36m:[m718[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
        if not self._indicator_context_cached and self._loaded_data is not None:
                                                                               ^
[1m.\agents\orchestrator.py[m[36m:[m726[36m:[m80[36m:[m [1m[31mE501[m line too long (92 > 79 characters)
                self.context.strategy_indicators_context = indicator_ctx.get("strategy", "")
                                                                               ^
[1m.\agents\orchestrator.py[m[36m:[m727[36m:[m80[36m:[m [1m[31mE501[m line too long (93 > 79 characters)
                self.context.readonly_indicators_context = indicator_ctx.get("read_only", "")
                                                                               ^
[1m.\agents\orchestrator.py[m[36m:[m728[36m:[m80[36m:[m [1m[31mE501[m line too long (91 > 79 characters)
                self.context.indicator_context_warnings = indicator_ctx.get("warnings", [])
                                                                               ^
[1m.\agents\orchestrator.py[m[36m:[m732[36m:[m80[36m:[m [1m[31mE501[m line too long (89 > 79 characters)
                    strategy_indicators_context=self.context.strategy_indicators_context,
                                                                               ^
[1m.\agents\orchestrator.py[m[36m:[m733[36m:[m80[36m:[m [1m[31mE501[m line too long (89 > 79 characters)
                    readonly_indicators_context=self.context.readonly_indicators_context,
                                                                               ^
[1m.\agents\orchestrator.py[m[36m:[m737[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
                self._warnings.append(f"Contexte indicateurs indisponible: {exc}")
                                                                               ^
[1m.\agents\orchestrator.py[m[36m:[m745[36m:[m80[36m:[m [1m[31mE501[m line too long (98 > 79 characters)
        self._log_event("agent_execute_start", role="analyst", model=self.llm_client.config.model)
                                                                               ^
[1m.\agents\orchestrator.py[m[36m:[m749[36m:[m80[36m:[m [1m[31mE501[m line too long (99 > 79 characters)
        self._log_event("agent_execute_end", role="analyst", success=result.success, latency_ms=dt)
                                                                               ^
[1m.\agents\orchestrator.py[m[36m:[m756[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
            self._log_event("error", scope="analyst", message=str(result.errors))
                                                                               ^
[1m.\agents\orchestrator.py[m[36m:[m769[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
                transition = self.state_machine.transition_to(AgentState.VALIDATE)
                                                                               ^
[1m.\agents\orchestrator.py[m[36m:[m775[36m:[m80[36m:[m [1m[31mE501[m line too long (85 > 79 characters)
                    self.state_machine.transition_to(AgentState.VALIDATE, force=True)
                                                                               ^
[1m.\agents\orchestrator.py[m[36m:[m796[36m:[m80[36m:[m [1m[31mE501[m line too long (101 > 79 characters)
        self._log_event("agent_execute_start", role="strategist", model=self.llm_client.config.model)
                                                                               ^
[1m.\agents\orchestrator.py[m[36m:[m800[36m:[m80[36m:[m [1m[31mE501[m line too long (102 > 79 characters)
        self._log_event("agent_execute_end", role="strategist", success=result.success, latency_ms=dt)
                                                                               ^
[1m.\agents\orchestrator.py[m[36m:[m807[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
            self._log_event("error", scope="strategist", message=str(result.errors))
                                                                               ^
[1m.\agents\orchestrator.py[m[36m:[m837[36m:[m80[36m:[m [1m[31mE501[m line too long (92 > 79 characters)
                    f"  ‚ö†Ô∏è Proposition ignor√©e (d√©j√† test√©e): {proposal.get('name', 'N/A')}"
                                                                               ^
[1m.\agents\orchestrator.py[m[36m:[m857[36m:[m80[36m:[m [1m[31mE501[m line too long (96 > 79 characters)
            logger.warning("Toutes les propositions sont des duplications - passage √† VALIDATE")
                                                                               ^
[1m.\agents\orchestrator.py[m[36m:[m869[36m:[m80[36m:[m [1m[31mE501[m line too long (86 > 79 characters)
        """
        G√®re un sweep request du Strategist (grid search).

        Args:
            sweep_request: Dict avec ranges, rationale, optimize_for, max_combinations
        """
           
                                                          

       ^
[1m.\agents\orchestrator.py[m[36m:[m872[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
        logger.info(f"  Sweep rationale: {sweep_request.get('rationale', 'N/A')}")
                                                                               ^
[1m.\agents\orchestrator.py[m[36m:[m877[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
                f"‚ö†Ô∏è Limite de sweeps atteinte ({self._max_sweeps_per_session}). "
                                                                               ^
[1m.\agents\orchestrator.py[m[36m:[m881[36m:[m80[36m:[m [1m[31mE501[m line too long (96 > 79 characters)
                f"Sweep limit reached ({self._sweeps_performed}/{self._max_sweeps_per_session})"
                                                                               ^
[1m.\agents\orchestrator.py[m[36m:[m936[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
                raise ValueError("Impossible d'extraire param_specs du contexte")
                                                                               ^
[1m.\agents\orchestrator.py[m[36m:[m940[36m:[m80[36m:[m [1m[31mE501[m line too long (91 > 79 characters)
                logger.error("Sweep impossible: donn√©es non disponibles dans orchestrator")
                                                                               ^
[1m.\agents\orchestrator.py[m[36m:[m955[36m:[m80[36m:[m [1m[31mE501[m line too long (90 > 79 characters)
                initial_capital=10000.0,  # Utiliser capital depuis contexte si disponible
                                                                               ^
[1m.\agents\orchestrator.py[m[36m:[m974[36m:[m80[36m:[m [1m[31mE501[m line too long (102 > 79 characters)
                f"‚úÖ Sweep #{self._sweeps_performed} termin√©: {n_combinations} combinaisons test√©es | "
                                                                               ^
[1m.\agents\orchestrator.py[m[36m:[m975[36m:[m80[36m:[m [1m[31mE501[m line too long (128 > 79 characters)
                f"Best {range_proposal.optimize_for}={sweep_results['best_metrics'].get(range_proposal.optimize_for, 0):.3f} | "
                                                                               ^
[1m.\agents\orchestrator.py[m[36m:[m976[36m:[m80[36m:[m [1m[31mE501[m line too long (90 > 79 characters)
                f"Budget: {self._total_combinations_tested}/{self._max_iter_label} combos"
                                                                               ^
[1m.\agents\orchestrator.py[m[36m:[m993[36m:[m80[36m:[m [1m[31mE501[m line too long (149 > 79 characters)
                "name": f"Sweep Best Config ({range_proposal.optimize_for}={sweep_results['best_metrics'].get(range_proposal.optimize_for, 0):.3f})",
                                                                               ^
[1m.\agents\orchestrator.py[m[36m:[m997[36m:[m80[36m:[m [1m[31mE501[m line too long (89 > 79 characters)
                "rationale": f"Best config from grid search: {range_proposal.rationale}",
                                                                               ^
[1m.\agents\orchestrator.py[m[36m:[m1003[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
            logger.info(f"  Meilleurs param√®tres: {sweep_results['best_params']}")
                                                                               ^
[1m.\agents\orchestrator.py[m[36m:[m1024[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
            self._log_event("warning", message="Aucune proposition √† critiquer")
                                                                               ^
[1m.\agents\orchestrator.py[m[36m:[m1030[36m:[m80[36m:[m [1m[31mE501[m line too long (97 > 79 characters)
        self._log_event("agent_execute_start", role="critic", model=self.llm_client.config.model)
                                                                               ^
[1m.\agents\orchestrator.py[m[36m:[m1034[36m:[m80[36m:[m [1m[31mE501[m line too long (98 > 79 characters)
        self._log_event("agent_execute_end", role="critic", success=result.success, latency_ms=dt)
                                                                               ^
[1m.\agents\orchestrator.py[m[36m:[m1041[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
            self._log_event("error", scope="critic", message=str(result.errors))
                                                                               ^
[1m.\agents\orchestrator.py[m[36m:[m1076[36m:[m80[36m:[m [1m[31mE501[m line too long (100 > 79 characters)
        self._log_event("agent_execute_start", role="validator", model=self.llm_client.config.model)
                                                                               ^
[1m.\agents\orchestrator.py[m[36m:[m1080[36m:[m80[36m:[m [1m[31mE501[m line too long (101 > 79 characters)
        self._log_event("agent_execute_end", role="validator", success=result.success, latency_ms=dt)
                                                                               ^
[1m.\agents\orchestrator.py[m[36m:[m1087[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
            self._log_event("error", scope="validator", message=str(result.errors))
                                                                               ^
[1m.\agents\orchestrator.py[m[36m:[m1152[36m:[m80[36m:[m [1m[31mE501[m line too long (96 > 79 characters)
                {"metrics": self.context.current_metrics, "params": self.context.current_params}
                                                                               ^
[1m.\agents\orchestrator.py[m[36m:[m1155[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
        # V√©rifier le budget de combinaisons test√©es avant la prochaine it√©ration
                                                                               ^
[1m.\agents\orchestrator.py[m[36m:[m1156[36m:[m80[36m:[m [1m[31mE501[m line too long (110 > 79 characters)
        if (not self._unlimited_iterations) and self._total_combinations_tested >= self.config.max_iterations:
                                                                               ^
[1m.\agents\orchestrator.py[m[36m:[m1158[36m:[m80[36m:[m [1m[31mE501[m line too long (86 > 79 characters)
                f"‚ö†Ô∏è Budget √©puis√©: {self._total_combinations_tested} combos test√©es "
                                                                               ^
[1m.\agents\orchestrator.py[m[36m:[m1159[36m:[m80[36m:[m [1m[31mE501[m line too long (95 > 79 characters)
                f"(limite: {self.config.max_iterations}, dont {self._sweeps_performed} sweeps)"
                                                                               ^
[1m.\agents\orchestrator.py[m[36m:[m1162[36m:[m80[36m:[m [1m[31mE501[m line too long (103 > 79 characters)
                f"Budget √©puis√©: {self._total_combinations_tested}/{self.config.max_iterations} combos"
                                                                               ^
[1m.\agents\orchestrator.py[m[36m:[m1180[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
                errors.append(f"data_path n'existe pas: {self.config.data_path}")
                                                                               ^
[1m.\agents\orchestrator.py[m[36m:[m1192[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
    def _run_backtest(self, params: Dict[str, Any]) -> Optional[MetricsSnapshot]:
                                                                               ^
[1m.\agents\orchestrator.py[m[36m:[m1200[36m:[m80[36m:[m [1m[31mE501[m line too long (88 > 79 characters)
        self._total_combinations_tested += 1  # Compter cette combinaison vers le budget
                                                                               ^
[1m.\agents\orchestrator.py[m[36m:[m1225[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
        """
        Calcule les m√©triques de walk-forward validation et met √† jour le contexte.

        Charge les donn√©es si n√©cessaire et ex√©cute une validation walk-forward
        pour d√©tecter l'overfitting avec les m√©triques robustes.
        """
           
                                                                   ^
[1m.\agents\orchestrator.py[m[36m:[m1248[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
                self.context.overfitting_ratio = wf_metrics["overfitting_ratio"]
                                                                               ^
[1m.\agents\orchestrator.py[m[36m:[m1251[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
                self.context.test_stability_std = wf_metrics["test_stability_std"]
                                                                               ^
[1m.\agents\orchestrator.py[m[36m:[m1264[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
                logger.warning(f"√âchec du calcul des m√©triques walk-forward: {e}")
                                                                               ^
[1m.\agents\orchestrator.py[m[36m:[m1272[36m:[m80[36m:[m [1m[31mE501[m line too long (86 > 79 characters)
            logger.debug("Pas de data/data_path configur√©, skip walk-forward metrics")
                                                                               ^
[1m.\agents\orchestrator.py[m[36m:[m1292[36m:[m80[36m:[m [1m[31mE501[m line too long (96 > 79 characters)
                    logger.warning(f"Format non support√© pour walk-forward: {data_path.suffix}")
                                                                               ^
[1m.\agents\orchestrator.py[m[36m:[m1295[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
                logger.info(f"  Donn√©es charg√©es: {len(self._loaded_data)} lignes")
                                                                               ^
[1m.\agents\orchestrator.py[m[36m:[m1301[36m:[m80[36m:[m [1m[31mE501[m line too long (95 > 79 characters)
            if 'timestamp' in self._loaded_data.columns or 'date' in self._loaded_data.columns:
                                                                               ^
[1m.\agents\orchestrator.py[m[36m:[m1302[36m:[m80[36m:[m [1m[31mE501[m line too long (94 > 79 characters)
                date_col = 'timestamp' if 'timestamp' in self._loaded_data.columns else 'date'
                                                                               ^
[1m.\agents\orchestrator.py[m[36m:[m1306[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
                    self.context.data_date_range = f"{dates.min()} ‚Üí {dates.max()}"
                                                                               ^
[1m.\agents\orchestrator.py[m[36m:[m1357[36m:[m80[36m:[m [1m[31mE501[m line too long (100 > 79 characters)
        def _eval_one(proposal: Dict[str, Any]) -> tuple[Dict[str, Any], Optional[MetricsSnapshot]]:
                                                                               ^
[1m.\agents\orchestrator.py[m[36m:[m1386[36m:[m80[36m:[m [1m[31mE501[m line too long (93 > 79 characters)
                logger.info(f"Test proposition {proposal.get('id')}: {proposal.get('name')}")
                                                                               ^
[1m.\agents\orchestrator.py[m[36m:[m1532[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
        """G√©n√®re un rapport final d√©taill√© incluant les statistiques du tracker."""
                                                                               ^
[1m.\agents\orchestrator.py[m[36m:[m1543[36m:[m80[36m:[m [1m[31mE501[m line too long (91 > 79 characters)
            f"üîç Sweeps effectu√©s: {self._sweeps_performed}/{self._max_sweeps_per_session}",
                                                                               ^
[1m.\agents\orchestrator.py[m[36m:[m1552[36m:[m80[36m:[m [1m[31mE501[m line too long (151 > 79 characters)
            f"  D√©cision: {'‚úÖ APPROUV√â' if final_state == AgentState.APPROVED else '‚ùå REJET√â' if final_state == AgentState.REJECTED else '‚ö†Ô∏è AVORT√â'}",
                                                                               ^
[1m.\agents\orchestrator.py[m[36m:[m1577[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
                f"  üìä Sharpe Ratio: {self.context.best_metrics.sharpe_ratio:.3f}",
                                                                               ^
[1m.\agents\orchestrator.py[m[36m:[m1578[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
                f"  üí∞ Total Return: {self.context.best_metrics.total_return:.2%}",
                                                                               ^
[1m.\agents\orchestrator.py[m[36m:[m1579[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
                f"  üìâ Max Drawdown: {self.context.best_metrics.max_drawdown:.2%}",
                                                                               ^
[1m.\agents\orchestrator.py[m[36m:[m1580[36m:[m80[36m:[m [1m[31mE501[m line too long (132 > 79 characters)
                f"  üéØ Win Rate: {self.context.best_metrics.win_rate:.1%}" if hasattr(self.context.best_metrics, 'win_rate') else "",
                                                                               ^
[1m.\agents\orchestrator.py[m[36m:[m1625[36m:[m80[36m:[m [1m[31mE501[m line too long (94 > 79 characters)
            for i, hist in enumerate(self.context.iteration_history[-10:], 1):  # Derni√®res 10
                                                                               ^
[1m.\agents\orchestrator.py[m[36m:[m1637[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
                if params and len(params) <= 5:  # Afficher params si peu nombreux
                                                                               ^
[1m.\agents\orchestrator.py[m[36m:[m1638[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
                    param_str = ", ".join(f"{k}={v}" for k, v in params.items())
                                                                               ^
[1m.\agents\orchestrator.py[m[36m:[m1651[36m:[m80[36m:[m [1m[31mE501[m line too long (112 > 79 characters)
                f"  Combinaisons test√©es via sweeps: {self._total_combinations_tested - self._backtests_count}",
                                                                               ^
[1m.\agents\orchestrator.py[m[36m:[m1673[36m:[m80[36m:[m [1m[31mE501[m line too long (93 > 79 characters)
                f"  üîÑ Duplications √©vit√©es: {self.param_tracker.get_duplicates_prevented()}",
                                                                               ^
[1m.\agents\orchestrator.py[m[36m:[m1683[36m:[m80[36m:[m [1m[31mE501[m line too long (143 > 79 characters)
                    f"    Return: {best_sharpe.total_return:.2%}" if hasattr(best_sharpe, 'total_return') and best_sharpe.total_return else "",
                                                                               ^
[1m.\agents\orchestrator.py[m[36m:[m1744[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
        total_calls = sum(_get_agent_stats(a)["execution_count"] for a in agents)
                                                                               ^
[1m.\agents\orchestrator.py[m[36m:[m1755[36m:[m80[36m:[m [1m[31mE501[m line too long (90 > 79 characters)
                    f"‚úÖ {duplicates} duplications de param√®tres √©vit√©es durant la session"
                                                                               ^
[1m.\agents\orchestrator.py[m[36m:[m1759[36m:[m80[36m:[m [1m[31mE501[m line too long (93 > 79 characters)
                    f"üìä {self.param_tracker.get_tested_count()} combinaisons uniques test√©es"
                                                                               ^
[1m.\agents\orchestrator.py[m[36m:[m1766[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
            final_params=self.context.best_params or self.context.current_params,
                                                                               ^
[1m.\agents\state_machine.py[m[36m:[m4[36m:[m80[36m:[m [1m[31mE501[m line too long (94 > 79 characters)
"""
Module-ID: agents.state_machine

Purpose: Machine √† √©tats rigide pour le workflow LLM avec transitions valid√©es et tra√ßabilit√©.

Role in pipeline: orchestration

Key components: AgentState (enum), StateMachine, StateTransition, ValidationResult

Inputs: √âtat courant, action demand√©e, validateurs optionnels

Outputs: Nouvel √©tat, historique transitions, dur√©es, erreurs

Dependencies: utils.log, dataclasses

Conventions: √âtats INIT‚ÜíANALYZE‚ÜíPROPOSE‚ÜíCRITIQUE‚ÜíVALIDATE‚Üí[APPROVED|REJECTED|ITERATE]; ITERATE reboucle √† ANALYZE; *‚ÜíFAILED sur erreur; iteration incr√©ment√© sur transition ITERATE.

Read-if: Modification transitions, ajout √©tats, ou int√©gration validateurs custom.

Skip-if: Vous ne touchez qu'aux agents isol√©s.
"""
   
                               

                                          ^
[1m.\agents\state_machine.py[m[36m:[m8[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
"""
Module-ID: agents.state_machine

Purpose: Machine √† √©tats rigide pour le workflow LLM avec transitions valid√©es et tra√ßabilit√©.

Role in pipeline: orchestration

Key components: AgentState (enum), StateMachine, StateTransition, ValidationResult

Inputs: √âtat courant, action demand√©e, validateurs optionnels

Outputs: Nouvel √©tat, historique transitions, dur√©es, erreurs

Dependencies: utils.log, dataclasses

Conventions: √âtats INIT‚ÜíANALYZE‚ÜíPROPOSE‚ÜíCRITIQUE‚ÜíVALIDATE‚Üí[APPROVED|REJECTED|ITERATE]; ITERATE reboucle √† ANALYZE; *‚ÜíFAILED sur erreur; iteration incr√©ment√© sur transition ITERATE.

Read-if: Modification transitions, ajout √©tats, ou int√©gration validateurs custom.

Skip-if: Vous ne touchez qu'aux agents isol√©s.
"""
   
                               

                                          ^
[1m.\agents\state_machine.py[m[36m:[m16[36m:[m80[36m:[m [1m[31mE501[m line too long (180 > 79 characters)
"""
Module-ID: agents.state_machine

Purpose: Machine √† √©tats rigide pour le workflow LLM avec transitions valid√©es et tra√ßabilit√©.

Role in pipeline: orchestration

Key components: AgentState (enum), StateMachine, StateTransition, ValidationResult

Inputs: √âtat courant, action demand√©e, validateurs optionnels

Outputs: Nouvel √©tat, historique transitions, dur√©es, erreurs

Dependencies: utils.log, dataclasses

Conventions: √âtats INIT‚ÜíANALYZE‚ÜíPROPOSE‚ÜíCRITIQUE‚ÜíVALIDATE‚Üí[APPROVED|REJECTED|ITERATE]; ITERATE reboucle √† ANALYZE; *‚ÜíFAILED sur erreur; iteration incr√©ment√© sur transition ITERATE.

Read-if: Modification transitions, ajout √©tats, ou int√©gration validateurs custom.

Skip-if: Vous ne touchez qu'aux agents isol√©s.
"""
   
                               

                                          ^
[1m.\agents\state_machine.py[m[36m:[m18[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
"""
Module-ID: agents.state_machine

Purpose: Machine √† √©tats rigide pour le workflow LLM avec transitions valid√©es et tra√ßabilit√©.

Role in pipeline: orchestration

Key components: AgentState (enum), StateMachine, StateTransition, ValidationResult

Inputs: √âtat courant, action demand√©e, validateurs optionnels

Outputs: Nouvel √©tat, historique transitions, dur√©es, erreurs

Dependencies: utils.log, dataclasses

Conventions: √âtats INIT‚ÜíANALYZE‚ÜíPROPOSE‚ÜíCRITIQUE‚ÜíVALIDATE‚Üí[APPROVED|REJECTED|ITERATE]; ITERATE reboucle √† ANALYZE; *‚ÜíFAILED sur erreur; iteration incr√©ment√© sur transition ITERATE.

Read-if: Modification transitions, ajout √©tats, ou int√©gration validateurs custom.

Skip-if: Vous ne touchez qu'aux agents isol√©s.
"""
   
                               

                                          ^
[1m.\agents\state_machine.py[m[36m:[m53[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
        return self in (AgentState.APPROVED, AgentState.REJECTED, AgentState.FAILED)
                                                                               ^
[1m.\agents\state_machine.py[m[36m:[m76[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
    def failure(cls, message: str, errors: List[str] = None) -> ValidationResult:
                                                                               ^
[1m.\agents\state_machine.py[m[36m:[m133[36m:[m80[36m:[m [1m[31mE501[m line too long (89 > 79 characters)
        AgentState.ANALYZE: {AgentState.PROPOSE, AgentState.VALIDATE, AgentState.FAILED},
                                                                               ^
[1m.\agents\state_machine.py[m[36m:[m136[36m:[m80[36m:[m [1m[31mE501[m line too long (111 > 79 characters)
        AgentState.VALIDATE: {AgentState.APPROVED, AgentState.REJECTED, AgentState.ITERATE, AgentState.FAILED},
                                                                               ^
[1m.\agents\state_machine.py[m[36m:[m137[36m:[m80[36m:[m [1m[31mE501[m line too long (89 > 79 characters)
        AgentState.ITERATE: {AgentState.ANALYZE, AgentState.REJECTED, AgentState.FAILED},
                                                                               ^
[1m.\agents\state_machine.py[m[36m:[m166[36m:[m80[36m:[m [1m[31mE501[m line too long (95 > 79 characters)
        self._record_transition(None, initial_state, ValidationResult.success("Initial state"))
                                                                               ^
[1m.\agents\state_machine.py[m[36m:[m168[36m:[m80[36m:[m [1m[31mE501[m line too long (86 > 79 characters)
        max_iter_label = "‚àû" if not self._has_iteration_limit else str(max_iterations)
                                                                               ^
[1m.\agents\state_machine.py[m[36m:[m169[36m:[m80[36m:[m [1m[31mE501[m line too long (102 > 79 characters)
        logger.info(f"StateMachine initialis√©e: √©tat={initial_state.name}, max_iter={max_iter_label}")
                                                                               ^
[1m.\agents\state_machine.py[m[36m:[m223[36m:[m80[36m:[m [1m[31mE501[m line too long (92 > 79 characters)
        if self._current_state == AgentState.ITERATE and target_state == AgentState.ANALYZE:
                                                                               ^
[1m.\agents\state_machine.py[m[36m:[m224[36m:[m80[36m:[m [1m[31mE501[m line too long (93 > 79 characters)
            if self._has_iteration_limit and self._current_iteration >= self._max_iterations:
                                                                               ^
[1m.\agents\state_machine.py[m[36m:[m267[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
                f"Impossible de quitter l'√©tat terminal {self._current_state.name}"
                                                                               ^
[1m.\agents\state_machine.py[m[36m:[m274[36m:[m80[36m:[m [1m[31mE501[m line too long (89 > 79 characters)
                f"Transition {self._current_state.name} ‚Üí {target_state.name} invalide. "
                                                                               ^
[1m.\agents\state_machine.py[m[36m:[m281[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
            validation = self._transition_validators[validator_key](self._context)
                                                                               ^
[1m.\agents\state_machine.py[m[36m:[m284[36m:[m80[36m:[m [1m[31mE501[m line too long (93 > 79 characters)
                    f"Validation √©chou√©e: {self._current_state.name} ‚Üí {target_state.name}: "
                                                                               ^
[1m.\agents\state_machine.py[m[36m:[m296[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
        if target_state == AgentState.ANALYZE and old_state == AgentState.ITERATE:
                                                                               ^
[1m.\agents\state_machine.py[m[36m:[m323[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
        self._record_transition(self._current_state, AgentState.FAILED, validation)
                                                                               ^
[1m.\agents\state_machine.py[m[36m:[m338[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
            duration = (now - self._last_transition_time).total_seconds() * 1000
                                                                               ^
[1m.\agents\state_machine.py[m[36m:[m387[36m:[m80[36m:[m [1m[31mE501[m line too long (89 > 79 characters)
        self._record_transition(None, AgentState.INIT, ValidationResult.success("Reset"))
                                                                               ^
[1m.\agents\state_machine.py[m[36m:[m394[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
    def __init__(self, message: str, from_state: AgentState, to_state: AgentState):
                                                                               ^
[1m.\agents\strategist.py[m[36m:[m4[36m:[m80[36m:[m [1m[31mE501[m line too long (93 > 79 characters)
"""
Module-ID: agents.strategist

Purpose: Proposer des ajustements cr√©atifs mais r√©alistes des param√®tres bas√©s sur l'analyse.

Role in pipeline: orchestration

Key components: StrategistAgent, ParameterProposal, ProposalList

Inputs: AgentContext (analyst_result, param_bounds, param_specs)

Outputs: Liste de ParameterProposal (params valid√©s, justifications, priorit√©s)

Dependencies: agents.base_agent, utils.template, utils.parameters

Conventions: Propositions clamp√©es aux bornes; bornes min < max obligatoires; justifications exig√©es; template Jinja2.

Read-if: Modification propositions, cr√©ativit√©/conservatisme, ou cl√©mence des contraintes.

Skip-if: Vous ne touchez qu'√† analyze/critique/validate.
"""
   
                            

                                             ^
[1m.\agents\strategist.py[m[36m:[m16[36m:[m80[36m:[m [1m[31mE501[m line too long (118 > 79 characters)
"""
Module-ID: agents.strategist

Purpose: Proposer des ajustements cr√©atifs mais r√©alistes des param√®tres bas√©s sur l'analyse.

Role in pipeline: orchestration

Key components: StrategistAgent, ParameterProposal, ProposalList

Inputs: AgentContext (analyst_result, param_bounds, param_specs)

Outputs: Liste de ParameterProposal (params valid√©s, justifications, priorit√©s)

Dependencies: agents.base_agent, utils.template, utils.parameters

Conventions: Propositions clamp√©es aux bornes; bornes min < max obligatoires; justifications exig√©es; template Jinja2.

Read-if: Modification propositions, cr√©ativit√©/conservatisme, ou cl√©mence des contraintes.

Skip-if: Vous ne touchez qu'√† analyze/critique/validate.
"""
   
                            

                                             ^
[1m.\agents\strategist.py[m[36m:[m18[36m:[m80[36m:[m [1m[31mE501[m line too long (90 > 79 characters)
"""
Module-ID: agents.strategist

Purpose: Proposer des ajustements cr√©atifs mais r√©alistes des param√®tres bas√©s sur l'analyse.

Role in pipeline: orchestration

Key components: StrategistAgent, ParameterProposal, ProposalList

Inputs: AgentContext (analyst_result, param_bounds, param_specs)

Outputs: Liste de ParameterProposal (params valid√©s, justifications, priorit√©s)

Dependencies: agents.base_agent, utils.template, utils.parameters

Conventions: Propositions clamp√©es aux bornes; bornes min < max obligatoires; justifications exig√©es; template Jinja2.

Read-if: Modification propositions, cr√©ativit√©/conservatisme, ou cl√©mence des contraintes.

Skip-if: Vous ne touchez qu'√† analyze/critique/validate.
"""
   
                            

                                             ^
[1m.\agents\strategist.py[m[36m:[m59[36m:[m80[36m:[m [1m[31mE501[m line too long (117 > 79 characters)
        return """You are a senior quantitative strategist specializing in algorithmic trading strategy optimization.

Your expertise includes:
- Parameter optimization for trading strategies
- Understanding indicator behavior across different settings
- Balancing risk/reward trade-offs
- Creative but grounded strategy improvements
- Avoiding overfitting while maximizing performance

When proposing parameter changes:
1. Consider the analyst's findings and recommendations
2. Propose changes that address identified weaknesses
3. Stay within reasonable parameter bounds
4. Prioritize robustness over maximum performance
5. Consider how parameters interact with each other
6. Avoid drastic changes that might cause instability

IMPORTANT CONSTRAINTS:
- Each parameter must stay within its min/max bounds
- Propose 3-5 parameter sets, ordered by priority
- First proposal should be conservative, later ones more aggressive
- Always explain the rationale for each change

Respond ONLY in valid JSON format with this exact structure:
{
    "analysis_summary": "Brief summary of analyst findings you're addressing",
    "optimization_strategy": "Overall approach to optimization",
    "proposals": [
        {
            "id": 1,
            "name": "Conservative Adjustment",
            "priority": "HIGH|MEDIUM|LOW",
            "risk_level": "LOW|MEDIUM|HIGH",
            "parameters": {
                "param_name": value,
                ...
            },
            "changes_from_current": {
                "param_name": {"from": old_value, "to": new_value, "change_percent": X}
            },
            "rationale": "Why this configuration might improve performance",
            "expected_impact": {
                "sharpe_ratio": "+X% to +Y%",
                "drawdown": "similar|reduced|increased",
                "trade_frequency": "similar|higher|lower"
            },
            "risks": ["risk1", "risk2"]
        }
    ],
    "constraints_respected": true,
    "fallback_recommendation": "What to do if all proposals fail"
}"""
                                                                               ^
[1m.\agents\strategist.py[m[36m:[m97[36m:[m80[36m:[m [1m[31mE501[m line too long (87 > 79 characters)
        return """You are a senior quantitative strategist specializing in algorithmic trading strategy optimization.

Your expertise includes:
- Parameter optimization for trading strategies
- Understanding indicator behavior across different settings
- Balancing risk/reward trade-offs
- Creative but grounded strategy improvements
- Avoiding overfitting while maximizing performance

When proposing parameter changes:
1. Consider the analyst's findings and recommendations
2. Propose changes that address identified weaknesses
3. Stay within reasonable parameter bounds
4. Prioritize robustness over maximum performance
5. Consider how parameters interact with each other
6. Avoid drastic changes that might cause instability

IMPORTANT CONSTRAINTS:
- Each parameter must stay within its min/max bounds
- Propose 3-5 parameter sets, ordered by priority
- First proposal should be conservative, later ones more aggressive
- Always explain the rationale for each change

Respond ONLY in valid JSON format with this exact structure:
{
    "analysis_summary": "Brief summary of analyst findings you're addressing",
    "optimization_strategy": "Overall approach to optimization",
    "proposals": [
        {
            "id": 1,
            "name": "Conservative Adjustment",
            "priority": "HIGH|MEDIUM|LOW",
            "risk_level": "LOW|MEDIUM|HIGH",
            "parameters": {
                "param_name": value,
                ...
            },
            "changes_from_current": {
                "param_name": {"from": old_value, "to": new_value, "change_percent": X}
            },
            "rationale": "Why this configuration might improve performance",
            "expected_impact": {
                "sharpe_ratio": "+X% to +Y%",
                "drawdown": "similar|reduced|increased",
                "trade_frequency": "similar|higher|lower"
            },
            "risks": ["risk1", "risk2"]
        }
    ],
    "constraints_respected": true,
    "fallback_recommendation": "What to do if all proposals fail"
}"""
                                                                               ^
[1m.\agents\strategist.py[m[36m:[m153[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
        validated_proposals = self._validate_and_fix_proposals(proposals, context)
                                                                               ^
[1m.\agents\strategist.py[m[36m:[m170[36m:[m80[36m:[m [1m[31mE501[m line too long (89 > 79 characters)
                "optimization_strategy": proposals_data.get("optimization_strategy", ""),
                                                                               ^
[1m.\agents\strategist.py[m[36m:[m171[36m:[m80[36m:[m [1m[31mE501[m line too long (93 > 79 characters)
                "fallback_recommendation": proposals_data.get("fallback_recommendation", ""),
                                                                               ^
[1m.\agents\strategist.py[m[36m:[m210[36m:[m80[36m:[m [1m[31mE501[m line too long (87 > 79 characters)
            "session_params_summary": getattr(context, 'session_params_summary', None),
                                                                               ^
[1m.\agents\strategist.py[m[36m:[m250[36m:[m80[36m:[m [1m[31mE501[m line too long (89 > 79 characters)
                        f"Param√®tre {param_name}={value} < min={spec.min_value}, corrig√©"
                                                                               ^
[1m.\agents\strategist.py[m[36m:[m256[36m:[m80[36m:[m [1m[31mE501[m line too long (89 > 79 characters)
                        f"Param√®tre {param_name}={value} > max={spec.max_value}, corrig√©"
                                                                               ^
[1m.\agents\strategist.py[m[36m:[m262[36m:[m80[36m:[m [1m[31mE501[m line too long (88 > 79 characters)
                    if isinstance(value, float) and isinstance(spec.step, (int, float)):
                                                                               ^
[1m.\agents\validator.py[m[36m:[m4[36m:[m80[36m:[m [1m[31mE501[m line too long (92 > 79 characters)
"""
Module-ID: agents.validator

Purpose: Prendre la d√©cision finale (APPROVE/REJECT/ITERATE/ABORT) avec synth√®se des agents.

Role in pipeline: orchestration

Key components: ValidatorAgent, ValidationDecision, ValidatorResponse

Inputs: AgentContext complet (analyst_result, propositions, critic_evaluation)

Outputs: ValidationDecision (APPROVE/REJECT/ITERATE/ABORT) avec justifications

Dependencies: agents.base_agent, agents.state_machine, utils.template

Conventions: Decision irr√©vocable une fois APPROVED/REJECTED; ITERATE remet √† ANALYZE; ABORT ‚Üí FAILED; template Jinja2.

Read-if: Modification crit√®res d√©cision, seuils approbation, ou logique d'it√©ration.

Skip-if: Vous ne changez que analyze/propose/critique.
"""
   
                           

                                              ^
[1m.\agents\validator.py[m[36m:[m16[36m:[m80[36m:[m [1m[31mE501[m line too long (119 > 79 characters)
"""
Module-ID: agents.validator

Purpose: Prendre la d√©cision finale (APPROVE/REJECT/ITERATE/ABORT) avec synth√®se des agents.

Role in pipeline: orchestration

Key components: ValidatorAgent, ValidationDecision, ValidatorResponse

Inputs: AgentContext complet (analyst_result, propositions, critic_evaluation)

Outputs: ValidationDecision (APPROVE/REJECT/ITERATE/ABORT) avec justifications

Dependencies: agents.base_agent, agents.state_machine, utils.template

Conventions: Decision irr√©vocable une fois APPROVED/REJECTED; ITERATE remet √† ANALYZE; ABORT ‚Üí FAILED; template Jinja2.

Read-if: Modification crit√®res d√©cision, seuils approbation, ou logique d'it√©ration.

Skip-if: Vous ne changez que analyze/propose/critique.
"""
   
                           

                                              ^
[1m.\agents\validator.py[m[36m:[m18[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
"""
Module-ID: agents.validator

Purpose: Prendre la d√©cision finale (APPROVE/REJECT/ITERATE/ABORT) avec synth√®se des agents.

Role in pipeline: orchestration

Key components: ValidatorAgent, ValidationDecision, ValidatorResponse

Inputs: AgentContext complet (analyst_result, propositions, critic_evaluation)

Outputs: ValidationDecision (APPROVE/REJECT/ITERATE/ABORT) avec justifications

Dependencies: agents.base_agent, agents.state_machine, utils.template

Conventions: Decision irr√©vocable une fois APPROVED/REJECTED; ITERATE remet √† ANALYZE; ABORT ‚Üí FAILED; template Jinja2.

Read-if: Modification crit√®res d√©cision, seuils approbation, ou logique d'it√©ration.

Skip-if: Vous ne changez que analyze/propose/critique.
"""
   
                           

                                              ^
[1m.\agents\validator.py[m[36m:[m68[36m:[m80[36m:[m [1m[31mE501[m line too long (85 > 79 characters)
        return """You are the final decision-maker for trading strategy optimization.

Your role is to synthesize all agent reports and make the final call.

Decision criteria:
1. APPROVE: Configuration meets ALL requirements and is production-ready
   - Sharpe ratio >= minimum threshold
   - Drawdown <= maximum allowed
   - Overfitting ratio <= threshold
   - Sufficient trades for statistical validity
   - Approved by Critic with reasonable confidence

2. ITERATE: Promising but needs more optimization
   - Shows potential but doesn't meet all criteria
   - Clear path to improvement exists
   - Not at max iterations yet
   - Risk of overfitting is manageable

3. REJECT: Should stop optimization entirely
   - Fundamental strategy issues identified
   - Max iterations reached without meeting criteria
   - High overfitting that can't be fixed
   - Market regime mismatch

4. ABORT: Critical error requiring human intervention
   - System malfunction
   - Data quality issues
   - Inconsistent results

Your decision MUST be based on objective criteria, not feelings.
Be conservative - when in doubt, ITERATE rather than APPROVE.

Respond ONLY in valid JSON format with this exact structure:
{
    "decision": "APPROVE|REJECT|ITERATE|ABORT",
    "confidence": 0-100,
    "summary": "Brief summary of the decision rationale",

    "criteria_check": {
        "sharpe_meets_minimum": true/false,
        "drawdown_within_limit": true/false,
        "overfitting_acceptable": true/false,
        "sufficient_trades": true/false,
        "critic_approved": true/false
    },

    "agent_synthesis": {
        "analyst_key_points": ["point1", "point2"],
        "strategist_contribution": "summary",
        "critic_concerns_addressed": true/false
    },

    "if_approved": {
        "final_parameters": {"param": value},
        "expected_performance": {"metric": value},
        "deployment_notes": ["note1", "note2"],
        "monitoring_recommendations": ["rec1", "rec2"]
    },

    "if_iterate": {
        "focus_areas": ["area1", "area2"],
        "suggested_approach": "what to try next",
        "max_more_iterations": 3
    },

    "if_rejected": {
        "primary_reasons": ["reason1", "reason2"],
        "fundamental_issues": ["issue1"],
        "recommendations": ["what to do instead"]
    },

    "final_report": "Comprehensive final report paragraph"
}"""
                                                                               ^
[1m.\agents\validator.py[m[36m:[m193[36m:[m80[36m:[m [1m[31mE501[m line too long (91 > 79 characters)
        decision = self._validate_decision_coherence(decision, objective_check, validation)
                                                                               ^
[1m.\agents\validator.py[m[36m:[m201[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
            "criteria_check": validation.get("criteria_check", objective_check),
                                                                               ^
[1m.\agents\validator.py[m[36m:[m210[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
            result_data["rejection_details"] = validation.get("if_rejected", {})
                                                                               ^
[1m.\agents\validator.py[m[36m:[m222[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
    def _check_objective_criteria(self, context: AgentContext) -> Dict[str, bool]:
                                                                               ^
[1m.\agents\validator.py[m[36m:[m234[36m:[m80[36m:[m [1m[31mE501[m line too long (87 > 79 characters)
            checks["sharpe_meets_minimum"] = metrics.sharpe_ratio >= context.min_sharpe
                                                                               ^
[1m.\agents\validator.py[m[36m:[m235[36m:[m80[36m:[m [1m[31mE501[m line too long (101 > 79 characters)
            checks["drawdown_within_limit"] = abs(metrics.max_drawdown) <= context.max_drawdown_limit
                                                                               ^
[1m.\agents\validator.py[m[36m:[m236[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
            checks["sufficient_trades"] = metrics.total_trades >= context.min_trades
                                                                               ^
[1m.\agents\validator.py[m[36m:[m240[36m:[m80[36m:[m [1m[31mE501[m line too long (105 > 79 characters)
            checks["overfitting_acceptable"] = context.overfitting_ratio <= context.max_overfitting_ratio
                                                                               ^
[1m.\analyze_all_results.py[m[36m:[m22[36m:[m80[36m:[m [1m[31mE501[m line too long (87 > 79 characters)
    df_ema = pd.read_parquet(results_dir / 'sweep_20251230_231247/all_results.parquet')
                                                                               ^
[1m.\analyze_all_results.py[m[36m:[m31[36m:[m80[36m:[m [1m[31mE501[m line too long (109 > 79 characters)
        print(f'   Param√®tres: fast_period={int(row["fast_period"])}, slow_period={int(row["slow_period"])}')
                                                                               ^
[1m.\analyze_all_results.py[m[36m:[m32[36m:[m80[36m:[m [1m[31mE501[m line too long (90 > 79 characters)
        print(f'   PnL: ${row["total_pnl"]:.2f} | Return: {row["total_return_pct"]:.2f}%')
                                                                               ^
[1m.\analyze_all_results.py[m[36m:[m33[36m:[m80[36m:[m [1m[31mE501[m line too long (90 > 79 characters)
        print(f'   Sharpe: {row["sharpe_ratio"]:.2f} | Calmar: {row["calmar_ratio"]:.2f}')
                                                                               ^
[1m.\analyze_all_results.py[m[36m:[m34[36m:[m80[36m:[m [1m[31mE501[m line too long (97 > 79 characters)
        print(f'   Win Rate: {row["win_rate"]:.1f}% | Profit Factor: {row["profit_factor"]:.2f}')
                                                                               ^
[1m.\analyze_all_results.py[m[36m:[m35[36m:[m80[36m:[m [1m[31mE501[m line too long (92 > 79 characters)
        print(f'   Max DD: {row["max_drawdown"]:.2f}% | Trades: {int(row["total_trades"])}')
                                                                               ^
[1m.\analyze_all_results.py[m[36m:[m36[36m:[m80[36m:[m [1m[31mE501[m line too long (86 > 79 characters)
        print(f'   Avg Win: ${row["avg_win"]:.2f} | Avg Loss: ${row["avg_loss"]:.2f}')
                                                                               ^
[1m.\analyze_all_results.py[m[36m:[m37[36m:[m80[36m:[m [1m[31mE501[m line too long (102 > 79 characters)
        print(f'   Largest Win: ${row["largest_win"]:.2f} | Largest Loss: ${row["largest_loss"]:.2f}')
                                                                               ^
[1m.\analyze_all_results.py[m[36m:[m70[36m:[m80[36m:[m [1m[31mE501[m line too long (89 > 79 characters)
        print(f'      PnL: ${m["total_pnl"]:.2f} | Return: {m["total_return_pct"]:.2f}%')
                                                                               ^
[1m.\analyze_all_results.py[m[36m:[m71[36m:[m80[36m:[m [1m[31mE501[m line too long (100 > 79 characters)
        print(f'      CAGR: {m.get("annualized_return", 0):.2f}% | Sharpe: {m["sharpe_ratio"]:.2f}')
                                                                               ^
[1m.\analyze_all_results.py[m[36m:[m72[36m:[m80[36m:[m [1m[31mE501[m line too long (100 > 79 characters)
        print(f'      Win Rate: {m["win_rate_pct"]:.2f}% | Profit Factor: {m["profit_factor"]:.2f}')
                                                                               ^
[1m.\analyze_all_results.py[m[36m:[m73[36m:[m80[36m:[m [1m[31mE501[m line too long (90 > 79 characters)
        print(f'      Max DD: {m["max_drawdown_pct"]:.2f}% | Trades: {m["total_trades"]}')
                                                                               ^
[1m.\analyze_all_results.py[m[36m:[m74[36m:[m80[36m:[m [1m[31mE501[m line too long (85 > 79 characters)
        print(f'      Avg Win: ${m["avg_win"]:.2f} | Avg Loss: ${m["avg_loss"]:.2f}')
                                                                               ^
[1m.\analyze_all_results.py[m[36m:[m75[36m:[m80[36m:[m [1m[31mE501[m line too long (101 > 79 characters)
        print(f'      Largest Win: ${m["largest_win"]:.2f} | Largest Loss: ${m["largest_loss"]:.2f}')
                                                                               ^
[1m.\analyze_all_results.py[m[36m:[m76[36m:[m80[36m:[m [1m[31mE501[m line too long (102 > 79 characters)
        print(f'      Expectancy: ${m["expectancy"]:.2f} | Risk/Reward: {m["risk_reward_ratio"]:.2f}')
                                                                               ^
[1m.\analyze_all_results.py[m[36m:[m84[36m:[m80[36m:[m [1m[31mE501[m line too long (117 > 79 characters)
    print(f'  - EMA Cross: 10,000 combinaisons ‚Üí {len(profitable_ema)} profitables ({len(profitable_ema)/100:.1f}%)')
                                                                               ^
[1m.\analyze_all_results.py[m[36m:[m85[36m:[m80[36m:[m [1m[31mE501[m line too long (142 > 79 characters)
    print(f'  - BollingerATR & variants: {len(index)} runs ‚Üí {len(profitable_runs)} profitables ({len(profitable_runs)/len(index)*100:.1f}%)')
                                                                               ^
[1m.\analyze_all_results.py[m[36m:[m90[36m:[m80[36m:[m [1m[31mE501[m line too long (105 > 79 characters)
        print(f'   Strat√©gie: EMA Cross ({int(best_ema["fast_period"])}/{int(best_ema["slow_period"])})')
                                                                               ^
[1m.\analyze_all_results.py[m[36m:[m91[36m:[m80[36m:[m [1m[31mE501[m line too long (146 > 79 characters)
        print(f'   Return: {best_ema["total_return_pct"]:.2f}% | Sharpe: {best_ema["sharpe_ratio"]:.2f} | Calmar: {best_ema["calmar_ratio"]:.2f}')
                                                                               ^
[1m.\analyze_all_results.py[m[36m:[m95[36m:[m1[36m:[m [1m[31mE303[m too many blank lines (3)
if __name__ == '__main__':
^
[1m.\backtest\__init__.py[m[36m:[m4[36m:[m80[36m:[m [1m[31mE501[m line too long (109 > 79 characters)
"""
Module-ID: backtest

Purpose: Moteur de backtesting (pipeline complet + optimisation + validation) avec API stable pour UI/agents.

Role in pipeline: core / orchestration

Key components: BacktestEngine, RunResult, OptunaOptimizer, SweepEngine, WalkForwardValidator, BackendFacade

Inputs: Donn√©es OHLCV, strat√©gies, param√®tres, configurations

Outputs: R√©sultats de backtest structur√©s (trades, m√©triques, rapports)

Dependencies: Tous les modules backtest/*, strategies, indicators, data, utils, optionnel: optuna, tabulate

Conventions: Pipeline donn√©es‚Üíindicateurs‚Üísignaux‚Üítrades‚Üím√©triques; erreurs structur√©es; r√©ponses typ√©es.

Read-if: Vous importez le moteur depuis UI/agents ou modifiez l'architecture.

Skip-if: Vous travaillez sur une seule strat/indicateur.
"""
   
                   

                                                      ^
[1m.\backtest\__init__.py[m[36m:[m8[36m:[m80[36m:[m [1m[31mE501[m line too long (108 > 79 characters)
"""
Module-ID: backtest

Purpose: Moteur de backtesting (pipeline complet + optimisation + validation) avec API stable pour UI/agents.

Role in pipeline: core / orchestration

Key components: BacktestEngine, RunResult, OptunaOptimizer, SweepEngine, WalkForwardValidator, BackendFacade

Inputs: Donn√©es OHLCV, strat√©gies, param√®tres, configurations

Outputs: R√©sultats de backtest structur√©s (trades, m√©triques, rapports)

Dependencies: Tous les modules backtest/*, strategies, indicators, data, utils, optionnel: optuna, tabulate

Conventions: Pipeline donn√©es‚Üíindicateurs‚Üísignaux‚Üítrades‚Üím√©triques; erreurs structur√©es; r√©ponses typ√©es.

Read-if: Vous importez le moteur depuis UI/agents ou modifiez l'architecture.

Skip-if: Vous travaillez sur une seule strat/indicateur.
"""
   
                   

                                                      ^
[1m.\backtest\__init__.py[m[36m:[m14[36m:[m80[36m:[m [1m[31mE501[m line too long (107 > 79 characters)
"""
Module-ID: backtest

Purpose: Moteur de backtesting (pipeline complet + optimisation + validation) avec API stable pour UI/agents.

Role in pipeline: core / orchestration

Key components: BacktestEngine, RunResult, OptunaOptimizer, SweepEngine, WalkForwardValidator, BackendFacade

Inputs: Donn√©es OHLCV, strat√©gies, param√®tres, configurations

Outputs: R√©sultats de backtest structur√©s (trades, m√©triques, rapports)

Dependencies: Tous les modules backtest/*, strategies, indicators, data, utils, optionnel: optuna, tabulate

Conventions: Pipeline donn√©es‚Üíindicateurs‚Üísignaux‚Üítrades‚Üím√©triques; erreurs structur√©es; r√©ponses typ√©es.

Read-if: Vous importez le moteur depuis UI/agents ou modifiez l'architecture.

Skip-if: Vous travaillez sur une seule strat/indicateur.
"""
   
                   

                                                      ^
[1m.\backtest\__init__.py[m[36m:[m16[36m:[m80[36m:[m [1m[31mE501[m line too long (105 > 79 characters)
"""
Module-ID: backtest

Purpose: Moteur de backtesting (pipeline complet + optimisation + validation) avec API stable pour UI/agents.

Role in pipeline: core / orchestration

Key components: BacktestEngine, RunResult, OptunaOptimizer, SweepEngine, WalkForwardValidator, BackendFacade

Inputs: Donn√©es OHLCV, strat√©gies, param√®tres, configurations

Outputs: R√©sultats de backtest structur√©s (trades, m√©triques, rapports)

Dependencies: Tous les modules backtest/*, strategies, indicators, data, utils, optionnel: optuna, tabulate

Conventions: Pipeline donn√©es‚Üíindicateurs‚Üísignaux‚Üítrades‚Üím√©triques; erreurs structur√©es; r√©ponses typ√©es.

Read-if: Vous importez le moteur depuis UI/agents ou modifiez l'architecture.

Skip-if: Vous travaillez sur une seule strat/indicateur.
"""
   
                   

                                                      ^
[1m.\backtest\engine.py[m[36m:[m4[36m:[m80[36m:[m [1m[31mE501[m line too long (110 > 79 characters)
"""
Module-ID: backtest.engine

Purpose: Orchestrer le pipeline complet de backtesting (donn√©es ‚Üí indicateurs ‚Üí signaux ‚Üí trades ‚Üí m√©triques).

Role in pipeline: orchestration / core

Key components: BacktestEngine, RunResult, run_backtest

Inputs: DataFrame OHLCV, StrategyBase, Config optionnel

Outputs: RunResult (trades, metrics, equity curve, detailed report)

Dependencies: strategies.base, indicators.registry, backtest.simulator, backtest.performance, data.indicator_bank, utils.config

Conventions: Indicateurs calcul√©s une fois; signaux normalis√©s (1/-1/0); prix en devise de base.

Read-if: Vous modifiez le pipeline principal ou l'API de BacktestEngine.

Skip-if: Vous ne faites que des strat√©gies/indicateurs.
"""
   
                          

                                               ^
[1m.\backtest\engine.py[m[36m:[m14[36m:[m80[36m:[m [1m[31mE501[m line too long (127 > 79 characters)
"""
Module-ID: backtest.engine

Purpose: Orchestrer le pipeline complet de backtesting (donn√©es ‚Üí indicateurs ‚Üí signaux ‚Üí trades ‚Üí m√©triques).

Role in pipeline: orchestration / core

Key components: BacktestEngine, RunResult, run_backtest

Inputs: DataFrame OHLCV, StrategyBase, Config optionnel

Outputs: RunResult (trades, metrics, equity curve, detailed report)

Dependencies: strategies.base, indicators.registry, backtest.simulator, backtest.performance, data.indicator_bank, utils.config

Conventions: Indicateurs calcul√©s une fois; signaux normalis√©s (1/-1/0); prix en devise de base.

Read-if: Vous modifiez le pipeline principal ou l'API de BacktestEngine.

Skip-if: Vous ne faites que des strat√©gies/indicateurs.
"""
   
                          

                                               ^
[1m.\backtest\engine.py[m[36m:[m16[36m:[m80[36m:[m [1m[31mE501[m line too long (96 > 79 characters)
"""
Module-ID: backtest.engine

Purpose: Orchestrer le pipeline complet de backtesting (donn√©es ‚Üí indicateurs ‚Üí signaux ‚Üí trades ‚Üí m√©triques).

Role in pipeline: orchestration / core

Key components: BacktestEngine, RunResult, run_backtest

Inputs: DataFrame OHLCV, StrategyBase, Config optionnel

Outputs: RunResult (trades, metrics, equity curve, detailed report)

Dependencies: strategies.base, indicators.registry, backtest.simulator, backtest.performance, data.indicator_bank, utils.config

Conventions: Indicateurs calcul√©s une fois; signaux normalis√©s (1/-1/0); prix en devise de base.

Read-if: Vous modifiez le pipeline principal ou l'API de BacktestEngine.

Skip-if: Vous ne faites que des strat√©gies/indicateurs.
"""
   
                          

                                               ^
[1m.\backtest\engine.py[m[36m:[m191[36m:[m80[36m:[m [1m[31mE501[m line too long (94 > 79 characters)
        """
        Ex√©cute un backtest complet.

        Args:
            df: DataFrame OHLCV avec colonnes (open, high, low, close, volume)
            strategy: Instance de strat√©gie ou nom de strat√©gie
            params: Param√®tres de trading et strat√©gie
            symbol: Symbole de l'actif (pour logging)
            timeframe: Timeframe des donn√©es (pour ajustements)
            seed: Seed pour reproductibilit√©
            silent_mode: Si True, d√©sactive les logs structur√©s (RUN_START, DATA_LOADED, etc.)
                        pour am√©liorer les performances en grid search

        Returns:
            RunResult avec equity, returns, trades, metrics et meta

        Raises:
            ValueError: Si donn√©es ou param√®tres invalides
        """
           
                                    

             
               ^
[1m.\backtest\engine.py[m[36m:[m204[36m:[m80[36m:[m [1m[31mE501[m line too long (104 > 79 characters)
        # Initialiser le counting handler pour compter warnings/errors (seulement si pas en silent_mode)
                                                                               ^
[1m.\backtest\engine.py[m[36m:[m208[36m:[m80[36m:[m [1m[31mE501[m line too long (101 > 79 characters)
            underlying_logger = self.logger.logger if hasattr(self.logger, 'logger') else self.logger
                                                                               ^
[1m.\backtest\engine.py[m[36m:[m212[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
        self.logger = self.logger.with_context(symbol=symbol, timeframe=timeframe)
                                                                               ^
[1m.\backtest\engine.py[m[36m:[m216[36m:[m80[36m:[m [1m[31mE501[m line too long (108 > 79 characters)
                             strategy if isinstance(strategy, str) else getattr(strategy, 'name', 'custom'),
                                                                               ^
[1m.\backtest\engine.py[m[36m:[m220[36m:[m80[36m:[m [1m[31mE501[m line too long (110 > 79 characters)
            strategy_name_log = strategy if isinstance(strategy, str) else getattr(strategy, 'name', 'custom')
                                                                               ^
[1m.\backtest\engine.py[m[36m:[m222[36m:[m80[36m:[m [1m[31mE501[m line too long (94 > 79 characters)
                f"RUN_START run_id={self.run_id} git_commit={get_git_commit()} mode=backtest "
                                                                               ^
[1m.\backtest\engine.py[m[36m:[m223[36m:[m80[36m:[m [1m[31mE501[m line too long (86 > 79 characters)
                f"symbol={symbol} timeframe={timeframe} strategy={strategy_name_log} "
                                                                               ^
[1m.\backtest\engine.py[m[36m:[m224[36m:[m80[36m:[m [1m[31mE501[m line too long (90 > 79 characters)
                f"initial_capital={self.initial_capital} fees_bps={self.config.fees_bps} "
                                                                               ^
[1m.\backtest\engine.py[m[36m:[m225[36m:[m80[36m:[m [1m[31mE501[m line too long (125 > 79 characters)
                f"slippage_bps={self.config.slippage_bps} leverage={params.get('leverage', 1) if params is not None else 1} "
                                                                               ^
[1m.\backtest\engine.py[m[36m:[m226[36m:[m80[36m:[m [1m[31mE501[m line too long (100 > 79 characters)
                f"seed={seed} n_bars={len(df)} period_start={df.index[0]} period_end={df.index[-1]}"
                                                                               ^
[1m.\backtest\engine.py[m[36m:[m237[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
            # DATA_LOADED : Log structur√© des donn√©es (d√©sactiv√© en silent_mode)
                                                                               ^
[1m.\backtest\engine.py[m[36m:[m245[36m:[m80[36m:[m [1m[31mE501[m line too long (87 > 79 characters)
                    f"open_min={df['open'].min():.2f} open_max={df['open'].max():.2f} "
                                                                               ^
[1m.\backtest\engine.py[m[36m:[m246[36m:[m80[36m:[m [1m[31mE501[m line too long (95 > 79 characters)
                    f"volume_min={df['volume'].min():.0f} volume_max={df['volume'].max():.0f} "
                                                                               ^
[1m.\backtest\engine.py[m[36m:[m247[36m:[m80[36m:[m [1m[31mE501[m line too long (98 > 79 characters)
                    f"n_nan_open={df['open'].isna().sum()} n_nan_close={df['close'].isna().sum()}"
                                                                               ^
[1m.\backtest\engine.py[m[36m:[m270[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
                params_str = " ".join([f"{k}={v}" for k, v in final_params.items()])
                                                                               ^
[1m.\backtest\engine.py[m[36m:[m272[36m:[m80[36m:[m [1m[31mE501[m line too long (85 > 79 characters)
                    f"PARAMS_RESOLVED run_id={self.run_id} strategy={strategy_name} "
                                                                               ^
[1m.\backtest\engine.py[m[36m:[m273[36m:[m80[36m:[m [1m[31mE501[m line too long (91 > 79 characters)
                    f"source={'user+defaults' if params else 'defaults_only'} {params_str}"
                                                                               ^
[1m.\backtest\engine.py[m[36m:[m278[36m:[m80[36m:[m [1m[31mE501[m line too long (96 > 79 characters)
            with trace_span(self.logger, "indicators", count=len(strategy.required_indicators)):
                                                                               ^
[1m.\backtest\engine.py[m[36m:[m279[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
                indicators = self._calculate_indicators(df, strategy, final_params)
                                                                               ^
[1m.\backtest\engine.py[m[36m:[m285[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
                signals = strategy.generate_signals(df, indicators, final_params)
                                                                               ^
[1m.\backtest\engine.py[m[36m:[m298[36m:[m80[36m:[m [1m[31mE501[m line too long (109 > 79 characters)
                    trades_df = simulate_trades(df, signals, final_params, execution_engine=execution_engine)
                                                                               ^
[1m.\backtest\engine.py[m[36m:[m305[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
                equity = calculate_equity_fast(df, trades_df, self.initial_capital)
                                                                               ^
[1m.\backtest\engine.py[m[36m:[m360[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
                    "pipeline_end duration_ms=%.1f trades=%s sharpe=%.2f pnl=%.2f",
                                                                               ^
[1m.\backtest\engine.py[m[36m:[m361[36m:[m80[36m:[m [1m[31mE501[m line too long (105 > 79 characters)
                    total_ms, len(trades_df), metrics.get('sharpe_ratio', 0), metrics.get('total_pnl', 0)
                                                                               ^
[1m.\backtest\engine.py[m[36m:[m365[36m:[m80[36m:[m [1m[31mE501[m line too long (90 > 79 characters)
                fees_total = trades_df['fees'].sum() if 'fees' in trades_df.columns else 0
                                                                               ^
[1m.\backtest\engine.py[m[36m:[m366[36m:[m80[36m:[m [1m[31mE501[m line too long (102 > 79 characters)
                slippage_total = trades_df['slippage'].sum() if 'slippage' in trades_df.columns else 0
                                                                               ^
[1m.\backtest\engine.py[m[36m:[m369[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
                    f"total_return_pct={metrics.get('total_return_pct', 0):.2f} "
                                                                               ^
[1m.\backtest\engine.py[m[36m:[m374[36m:[m80[36m:[m [1m[31mE501[m line too long (104 > 79 characters)
                    f"max_dd_pct={metrics.get('max_drawdown_pct', metrics.get('max_drawdown', 0)):.2f} "
                                                                               ^
[1m.\backtest\engine.py[m[36m:[m376[36m:[m80[36m:[m [1m[31mE501[m line too long (98 > 79 characters)
                    f"win_rate_pct={metrics.get('win_rate_pct', metrics.get('win_rate', 0)):.1f} "
                                                                               ^
[1m.\backtest\engine.py[m[36m:[m382[36m:[m80[36m:[m [1m[31mE501[m line too long (104 > 79 characters)
                    f"warnings_count={counting_handler.warnings} errors_count={counting_handler.errors}"
                                                                               ^
[1m.\backtest\engine.py[m[36m:[m395[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
            if 'counting_handler' in locals() and 'underlying_logger' in locals():
                                                                               ^
[1m.\backtest\engine.py[m[36m:[m428[36m:[m80[36m:[m [1m[31mE501[m line too long (108 > 79 characters)
        from strategies.base import get_strategy, list_strategies  # pylint: disable=import-outside-toplevel
                                                                               ^
[1m.\backtest\engine.py[m[36m:[m437[36m:[m80[36m:[m [1m[31mE501[m line too long (96 > 79 characters)
            raise ValueError(f"Strat√©gie inconnue: '{name}'. Disponibles: {available}") from exc
                                                                               ^
[1m.\backtest\engine.py[m[36m:[m454[36m:[m80[36m:[m [1m[31mE501[m line too long (95 > 79 characters)
            indicator_params = self._extract_indicator_params(strategy, indicator_name, params)
                                                                               ^
[1m.\backtest\engine.py[m[36m:[m460[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
                        indicator_name, indicator_params, df, data_hash=data_hash
                                                                               ^
[1m.\backtest\engine.py[m[36m:[m465[36m:[m80[36m:[m [1m[31mE501[m line too long (86 > 79 characters)
                    result = calculate_indicator(indicator_name, df, indicator_params)
                                                                               ^
[1m.\backtest\engine.py[m[36m:[m476[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
                self.logger.warning("  ‚ö†Ô∏è Erreur calcul %s: %s", indicator_name, e)
                                                                               ^
[1m.\backtest\engine.py[m[36m:[m481[36m:[m80[36m:[m [1m[31mE501[m line too long (85 > 79 characters)
    def _get_indicator_bank(self, params: Dict[str, Any]) -> Optional[IndicatorBank]:
                                                                               ^
[1m.\backtest\engine.py[m[36m:[m491[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
                kwargs["max_size_mb"] = float(params["indicator_cache_max_size_mb"])
                                                                               ^
[1m.\backtest\engine.py[m[36m:[m493[36m:[m80[36m:[m [1m[31mE501[m line too long (92 > 79 characters)
                kwargs["memory_max_entries"] = int(params["indicator_cache_memory_entries"])
                                                                               ^
[1m.\backtest\engine.py[m[36m:[m494[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
            self.indicator_bank = get_indicator_bank(cache_dir=cache_dir, **kwargs)
                                                                               ^
[1m.\backtest\engine.py[m[36m:[m497[36m:[m80[36m:[m [1m[31mE501[m line too long (93 > 79 characters)
    def _build_execution_engine(self, params: Dict[str, Any]) -> Optional["ExecutionEngine"]:
                                                                               ^
[1m.\backtest\engine.py[m[36m:[m504[36m:[m80[36m:[m [1m[31mE501[m line too long (105 > 79 characters)
        from backtest.execution import create_execution_engine  # pylint: disable=import-outside-toplevel
                                                                               ^
[1m.\backtest\engine.py[m[36m:[m543[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
        # Option 1: Si la strat√©gie a une m√©thode get_indicator_params, l'utiliser
                                                                               ^
[1m.\backtest\engine.py[m[36m:[m624[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
# - Conventions d'unit√©s/normalisations explicit√©es (signaux 1/-1/0, prix en devise)
                                                                               ^
[1m.\backtest\errors.py[m[36m:[m4[36m:[m80[36m:[m [1m[31mE501[m line too long (113 > 79 characters)
"""
Module-ID: backtest.errors

Purpose: Hi√©rarchie structur√©e d'exceptions pour distinguer erreurs utilisateur/syst√®me et messages UI coh√©rents.

Role in pipeline: error handling

Key components: BacktestError, UserInputError, DataError, BackendInternalError, LLMUnavailableError

Inputs: message, code, hint, details

Outputs: Exceptions s√©rialisables en dict (code, message, hint, details)

Dependencies: dataclasses, typing

Conventions: Codes error en UPPER_SNAKE_CASE; hints destin√©s utilisateurs (non techniques); details pour logs/debug; to_dict() pour s√©rialisation UI.

Read-if: Gestion erreurs backend/UI, codes erreur, ou messages utilisateur.

Skip-if: Vous n'ajoutez pas de nouveaux types d'erreurs.
"""
   
                          

                                               ^
[1m.\backtest\errors.py[m[36m:[m8[36m:[m80[36m:[m [1m[31mE501[m line too long (99 > 79 characters)
"""
Module-ID: backtest.errors

Purpose: Hi√©rarchie structur√©e d'exceptions pour distinguer erreurs utilisateur/syst√®me et messages UI coh√©rents.

Role in pipeline: error handling

Key components: BacktestError, UserInputError, DataError, BackendInternalError, LLMUnavailableError

Inputs: message, code, hint, details

Outputs: Exceptions s√©rialisables en dict (code, message, hint, details)

Dependencies: dataclasses, typing

Conventions: Codes error en UPPER_SNAKE_CASE; hints destin√©s utilisateurs (non techniques); details pour logs/debug; to_dict() pour s√©rialisation UI.

Read-if: Gestion erreurs backend/UI, codes erreur, ou messages utilisateur.

Skip-if: Vous n'ajoutez pas de nouveaux types d'erreurs.
"""
   
                          

                                               ^
[1m.\backtest\errors.py[m[36m:[m16[36m:[m80[36m:[m [1m[31mE501[m line too long (149 > 79 characters)
"""
Module-ID: backtest.errors

Purpose: Hi√©rarchie structur√©e d'exceptions pour distinguer erreurs utilisateur/syst√®me et messages UI coh√©rents.

Role in pipeline: error handling

Key components: BacktestError, UserInputError, DataError, BackendInternalError, LLMUnavailableError

Inputs: message, code, hint, details

Outputs: Exceptions s√©rialisables en dict (code, message, hint, details)

Dependencies: dataclasses, typing

Conventions: Codes error en UPPER_SNAKE_CASE; hints destin√©s utilisateurs (non techniques); details pour logs/debug; to_dict() pour s√©rialisation UI.

Read-if: Gestion erreurs backend/UI, codes erreur, ou messages utilisateur.

Skip-if: Vous n'ajoutez pas de nouveaux types d'erreurs.
"""
   
                          

                                               ^
[1m.\backtest\errors.py[m[36m:[m142[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
    """
    Erreur lorsque les donn√©es sont insuffisantes pour le warmup des indicateurs.

    Exemples:
    - Fen√™tre temporelle trop courte (49 barres < 200 requis)
    - P√©riode d'indicateur > donn√©es disponibles
    """
       
                                                                       ^
[1m.\backtest\errors.py[m[36m:[m164[36m:[m80[36m:[m [1m[31mE501[m line too long (98 > 79 characters)
        default_hint = "Utilisez une p√©riode plus longue ou v√©rifiez la disponibilit√© des donn√©es"
                                                                               ^
[1m.\backtest\errors.py[m[36m:[m295[36m:[m80[36m:[m [1m[31mE501[m line too long (85 > 79 characters)
# - Docstring de module normalis√©e (LLM-friendly) centr√©e sur hi√©rarchie d'exceptions
                                                                               ^
[1m.\backtest\execution.py[m[36m:[m4[36m:[m80[36m:[m [1m[31mE501[m line too long (91 > 79 characters)
"""
Module-ID: backtest.execution

Purpose: Mod√©liser l'ex√©cution r√©aliste (spread bid/ask, slippage, latence, impact march√©).

Role in pipeline: execution

Key components: ExecutionModel, ExecutionConfig, SpreadCalculator, SlippageCalculator

Inputs: Prix OHLCV, volatilit√©, volume, mod√®le (IDEAL/FIXED/DYNAMIC/REALISTIC)

Outputs: Spread/slippage appliqu√©s au prix d'ex√©cution

Dependencies: numpy, pandas, utils.log, optionnel: backtest.execution_fast (Numba)

Conventions: Spread en bps; slippage en fractions; latence en ms; mod√®les IDEAL < FIXED < DYNAMIC < REALISTIC en r√©alisme; optimisation 50-100x via Numba si dispo.

Read-if: Configuration r√©alisme ex√©cution, calcul spread/slippage, ou modification frais/latence.

Skip-if: Backtests acad√©miques (IDEAL model suffisant).
"""
   
                             

                                            ^
[1m.\backtest\execution.py[m[36m:[m8[36m:[m80[36m:[m [1m[31mE501[m line too long (85 > 79 characters)
"""
Module-ID: backtest.execution

Purpose: Mod√©liser l'ex√©cution r√©aliste (spread bid/ask, slippage, latence, impact march√©).

Role in pipeline: execution

Key components: ExecutionModel, ExecutionConfig, SpreadCalculator, SlippageCalculator

Inputs: Prix OHLCV, volatilit√©, volume, mod√®le (IDEAL/FIXED/DYNAMIC/REALISTIC)

Outputs: Spread/slippage appliqu√©s au prix d'ex√©cution

Dependencies: numpy, pandas, utils.log, optionnel: backtest.execution_fast (Numba)

Conventions: Spread en bps; slippage en fractions; latence en ms; mod√®les IDEAL < FIXED < DYNAMIC < REALISTIC en r√©alisme; optimisation 50-100x via Numba si dispo.

Read-if: Configuration r√©alisme ex√©cution, calcul spread/slippage, ou modification frais/latence.

Skip-if: Backtests acad√©miques (IDEAL model suffisant).
"""
   
                             

                                            ^
[1m.\backtest\execution.py[m[36m:[m14[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
"""
Module-ID: backtest.execution

Purpose: Mod√©liser l'ex√©cution r√©aliste (spread bid/ask, slippage, latence, impact march√©).

Role in pipeline: execution

Key components: ExecutionModel, ExecutionConfig, SpreadCalculator, SlippageCalculator

Inputs: Prix OHLCV, volatilit√©, volume, mod√®le (IDEAL/FIXED/DYNAMIC/REALISTIC)

Outputs: Spread/slippage appliqu√©s au prix d'ex√©cution

Dependencies: numpy, pandas, utils.log, optionnel: backtest.execution_fast (Numba)

Conventions: Spread en bps; slippage en fractions; latence en ms; mod√®les IDEAL < FIXED < DYNAMIC < REALISTIC en r√©alisme; optimisation 50-100x via Numba si dispo.

Read-if: Configuration r√©alisme ex√©cution, calcul spread/slippage, ou modification frais/latence.

Skip-if: Backtests acad√©miques (IDEAL model suffisant).
"""
   
                             

                                            ^
[1m.\backtest\execution.py[m[36m:[m16[36m:[m80[36m:[m [1m[31mE501[m line too long (163 > 79 characters)
"""
Module-ID: backtest.execution

Purpose: Mod√©liser l'ex√©cution r√©aliste (spread bid/ask, slippage, latence, impact march√©).

Role in pipeline: execution

Key components: ExecutionModel, ExecutionConfig, SpreadCalculator, SlippageCalculator

Inputs: Prix OHLCV, volatilit√©, volume, mod√®le (IDEAL/FIXED/DYNAMIC/REALISTIC)

Outputs: Spread/slippage appliqu√©s au prix d'ex√©cution

Dependencies: numpy, pandas, utils.log, optionnel: backtest.execution_fast (Numba)

Conventions: Spread en bps; slippage en fractions; latence en ms; mod√®les IDEAL < FIXED < DYNAMIC < REALISTIC en r√©alisme; optimisation 50-100x via Numba si dispo.

Read-if: Configuration r√©alisme ex√©cution, calcul spread/slippage, ou modification frais/latence.

Skip-if: Backtests acad√©miques (IDEAL model suffisant).
"""
   
                             

                                            ^
[1m.\backtest\execution.py[m[36m:[m18[36m:[m80[36m:[m [1m[31mE501[m line too long (97 > 79 characters)
"""
Module-ID: backtest.execution

Purpose: Mod√©liser l'ex√©cution r√©aliste (spread bid/ask, slippage, latence, impact march√©).

Role in pipeline: execution

Key components: ExecutionModel, ExecutionConfig, SpreadCalculator, SlippageCalculator

Inputs: Prix OHLCV, volatilit√©, volume, mod√®le (IDEAL/FIXED/DYNAMIC/REALISTIC)

Outputs: Spread/slippage appliqu√©s au prix d'ex√©cution

Dependencies: numpy, pandas, utils.log, optionnel: backtest.execution_fast (Numba)

Conventions: Spread en bps; slippage en fractions; latence en ms; mod√®les IDEAL < FIXED < DYNAMIC < REALISTIC en r√©alisme; optimisation 50-100x via Numba si dispo.

Read-if: Configuration r√©alisme ex√©cution, calcul spread/slippage, ou modification frais/latence.

Skip-if: Backtests acad√©miques (IDEAL model suffisant).
"""
   
                             

                                            ^
[1m.\backtest\execution.py[m[36m:[m42[36m:[m80[36m:[m [1m[31mE501[m line too long (97 > 79 characters)
    logger.debug(f"Execution optimizations: Numba={'available' if HAS_NUMBA else 'unavailable'}")
                                                                               ^
[1m.\backtest\execution.py[m[36m:[m238[36m:[m80[36m:[m [1m[31mE501[m line too long (95 > 79 characters)
            volatility_series = returns_series.rolling(window=window, min_periods=window).std()
                                                                               ^
[1m.\backtest\execution.py[m[36m:[m256[36m:[m80[36m:[m [1m[31mE501[m line too long (86 > 79 characters)
                    self._normalized_volatility = np.ones_like(self._volatility) * 0.5
                                                                               ^
[1m.\backtest\execution.py[m[36m:[m270[36m:[m80[36m:[m [1m[31mE501[m line too long (89 > 79 characters)
            avg_volume = volumes_series.rolling(window=window, min_periods=window).mean()
                                                                               ^
[1m.\backtest\execution.py[m[36m:[m281[36m:[m80[36m:[m [1m[31mE501[m line too long (88 > 79 characters)
                self._volume_ratio = np.where(volume_ratio > 0, 1.0 / volume_ratio, 1.0)
                                                                               ^
[1m.\backtest\execution.py[m[36m:[m302[36m:[m80[36m:[m [1m[31mE501[m line too long (89 > 79 characters)
        if self.config.use_volatility_spread and self._normalized_volatility is not None:
                                                                               ^
[1m.\backtest\execution.py[m[36m:[m305[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
            spread_adjustment = vol_factor * self.config.volatility_spread_factor
                                                                               ^
[1m.\backtest\execution.py[m[36m:[m314[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
    def _calculate_slippage_bps(self, bar_idx: int, size: float = 1.0) -> float:
                                                                               ^
[1m.\backtest\execution.py[m[36m:[m372[36m:[m80[36m:[m [1m[31mE501[m line too long (106 > 79 characters)
        if not self._prepared and self.config.model in (ExecutionModel.DYNAMIC, ExecutionModel.REALISTIC):
                                                                               ^
[1m.\backtest\execution.py[m[36m:[m373[36m:[m80[36m:[m [1m[31mE501[m line too long (85 > 79 characters)
            logger.warning("ExecutionEngine non pr√©par√© - utilisation valeurs fixes")
                                                                               ^
[1m.\backtest\execution.py[m[36m:[m401[36m:[m80[36m:[m [1m[31mE501[m line too long (95 > 79 characters)
        if self.config.model == ExecutionModel.REALISTIC and self.config.partial_fill_prob > 0:
                                                                               ^
[1m.\backtest\execution.py[m[36m:[m420[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
    def get_bid_ask(self, mid_price: float, bar_idx: int) -> Tuple[float, float]:
                                                                               ^
[1m.\backtest\execution.py[m[36m:[m512[36m:[m80[36m:[m [1m[31mE501[m line too long (88 > 79 characters)
        """
        Estimateur de Roll pour le spread bid/ask.

        Bas√© sur l'autocovariance des rendements.
        Roll (1984): spread = 2 * sqrt(-cov(r_t, r_{t-1}))

        Args:
            closes: Array des prix de cl√¥ture
            window: Fen√™tre de calcul

        Returns:
            Array des spreads estim√©s (en valeur, pas en BPS)

        Notes:
            Utilise impl√©mentation optimis√©e (Numba si disponible, sinon pandas rolling)
        """
           
                                                  

               ^
[1m.\backtest\execution.py[m[36m:[m521[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
        # Fallback: pandas rolling (vectoris√©, 50x plus rapide que boucle Python)
                                                                               ^
[1m.\backtest\execution.py[m[36m:[m528[36m:[m80[36m:[m [1m[31mE501[m line too long (86 > 79 characters)
        spreads[negative_cov] = 2 * np.sqrt(-cov[negative_cov]) * closes[negative_cov]
                                                                               ^
[1m.\backtest\execution.py[m[36m:[m552[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
        closes: np.ndarray = None  # Pas utilis√© mais gard√© pour compatibilit√© API
                                                                               ^
[1m.\backtest\execution.py[m[36m:[m566[36m:[m80[36m:[m [1m[31mE501[m line too long (87 > 79 characters)
        """
        Estimateur Corwin-Schultz bas√© sur High-Low.

        Args:
            highs: Array des hauts
            lows: Array des bas
            closes: Array des cl√¥tures (non utilis√©, pour compatibilit√©)

        Returns:
            Array des spreads estim√©s en BPS

        Notes:
            Utilise impl√©mentation optimis√©e (Numba si disponible, sinon boucle Python)
        """
           
                                                    

             ^
[1m.\backtest\execution.py[m[36m:[m572[36m:[m80[36m:[m [1m[31mE501[m line too long (91 > 79 characters)
        # Fallback: boucle Python (difficilement vectorisable √† cause de max/min imbriqu√©s)
                                                                               ^
[1m.\backtest\execution.py[m[36m:[m579[36m:[m80[36m:[m [1m[31mE501[m line too long (92 > 79 characters)
            beta = (np.log(highs[i] / lows[i])) ** 2 + (np.log(highs[i-1] / lows[i-1])) ** 2
                                                                               ^
[1m.\backtest\execution.py[m[36m:[m582[36m:[m80[36m:[m [1m[31mE501[m line too long (86 > 79 characters)
            gamma = (np.log(max(highs[i], highs[i-1]) / min(lows[i], lows[i-1]))) ** 2
                                                                               ^
[1m.\backtest\execution.py[m[36m:[m587[36m:[m80[36m:[m [1m[31mE501[m line too long (92 > 79 characters)
                alpha = (np.sqrt(2 * beta) - np.sqrt(beta)) / denom - np.sqrt(gamma / denom)
                                                                               ^
[1m.\backtest\execution.py[m[36m:[m737[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
# - Docstring de module normalis√©e (LLM-friendly) centr√©e sur ex√©cution r√©aliste
                                                                               ^
[1m.\backtest\execution.py[m[36m:[m738[36m:[m80[36m:[m [1m[31mE501[m line too long (91 > 79 characters)
# - Conventions spread (bps), slippage (fractions), mod√®les (IDEAL...REALISTIC) explicit√©es
                                                                               ^
[1m.\backtest\execution_fast.py[m[36m:[m4[36m:[m80[36m:[m [1m[31mE501[m line too long (96 > 79 characters)
"""
Module-ID: backtest.execution_fast

Purpose: Optimisations Numba JIT pour calculs spread/slippage dynamiques (50-100x acc√©l√©ration).

Role in pipeline: execution / performance

Key components: roll_spread_numba, high_low_spread_numba, HAS_NUMBA flag

Inputs: closes array, returns array, volatilit√©, volume

Outputs: Spreads/slippages vectoris√©s (arrays numpy)

Dependencies: numpy, optionnel: numba (JIT compilation); fallback Python si numba absent

Conventions: HAS_NUMBA = False si numba non install√© (fallback OK); spreads en fractions; cache=True pour r√©utilisation.

Read-if: Optimisation ex√©cution ou modification calculs spread/slippage.

Skip-if: Performances acceptables avec execution.py pur Python.
"""
   
                                  

                                       ^
[1m.\backtest\execution_fast.py[m[36m:[m14[36m:[m80[36m:[m [1m[31mE501[m line too long (88 > 79 characters)
"""
Module-ID: backtest.execution_fast

Purpose: Optimisations Numba JIT pour calculs spread/slippage dynamiques (50-100x acc√©l√©ration).

Role in pipeline: execution / performance

Key components: roll_spread_numba, high_low_spread_numba, HAS_NUMBA flag

Inputs: closes array, returns array, volatilit√©, volume

Outputs: Spreads/slippages vectoris√©s (arrays numpy)

Dependencies: numpy, optionnel: numba (JIT compilation); fallback Python si numba absent

Conventions: HAS_NUMBA = False si numba non install√© (fallback OK); spreads en fractions; cache=True pour r√©utilisation.

Read-if: Optimisation ex√©cution ou modification calculs spread/slippage.

Skip-if: Performances acceptables avec execution.py pur Python.
"""
   
                                  

                                       ^
[1m.\backtest\execution_fast.py[m[36m:[m16[36m:[m80[36m:[m [1m[31mE501[m line too long (120 > 79 characters)
"""
Module-ID: backtest.execution_fast

Purpose: Optimisations Numba JIT pour calculs spread/slippage dynamiques (50-100x acc√©l√©ration).

Role in pipeline: execution / performance

Key components: roll_spread_numba, high_low_spread_numba, HAS_NUMBA flag

Inputs: closes array, returns array, volatilit√©, volume

Outputs: Spreads/slippages vectoris√©s (arrays numpy)

Dependencies: numpy, optionnel: numba (JIT compilation); fallback Python si numba absent

Conventions: HAS_NUMBA = False si numba non install√© (fallback OK); spreads en fractions; cache=True pour r√©utilisation.

Read-if: Optimisation ex√©cution ou modification calculs spread/slippage.

Skip-if: Performances acceptables avec execution.py pur Python.
"""
   
                                  

                                       ^
[1m.\backtest\execution_fast.py[m[36m:[m183[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
    spreads[negative_cov] = 2 * np.sqrt(-cov[negative_cov]) * closes[negative_cov]
                                                                               ^
[1m.\backtest\execution_fast.py[m[36m:[m198[36m:[m80[36m:[m [1m[31mE501[m line too long (88 > 79 characters)
        beta = (np.log(highs[i] / lows[i])) ** 2 + (np.log(highs[i-1] / lows[i-1])) ** 2
                                                                               ^
[1m.\backtest\execution_fast.py[m[36m:[m199[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
        gamma = (np.log(max(highs[i], highs[i-1]) / min(lows[i], lows[i-1]))) ** 2
                                                                               ^
[1m.\backtest\execution_fast.py[m[36m:[m203[36m:[m80[36m:[m [1m[31mE501[m line too long (90 > 79 characters)
            alpha = (np.sqrt(2.0 * beta) - np.sqrt(beta)) / denom - np.sqrt(gamma / denom)
                                                                               ^
[1m.\backtest\execution_fast.py[m[36m:[m214[36m:[m80[36m:[m [1m[31mE501[m line too long (85 > 79 characters)
# - Docstring de module normalis√©e (LLM-friendly) centr√©e sur optimisations Numba JIT
                                                                               ^
[1m.\backtest\facade.py[m[36m:[m4[36m:[m80[36m:[m [1m[31mE501[m line too long (90 > 79 characters)
"""
Module-ID: backtest.facade

Purpose: Interface stable et typ√©e entre l'UI et le backend (BacktestEngine + agents LLM).

Role in pipeline: orchestration / api

Key components: BackendFacade, BacktestRequest, BackendResponse, ResponseStatus, ErrorCode

Inputs: BacktestRequest (params, strat√©gie, donn√©es), validation_fn optionnel

Outputs: BackendResponse (format unifi√©), erreurs structur√©es (jamais de traceback brut UI)

Dependencies: backtest.engine, backtest.errors, utils.config, dataclasses

Conventions: Erreurs via Response.status/error_code/error_message (jamais exceptions UI); contrats Request/Response immuables; warmup auto >= 200.

Read-if: Modification l'API UI‚Üîbackend, erreurs struct, ou contrats de r√©ponse.

Skip-if: Vous ne touchez qu'au moteur backtest pur.
"""
   
                          

                                               ^
[1m.\backtest\facade.py[m[36m:[m8[36m:[m80[36m:[m [1m[31mE501[m line too long (90 > 79 characters)
"""
Module-ID: backtest.facade

Purpose: Interface stable et typ√©e entre l'UI et le backend (BacktestEngine + agents LLM).

Role in pipeline: orchestration / api

Key components: BackendFacade, BacktestRequest, BackendResponse, ResponseStatus, ErrorCode

Inputs: BacktestRequest (params, strat√©gie, donn√©es), validation_fn optionnel

Outputs: BackendResponse (format unifi√©), erreurs structur√©es (jamais de traceback brut UI)

Dependencies: backtest.engine, backtest.errors, utils.config, dataclasses

Conventions: Erreurs via Response.status/error_code/error_message (jamais exceptions UI); contrats Request/Response immuables; warmup auto >= 200.

Read-if: Modification l'API UI‚Üîbackend, erreurs struct, ou contrats de r√©ponse.

Skip-if: Vous ne touchez qu'au moteur backtest pur.
"""
   
                          

                                               ^
[1m.\backtest\facade.py[m[36m:[m12[36m:[m80[36m:[m [1m[31mE501[m line too long (91 > 79 characters)
"""
Module-ID: backtest.facade

Purpose: Interface stable et typ√©e entre l'UI et le backend (BacktestEngine + agents LLM).

Role in pipeline: orchestration / api

Key components: BackendFacade, BacktestRequest, BackendResponse, ResponseStatus, ErrorCode

Inputs: BacktestRequest (params, strat√©gie, donn√©es), validation_fn optionnel

Outputs: BackendResponse (format unifi√©), erreurs structur√©es (jamais de traceback brut UI)

Dependencies: backtest.engine, backtest.errors, utils.config, dataclasses

Conventions: Erreurs via Response.status/error_code/error_message (jamais exceptions UI); contrats Request/Response immuables; warmup auto >= 200.

Read-if: Modification l'API UI‚Üîbackend, erreurs struct, ou contrats de r√©ponse.

Skip-if: Vous ne touchez qu'au moteur backtest pur.
"""
   
                          

                                               ^
[1m.\backtest\facade.py[m[36m:[m16[36m:[m80[36m:[m [1m[31mE501[m line too long (146 > 79 characters)
"""
Module-ID: backtest.facade

Purpose: Interface stable et typ√©e entre l'UI et le backend (BacktestEngine + agents LLM).

Role in pipeline: orchestration / api

Key components: BackendFacade, BacktestRequest, BackendResponse, ResponseStatus, ErrorCode

Inputs: BacktestRequest (params, strat√©gie, donn√©es), validation_fn optionnel

Outputs: BackendResponse (format unifi√©), erreurs structur√©es (jamais de traceback brut UI)

Dependencies: backtest.engine, backtest.errors, utils.config, dataclasses

Conventions: Erreurs via Response.status/error_code/error_message (jamais exceptions UI); contrats Request/Response immuables; warmup auto >= 200.

Read-if: Modification l'API UI‚Üîbackend, erreurs struct, ou contrats de r√©ponse.

Skip-if: Vous ne touchez qu'au moteur backtest pur.
"""
   
                          

                                               ^
[1m.\backtest\facade.py[m[36m:[m45[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
# Warmup minimal par d√©faut (conservateur pour couvrir la plupart des strat√©gies)
                                                                               ^
[1m.\backtest\facade.py[m[36m:[m103[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
        if self.data is None and (self.symbol is None or self.timeframe is None):
                                                                               ^
[1m.\backtest\facade.py[m[36m:[m241[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
    """
    Payload complet pour l'affichage UI.

    Contient toutes les donn√©es n√©cessaires pour afficher un r√©sultat de backtest.
    """
       
                                        

                             ^
[1m.\backtest\facade.py[m[36m:[m308[36m:[m80[36m:[m [1m[31mE501[m line too long (85 > 79 characters)
    results: List[Dict[str, Any]] = field(default_factory=list)  # Tous les r√©sultats
                                                                               ^
[1m.\backtest\facade.py[m[36m:[m386[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
        self._logger.info(f"[{trace_id}] run_backtest: {request.strategy_name}")
                                                                               ^
[1m.\backtest\facade.py[m[36m:[m424[36m:[m80[36m:[m [1m[31mE501[m line too long (89 > 79 characters)
                message=f"Backtest termin√© | Sharpe: {payload.metrics.sharpe_ratio:.2f}",
                                                                               ^
[1m.\backtest\facade.py[m[36m:[m453[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
                    hint="Utilisez list_strategies() pour voir les disponibles",
                                                                               ^
[1m.\backtest\facade.py[m[36m:[m529[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
                    metric_value = result.metrics.get(request.metric_to_optimize, 0)
                                                                               ^
[1m.\backtest\facade.py[m[36m:[m554[36m:[m80[36m:[m [1m[31mE501[m line too long (90 > 79 characters)
            status = ResponseStatus.SUCCESS if fail_count == 0 else ResponseStatus.PARTIAL
                                                                               ^
[1m.\backtest\facade.py[m[36m:[m752[36m:[m80[36m:[m [1m[31mE501[m line too long (88 > 79 characters)
                    hint="V√©rifiez que Ollama est d√©marr√© ou que la cl√© API est valide",
                                                                               ^
[1m.\backtest\facade.py[m[36m:[m763[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
                    message_user=f"Erreur lors de l'optimisation LLM: {str(e)}",
                                                                               ^
[1m.\backtest\facade.py[m[36m:[m833[36m:[m80[36m:[m [1m[31mE501[m line too long (89 > 79 characters)
        """
        Charge les donn√©es OHLCV avec validation de warmup minimal.

        Args:
            symbol: Symbole √† charger (ex: "BTCUSDT")
            timeframe: Timeframe (1h, 4h, 1d, etc.)
            start: Date de d√©but (optionnel)
            end: Date de fin (optionnel)
            warmup_required: Nombre minimal de barres requis (d√©faut: WARMUP_MIN_DEFAULT)

        Returns:
            DataFrame OHLCV valid√©

        Raises:
            InsufficientDataError: Si les donn√©es sont insuffisantes
            DataError: Si les donn√©es sont introuvables
        """
           
                                                                   ^
[1m.\backtest\facade.py[m[36m:[m853[36m:[m80[36m:[m [1m[31mE501[m line too long (108 > 79 characters)
                    f"Fen√™tre trop courte d√©tect√©e: {expected_bars} barres estim√©es < {warmup_min} requis. "
                                                                               ^
[1m.\backtest\facade.py[m[36m:[m854[36m:[m80[36m:[m [1m[31mE501[m line too long (92 > 79 characters)
                    f"Neutralisation des dates pour charger toutes les donn√©es disponibles."
                                                                               ^
[1m.\backtest\facade.py[m[36m:[m875[36m:[m80[36m:[m [1m[31mE501[m line too long (119 > 79 characters)
                message=f"Donn√©es insuffisantes: {actual_bars} barres < {warmup_min} requis pour {symbol}_{timeframe}",
                                                                               ^
[1m.\backtest\facade.py[m[36m:[m880[36m:[m80[36m:[m [1m[31mE501[m line too long (92 > 79 characters)
                hint=f"Le warmup des indicateurs n√©cessite au minimum {warmup_min} barres. "
                                                                               ^
[1m.\backtest\facade.py[m[36m:[m881[36m:[m80[36m:[m [1m[31mE501[m line too long (85 > 79 characters)
                     f"Disponibles: {actual_bars}. Utilisez une p√©riode plus longue."
                                                                               ^
[1m.\backtest\facade.py[m[36m:[m885[36m:[m80[36m:[m [1m[31mE501[m line too long (95 > 79 characters)
            f"Donn√©es charg√©es avec succ√®s: {actual_bars} barres (warmup requis: {warmup_min})"
                                                                               ^
[1m.\backtest\facade.py[m[36m:[m926[36m:[m80[36m:[m [1m[31mE501[m line too long (128 > 79 characters)
                    message=f"Donn√©es insuffisantes: {actual_bars} barres < {warmup_required} requis pour {symbol}_{timeframe}",
                                                                               ^
[1m.\backtest\facade.py[m[36m:[m931[36m:[m80[36m:[m [1m[31mE501[m line too long (101 > 79 characters)
                    hint=f"Le warmup des indicateurs n√©cessite au minimum {warmup_required} barres. "
                                                                               ^
[1m.\backtest\facade.py[m[36m:[m932[36m:[m80[36m:[m [1m[31mE501[m line too long (89 > 79 characters)
                         f"Disponibles: {actual_bars}. Utilisez une p√©riode plus longue."
                                                                               ^
[1m.\backtest\facade.py[m[36m:[m967[36m:[m80[36m:[m [1m[31mE501[m line too long (86 > 79 characters)
def get_facade(config: Optional[Config] = None, debug: bool = False) -> BackendFacade:
                                                                               ^
[1m.\backtest\facade.py[m[36m:[m1000[36m:[m80[36m:[m [1m[31mE501[m line too long (91 > 79 characters)
# - Docstring de module normalis√©e (LLM-friendly) centr√©e sur l'interface stable UI‚Üîbackend
                                                                               ^
[1m.\backtest\metrics_tier_s.py[m[36m:[m4[36m:[m80[36m:[m [1m[31mE501[m line too long (128 > 79 characters)
"""
Module-ID: backtest.metrics_tier_s

Purpose: Calcul des m√©triques avanc√©es (Sortino, Calmar, SQN, Recovery Factor, Ulcer Index, etc.) pour analyse institutionnelle.

Role in pipeline: metrics

Key components: TierSMetrics, calculate_tier_s_metrics, format_tier_s_report, grade_tier_s

Inputs: Returns array, trades list, max_drawdown, PnL

Outputs: TierSMetrics (dataclass), tier_s_score (0-100), tier_s_grade (A/B/C/D/F)

Dependencies: numpy, pandas, optionnel: tabulate (formatage)

Conventions: Toutes les m√©triques normalis√©es (fractions 0-1 pour retours); scores 0-100; grades A=excellent, F=faible.

Read-if: Analyse m√©triques avanc√©es, scores institutionnels, ou grading strat√©gies.

Skip-if: Vous n'utilisez que les m√©triques standards (Sharpe, Sortino basique).
"""
   
                                  

                                       ^
[1m.\backtest\metrics_tier_s.py[m[36m:[m8[36m:[m80[36m:[m [1m[31mE501[m line too long (90 > 79 characters)
"""
Module-ID: backtest.metrics_tier_s

Purpose: Calcul des m√©triques avanc√©es (Sortino, Calmar, SQN, Recovery Factor, Ulcer Index, etc.) pour analyse institutionnelle.

Role in pipeline: metrics

Key components: TierSMetrics, calculate_tier_s_metrics, format_tier_s_report, grade_tier_s

Inputs: Returns array, trades list, max_drawdown, PnL

Outputs: TierSMetrics (dataclass), tier_s_score (0-100), tier_s_grade (A/B/C/D/F)

Dependencies: numpy, pandas, optionnel: tabulate (formatage)

Conventions: Toutes les m√©triques normalis√©es (fractions 0-1 pour retours); scores 0-100; grades A=excellent, F=faible.

Read-if: Analyse m√©triques avanc√©es, scores institutionnels, ou grading strat√©gies.

Skip-if: Vous n'utilisez que les m√©triques standards (Sharpe, Sortino basique).
"""
   
                                  

                                       ^
[1m.\backtest\metrics_tier_s.py[m[36m:[m12[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
"""
Module-ID: backtest.metrics_tier_s

Purpose: Calcul des m√©triques avanc√©es (Sortino, Calmar, SQN, Recovery Factor, Ulcer Index, etc.) pour analyse institutionnelle.

Role in pipeline: metrics

Key components: TierSMetrics, calculate_tier_s_metrics, format_tier_s_report, grade_tier_s

Inputs: Returns array, trades list, max_drawdown, PnL

Outputs: TierSMetrics (dataclass), tier_s_score (0-100), tier_s_grade (A/B/C/D/F)

Dependencies: numpy, pandas, optionnel: tabulate (formatage)

Conventions: Toutes les m√©triques normalis√©es (fractions 0-1 pour retours); scores 0-100; grades A=excellent, F=faible.

Read-if: Analyse m√©triques avanc√©es, scores institutionnels, ou grading strat√©gies.

Skip-if: Vous n'utilisez que les m√©triques standards (Sharpe, Sortino basique).
"""
   
                                  

                                       ^
[1m.\backtest\metrics_tier_s.py[m[36m:[m16[36m:[m80[36m:[m [1m[31mE501[m line too long (119 > 79 characters)
"""
Module-ID: backtest.metrics_tier_s

Purpose: Calcul des m√©triques avanc√©es (Sortino, Calmar, SQN, Recovery Factor, Ulcer Index, etc.) pour analyse institutionnelle.

Role in pipeline: metrics

Key components: TierSMetrics, calculate_tier_s_metrics, format_tier_s_report, grade_tier_s

Inputs: Returns array, trades list, max_drawdown, PnL

Outputs: TierSMetrics (dataclass), tier_s_score (0-100), tier_s_grade (A/B/C/D/F)

Dependencies: numpy, pandas, optionnel: tabulate (formatage)

Conventions: Toutes les m√©triques normalis√©es (fractions 0-1 pour retours); scores 0-100; grades A=excellent, F=faible.

Read-if: Analyse m√©triques avanc√©es, scores institutionnels, ou grading strat√©gies.

Skip-if: Vous n'utilisez que les m√©triques standards (Sharpe, Sortino basique).
"""
   
                                  

                                       ^
[1m.\backtest\metrics_tier_s.py[m[36m:[m18[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
"""
Module-ID: backtest.metrics_tier_s

Purpose: Calcul des m√©triques avanc√©es (Sortino, Calmar, SQN, Recovery Factor, Ulcer Index, etc.) pour analyse institutionnelle.

Role in pipeline: metrics

Key components: TierSMetrics, calculate_tier_s_metrics, format_tier_s_report, grade_tier_s

Inputs: Returns array, trades list, max_drawdown, PnL

Outputs: TierSMetrics (dataclass), tier_s_score (0-100), tier_s_grade (A/B/C/D/F)

Dependencies: numpy, pandas, optionnel: tabulate (formatage)

Conventions: Toutes les m√©triques normalis√©es (fractions 0-1 pour retours); scores 0-100; grades A=excellent, F=faible.

Read-if: Analyse m√©triques avanc√©es, scores institutionnels, ou grading strat√©gies.

Skip-if: Vous n'utilisez que les m√©triques standards (Sharpe, Sortino basique).
"""
   
                                  

                                       ^
[1m.\backtest\metrics_tier_s.py[m[36m:[m425[36m:[m80[36m:[m [1m[31mE501[m line too long (88 > 79 characters)
    trimmed_returns = returns_clean[(returns_clean >= lower) & (returns_clean <= upper)]
                                                                               ^
[1m.\backtest\metrics_tier_s.py[m[36m:[m597[36m:[m80[36m:[m [1m[31mE501[m line too long (115 > 79 characters)
        grade_line = f"\n  GRADE: {grade_emoji} {metrics.tier_s_grade}  |  SCORE: {metrics.tier_s_score:.1f}/100\n"
                                                                               ^
[1m.\backtest\metrics_tier_s.py[m[36m:[m627[36m:[m80[36m:[m [1m[31mE501[m line too long (86 > 79 characters)
        report += tabulate(risk_ratios, tablefmt="simple", colalign=("left", "right"))
                                                                               ^
[1m.\backtest\metrics_tier_s.py[m[36m:[m629[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
        report += tabulate(recovery, tablefmt="simple", colalign=("left", "right"))
                                                                               ^
[1m.\backtest\metrics_tier_s.py[m[36m:[m631[36m:[m80[36m:[m [1m[31mE501[m line too long (85 > 79 characters)
        report += tabulate(r_multiple, tablefmt="simple", colalign=("left", "right"))
                                                                               ^
[1m.\backtest\metrics_tier_s.py[m[36m:[m633[36m:[m80[36m:[m [1m[31mE501[m line too long (86 > 79 characters)
        report += tabulate(adjustments, tablefmt="simple", colalign=("left", "right"))
                                                                               ^
[1m.\backtest\metrics_tier_s.py[m[36m:[m643[36m:[m80[36m:[m [1m[31mE501[m line too long (110 > 79 characters)
        report = f"""
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë          M√âTRIQUES TIER S (INSTITUTIONNEL)               ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë GRADE: {grade_emoji} {metrics.tier_s_grade}  |  SCORE: {metrics.tier_s_score:>5.1f}/100                    ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë RATIOS DE RISQUE AJUST√â                                  ‚ïë
‚ïë   Sortino Ratio:       {metrics.sortino_ratio:>10.3f}                     ‚ïë
‚ïë   Calmar Ratio:        {metrics.calmar_ratio:>10.3f}                     ‚ïë
‚ïë   SQN (Van Tharp):     {metrics.sqn:>10.3f}                     ‚ïë
‚ïë   Martin Ratio (UPI):  {metrics.martin_ratio:>10.3f}                     ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë R√âCUP√âRATION & STRESS                                    ‚ïë
‚ïë   Recovery Factor:     {metrics.recovery_factor:>10.3f}                     ‚ïë
‚ïë   Gain/Pain Ratio:     {metrics.gain_pain_ratio:>10.3f}                     ‚ïë
‚ïë   Ulcer Index:         {metrics.ulcer_index:>10.3f}%                    ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë R-MULTIPLE                                               ‚ïë
‚ïë   Avg R-Multiple:      {metrics.avg_r_multiple:>10.3f}R                    ‚ïë
‚ïë   Expectancy (R):      {metrics.expectancy_r:>10.3f}R                    ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë AJUSTEMENTS                                              ‚ïë
‚ïë   Outlier-Adj Sharpe:  {metrics.outlier_adjusted_sharpe:>10.3f}                     ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
"""
                     
                                                         ^
[1m.\backtest\metrics_tier_s.py[m[36m:[m661[36m:[m80[36m:[m [1m[31mE501[m line too long (87 > 79 characters)
        report = f"""
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë          M√âTRIQUES TIER S (INSTITUTIONNEL)               ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë GRADE: {grade_emoji} {metrics.tier_s_grade}  |  SCORE: {metrics.tier_s_score:>5.1f}/100                    ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë RATIOS DE RISQUE AJUST√â                                  ‚ïë
‚ïë   Sortino Ratio:       {metrics.sortino_ratio:>10.3f}                     ‚ïë
‚ïë   Calmar Ratio:        {metrics.calmar_ratio:>10.3f}                     ‚ïë
‚ïë   SQN (Van Tharp):     {metrics.sqn:>10.3f}                     ‚ïë
‚ïë   Martin Ratio (UPI):  {metrics.martin_ratio:>10.3f}                     ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë R√âCUP√âRATION & STRESS                                    ‚ïë
‚ïë   Recovery Factor:     {metrics.recovery_factor:>10.3f}                     ‚ïë
‚ïë   Gain/Pain Ratio:     {metrics.gain_pain_ratio:>10.3f}                     ‚ïë
‚ïë   Ulcer Index:         {metrics.ulcer_index:>10.3f}%                    ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë R-MULTIPLE                                               ‚ïë
‚ïë   Avg R-Multiple:      {metrics.avg_r_multiple:>10.3f}R                    ‚ïë
‚ïë   Expectancy (R):      {metrics.expectancy_r:>10.3f}R                    ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë AJUSTEMENTS                                              ‚ïë
‚ïë   Outlier-Adj Sharpe:  {metrics.outlier_adjusted_sharpe:>10.3f}                     ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
"""
                     
                                                         ^
[1m.\backtest\monte_carlo.py[m[36m:[m4[36m:[m80[36m:[m [1m[31mE501[m line too long (113 > 79 characters)
"""
Module-ID: backtest.monte_carlo

Purpose: √âchantillonnage intelligent de l'espace des param√®tres (random/LHS/Sobol) pour optimisation plus rapide.

Role in pipeline: optimization

Key components: SamplingMethod, ParameterSpace, sample_parameters, MonteCarlo

Inputs: param_space Dict, n_samples, m√©thode (RANDOM/LATIN_HYPERCUBE/SOBOL)

Outputs: √âchantillons (liste de dicts de param√®tres)

Dependencies: numpy, optionnel: scipy.stats (LHS)

Conventions: Param√®tres en fractions [0,1] puis redimensionn√©s; log_scale si demand√©; √©chantillonnage uniforme sur l'espace.

Read-if: Optimisation via Monte Carlo au lieu de sweep exhaustif, ou √©chantillonnage intelligent.

Skip-if: Vous utilisez sweep/optuna/pareto au lieu d'√©chantillonnage al√©atoire.
"""
   
                               

                                          ^
[1m.\backtest\monte_carlo.py[m[36m:[m16[36m:[m80[36m:[m [1m[31mE501[m line too long (124 > 79 characters)
"""
Module-ID: backtest.monte_carlo

Purpose: √âchantillonnage intelligent de l'espace des param√®tres (random/LHS/Sobol) pour optimisation plus rapide.

Role in pipeline: optimization

Key components: SamplingMethod, ParameterSpace, sample_parameters, MonteCarlo

Inputs: param_space Dict, n_samples, m√©thode (RANDOM/LATIN_HYPERCUBE/SOBOL)

Outputs: √âchantillons (liste de dicts de param√®tres)

Dependencies: numpy, optionnel: scipy.stats (LHS)

Conventions: Param√®tres en fractions [0,1] puis redimensionn√©s; log_scale si demand√©; √©chantillonnage uniforme sur l'espace.

Read-if: Optimisation via Monte Carlo au lieu de sweep exhaustif, ou √©chantillonnage intelligent.

Skip-if: Vous utilisez sweep/optuna/pareto au lieu d'√©chantillonnage al√©atoire.
"""
   
                               

                                          ^
[1m.\backtest\monte_carlo.py[m[36m:[m18[36m:[m80[36m:[m [1m[31mE501[m line too long (97 > 79 characters)
"""
Module-ID: backtest.monte_carlo

Purpose: √âchantillonnage intelligent de l'espace des param√®tres (random/LHS/Sobol) pour optimisation plus rapide.

Role in pipeline: optimization

Key components: SamplingMethod, ParameterSpace, sample_parameters, MonteCarlo

Inputs: param_space Dict, n_samples, m√©thode (RANDOM/LATIN_HYPERCUBE/SOBOL)

Outputs: √âchantillons (liste de dicts de param√®tres)

Dependencies: numpy, optionnel: scipy.stats (LHS)

Conventions: Param√®tres en fractions [0,1] puis redimensionn√©s; log_scale si demand√©; √©chantillonnage uniforme sur l'espace.

Read-if: Optimisation via Monte Carlo au lieu de sweep exhaustif, ou √©chantillonnage intelligent.

Skip-if: Vous utilisez sweep/optuna/pareto au lieu d'√©chantillonnage al√©atoire.
"""
   
                               

                                          ^
[1m.\backtest\monte_carlo.py[m[36m:[m298[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
        """
        Lance l'optimisation Monte Carlo.

        Args:
            evaluate_fn: Fonction d'√©valuation (params -> score)
            constraints_fn: Fonction de validation des contraintes (optionnel)
            progress_callback: Callback de progression (current, total, best_score)

        Returns:
            MonteCarloResult avec les meilleurs param√®tres
        """
           
                                         

             
          ^
[1m.\backtest\monte_carlo.py[m[36m:[m317[36m:[m80[36m:[m [1m[31mE501[m line too long (87 > 79 characters)
            raise ValueError("Aucun √©chantillon valide apr√®s filtrage des contraintes")
                                                                               ^
[1m.\backtest\monte_carlo.py[m[36m:[m349[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
                        f"(pas d'am√©lioration depuis {self.early_stop_patience})"
                                                                               ^
[1m.\backtest\monte_carlo.py[m[36m:[m488[36m:[m80[36m:[m [1m[31mE501[m line too long (89 > 79 characters)
# - Docstring de module normalis√©e (LLM-friendly) centr√©e sur √©chantillonnage intelligent
                                                                               ^
[1m.\backtest\optuna_optimizer.py[m[36m:[m4[36m:[m80[36m:[m [1m[31mE501[m line too long (106 > 79 characters)
"""
Module-ID: backtest.optuna_optimizer

Purpose: Optimiser les param√®tres via Optuna (bay√©sien TPE/CMA-ES) avec pruning et support multi-objectif.

Role in pipeline: optimization

Key components: OptunaOptimizer, OptunaResult, OptunaStudyConfig

Inputs: strategy_name, DataFrame OHLCV, param_space Dict, n_trials, m√©trique(s) √† optimiser, contraintes optionnelles

Outputs: OptunaResult (best_params, best_value, study, history)

Dependencies: optuna (TPE/CMA-ES samplers), backtest.engine, utils.observability

Conventions: param_space Dict avec {"param_name": {"type": "int"/"float", "low": X, "high": Y}}; metric "sharpe_ratio" par d√©faut; directions {"metric": 1/-1}; pruning via MedianPruner/HyperbandPruner.

Read-if: Configuration optimisation bay√©sienne, pruning, multi-objectif (Pareto) ou gestion des trials.

Skip-if: Vous utilisez sweep/pareto au lieu d'optuna.
"""
   
                                    

                                     ^
[1m.\backtest\optuna_optimizer.py[m[36m:[m10[36m:[m80[36m:[m [1m[31mE501[m line too long (117 > 79 characters)
"""
Module-ID: backtest.optuna_optimizer

Purpose: Optimiser les param√®tres via Optuna (bay√©sien TPE/CMA-ES) avec pruning et support multi-objectif.

Role in pipeline: optimization

Key components: OptunaOptimizer, OptunaResult, OptunaStudyConfig

Inputs: strategy_name, DataFrame OHLCV, param_space Dict, n_trials, m√©trique(s) √† optimiser, contraintes optionnelles

Outputs: OptunaResult (best_params, best_value, study, history)

Dependencies: optuna (TPE/CMA-ES samplers), backtest.engine, utils.observability

Conventions: param_space Dict avec {"param_name": {"type": "int"/"float", "low": X, "high": Y}}; metric "sharpe_ratio" par d√©faut; directions {"metric": 1/-1}; pruning via MedianPruner/HyperbandPruner.

Read-if: Configuration optimisation bay√©sienne, pruning, multi-objectif (Pareto) ou gestion des trials.

Skip-if: Vous utilisez sweep/pareto au lieu d'optuna.
"""
   
                                    

                                     ^
[1m.\backtest\optuna_optimizer.py[m[36m:[m14[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
"""
Module-ID: backtest.optuna_optimizer

Purpose: Optimiser les param√®tres via Optuna (bay√©sien TPE/CMA-ES) avec pruning et support multi-objectif.

Role in pipeline: optimization

Key components: OptunaOptimizer, OptunaResult, OptunaStudyConfig

Inputs: strategy_name, DataFrame OHLCV, param_space Dict, n_trials, m√©trique(s) √† optimiser, contraintes optionnelles

Outputs: OptunaResult (best_params, best_value, study, history)

Dependencies: optuna (TPE/CMA-ES samplers), backtest.engine, utils.observability

Conventions: param_space Dict avec {"param_name": {"type": "int"/"float", "low": X, "high": Y}}; metric "sharpe_ratio" par d√©faut; directions {"metric": 1/-1}; pruning via MedianPruner/HyperbandPruner.

Read-if: Configuration optimisation bay√©sienne, pruning, multi-objectif (Pareto) ou gestion des trials.

Skip-if: Vous utilisez sweep/pareto au lieu d'optuna.
"""
   
                                    

                                     ^
[1m.\backtest\optuna_optimizer.py[m[36m:[m16[36m:[m80[36m:[m [1m[31mE501[m line too long (201 > 79 characters)
"""
Module-ID: backtest.optuna_optimizer

Purpose: Optimiser les param√®tres via Optuna (bay√©sien TPE/CMA-ES) avec pruning et support multi-objectif.

Role in pipeline: optimization

Key components: OptunaOptimizer, OptunaResult, OptunaStudyConfig

Inputs: strategy_name, DataFrame OHLCV, param_space Dict, n_trials, m√©trique(s) √† optimiser, contraintes optionnelles

Outputs: OptunaResult (best_params, best_value, study, history)

Dependencies: optuna (TPE/CMA-ES samplers), backtest.engine, utils.observability

Conventions: param_space Dict avec {"param_name": {"type": "int"/"float", "low": X, "high": Y}}; metric "sharpe_ratio" par d√©faut; directions {"metric": 1/-1}; pruning via MedianPruner/HyperbandPruner.

Read-if: Configuration optimisation bay√©sienne, pruning, multi-objectif (Pareto) ou gestion des trials.

Skip-if: Vous utilisez sweep/pareto au lieu d'optuna.
"""
   
                                    

                                     ^
[1m.\backtest\optuna_optimizer.py[m[36m:[m18[36m:[m80[36m:[m [1m[31mE501[m line too long (103 > 79 characters)
"""
Module-ID: backtest.optuna_optimizer

Purpose: Optimiser les param√®tres via Optuna (bay√©sien TPE/CMA-ES) avec pruning et support multi-objectif.

Role in pipeline: optimization

Key components: OptunaOptimizer, OptunaResult, OptunaStudyConfig

Inputs: strategy_name, DataFrame OHLCV, param_space Dict, n_trials, m√©trique(s) √† optimiser, contraintes optionnelles

Outputs: OptunaResult (best_params, best_value, study, history)

Dependencies: optuna (TPE/CMA-ES samplers), backtest.engine, utils.observability

Conventions: param_space Dict avec {"param_name": {"type": "int"/"float", "low": X, "high": Y}}; metric "sharpe_ratio" par d√©faut; directions {"metric": 1/-1}; pruning via MedianPruner/HyperbandPruner.

Read-if: Configuration optimisation bay√©sienne, pruning, multi-objectif (Pareto) ou gestion des trials.

Skip-if: Vous utilisez sweep/pareto au lieu d'optuna.
"""
   
                                    

                                     ^
[1m.\backtest\optuna_optimizer.py[m[36m:[m212[36m:[m80[36m:[m [1m[31mE501[m line too long (99 > 79 characters)
        """
        Initialise l'optimiseur.

        Args:
            strategy_name: Nom de la strat√©gie √† optimiser
            data: DataFrame OHLCV
            param_space: Espace des param√®tres √† explorer
                Format: {"param_name": {"type": "int/float/categorical", ...}}
            initial_capital: Capital de d√©part
            constraints: Contraintes entre param√®tres
                Format: [("param1", ">", "param2"), ...]
            seed: Seed pour reproductibilit√©
            early_stop_patience: Arr√™t anticip√© apr√®s N trials sans am√©lioration (None = d√©sactiv√©)
            config: Configuration du moteur (frais, slippage, etc.)
            symbol: Symbole pour les metadonnees
            timeframe: Timeframe pour les metadonnees
        """
           
                                

             
                   ^
[1m.\backtest\optuna_optimizer.py[m[36m:[m251[36m:[m80[36m:[m [1m[31mE501[m line too long (91 > 79 characters)
            len(self.param_specs), len(self.constraints), early_stop_patience or "disabled"
                                                                               ^
[1m.\backtest\optuna_optimizer.py[m[36m:[m276[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
            right_val = params.get(right, 0) if isinstance(right, str) else right
                                                                               ^
[1m.\backtest\optuna_optimizer.py[m[36m:[m310[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
        """
        Cr√©e un callback d'early stopping pour Optuna.

        Arr√™te l'optimisation apr√®s 'patience' trials sans am√©lioration.

        Args:
            patience: Nombre de trials sans am√©lioration avant arr√™t
            direction: "maximize" ou "minimize"
            metric_index: Index de la m√©trique pour multi-objectif (0 par d√©faut)

        Returns:
            Callback Optuna
        """
           
                                                      

           ^
[1m.\backtest\optuna_optimizer.py[m[36m:[m327[36m:[m80[36m:[m [1m[31mE501[m line too long (112 > 79 characters)
                score = trial.values[metric_index] if hasattr(trial, "values") and trial.values else trial.value
                                                                               ^
[1m.\backtest\optuna_optimizer.py[m[36m:[m363[36m:[m80[36m:[m [1m[31mE501[m line too long (89 > 79 characters)
                    "early_stop_triggered trials_without_improvement=%s best_score=%.4f",
                                                                               ^
[1m.\backtest\optuna_optimizer.py[m[36m:[m406[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
                return float("-inf") if direction == "maximize" else float("inf")
                                                                               ^
[1m.\backtest\optuna_optimizer.py[m[36m:[m424[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
                )) or (direction == "minimize" and value < self._best_metrics.get(
                                                                               ^
[1m.\backtest\optuna_optimizer.py[m[36m:[m427[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
                    self._best_metrics = normalize_metrics(result.metrics, "pct")
                                                                               ^
[1m.\backtest\optuna_optimizer.py[m[36m:[m442[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
                return float("-inf") if direction == "maximize" else float("inf")
                                                                               ^
[1m.\backtest\optuna_optimizer.py[m[36m:[m473[36m:[m80[36m:[m [1m[31mE501[m line too long (105 > 79 characters)
        """
        Lance l'optimisation.

        Args:
            n_trials: Nombre de trials √† ex√©cuter
            metric: M√©trique √† optimiser
            direction: "maximize" ou "minimize"
            timeout: Timeout en secondes (optionnel)
            sampler: Algorithme ("tpe", "cmaes", "random")
            pruner: Strat√©gie de pruning ("median", "hyperband", "none")
            n_startup_trials: Trials al√©atoires avant TPE
            show_progress: Afficher la progression
            callbacks: Callbacks Optuna optionnels
            early_stop_patience: Arr√™t apr√®s N trials sans am√©lioration (None = utiliser valeur __init__)

        Returns:
            OptimizationResult avec les meilleurs param√®tres
        """
           
                             

             
                      ^
[1m.\backtest\optuna_optimizer.py[m[36m:[m526[36m:[m80[36m:[m [1m[31mE501[m line too long (103 > 79 characters)
        patience = early_stop_patience if early_stop_patience is not None else self.early_stop_patience
                                                                               ^
[1m.\backtest\optuna_optimizer.py[m[36m:[m529[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
            early_stop_cb = self._create_early_stop_callback(patience, direction)
                                                                               ^
[1m.\backtest\optuna_optimizer.py[m[36m:[m606[36m:[m80[36m:[m [1m[31mE501[m line too long (105 > 79 characters)
        """
        Optimisation multi-objectif (front de Pareto).

        Args:
            n_trials: Nombre de trials
            metrics: Liste des m√©triques √† optimiser
            directions: Liste des directions ("maximize"/"minimize")
            timeout: Timeout en secondes
            show_progress: Afficher la progression
            early_stop_patience: Arr√™t apr√®s N trials sans am√©lioration (None = utiliser valeur __init__)

        Returns:
            MultiObjectiveResult avec le front de Pareto

        Example:
            >>> result = optimizer.optimize_multi_objective(
            ...     n_trials=100,
            ...     metrics=["sharpe_ratio", "max_drawdown_pct"],
            ...     directions=["maximize", "minimize"],
            ... )
        """
           
                                                      

           ^
[1m.\backtest\optuna_optimizer.py[m[36m:[m683[36m:[m80[36m:[m [1m[31mE501[m line too long (103 > 79 characters)
        patience = early_stop_patience if early_stop_patience is not None else self.early_stop_patience
                                                                               ^
[1m.\backtest\optuna_optimizer.py[m[36m:[m686[36m:[m80[36m:[m [1m[31mE501[m line too long (89 > 79 characters)
            # Utiliser la premi√®re m√©trique (index 0) comme r√©f√©rence pour early stopping
                                                                               ^
[1m.\backtest\optuna_optimizer.py[m[36m:[m807[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
            "atr_mult": {"type": "float", "low": 1.0, "high": 3.0, "step": 0.1},
                                                                               ^
[1m.\backtest\optuna_optimizer.py[m[36m:[m847[36m:[m80[36m:[m [1m[31mE501[m line too long (85 > 79 characters)
# - Docstring de module normalis√©e (LLM-friendly) centr√©e sur optimisation bay√©sienne
                                                                               ^
[1m.\backtest\pareto.py[m[36m:[m4[36m:[m80[36m:[m [1m[31mE501[m line too long (97 > 79 characters)
"""
Module-ID: backtest.pareto

Purpose: Optimiser multi-objectif avec d√©tection domination Pareto et early stopping automatique.

Role in pipeline: optimization

Key components: ParetoPoint, ParetoFrontier, pareto_optimize, is_dominated

Inputs: points (params + m√©triques), directions optimisation (1=max, -1=min)

Outputs: ParetoFrontier (fronti√®re optimale), points domin√©s exclu

Dependencies: numpy

Conventions: Point domine si >= sur tous les objectifs et > sur au moins un; fronti√®re mise √† jour dynamiquement; early stop si nouvelle solution non-domin√©e.

Read-if: Multi-objectif (ex: Sharpe ET max_drawdown), pruning automatique, or fronti√®re de Pareto.

Skip-if: Single-objectif uniquement (sweep/optuna simple).
"""
   
                          

                                               ^
[1m.\backtest\pareto.py[m[36m:[m16[36m:[m80[36m:[m [1m[31mE501[m line too long (158 > 79 characters)
"""
Module-ID: backtest.pareto

Purpose: Optimiser multi-objectif avec d√©tection domination Pareto et early stopping automatique.

Role in pipeline: optimization

Key components: ParetoPoint, ParetoFrontier, pareto_optimize, is_dominated

Inputs: points (params + m√©triques), directions optimisation (1=max, -1=min)

Outputs: ParetoFrontier (fronti√®re optimale), points domin√©s exclu

Dependencies: numpy

Conventions: Point domine si >= sur tous les objectifs et > sur au moins un; fronti√®re mise √† jour dynamiquement; early stop si nouvelle solution non-domin√©e.

Read-if: Multi-objectif (ex: Sharpe ET max_drawdown), pruning automatique, or fronti√®re de Pareto.

Skip-if: Single-objectif uniquement (sweep/optuna simple).
"""
   
                          

                                               ^
[1m.\backtest\pareto.py[m[36m:[m18[36m:[m80[36m:[m [1m[31mE501[m line too long (98 > 79 characters)
"""
Module-ID: backtest.pareto

Purpose: Optimiser multi-objectif avec d√©tection domination Pareto et early stopping automatique.

Role in pipeline: optimization

Key components: ParetoPoint, ParetoFrontier, pareto_optimize, is_dominated

Inputs: points (params + m√©triques), directions optimisation (1=max, -1=min)

Outputs: ParetoFrontier (fronti√®re optimale), points domin√©s exclu

Dependencies: numpy

Conventions: Point domine si >= sur tous les objectifs et > sur au moins un; fronti√®re mise √† jour dynamiquement; early stop si nouvelle solution non-domin√©e.

Read-if: Multi-objectif (ex: Sharpe ET max_drawdown), pruning automatique, or fronti√®re de Pareto.

Skip-if: Single-objectif uniquement (sweep/optuna simple).
"""
   
                          

                                               ^
[1m.\backtest\pareto.py[m[36m:[m52[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
    def dominates(self, other: "ParetoPoint", directions: Dict[str, int]) -> bool:
                                                                               ^
[1m.\backtest\pareto.py[m[36m:[m67[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
        dominated_keys = set(self.objectives.keys()) & set(other.objectives.keys())
                                                                               ^
[1m.\backtest\pareto.py[m[36m:[m166[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
            key=lambda p: p.objectives.get(objective, float('-inf')) * direction
                                                                               ^
[1m.\backtest\pareto.py[m[36m:[m356[36m:[m80[36m:[m [1m[31mE501[m line too long (89 > 79 characters)
        quick_evaluate_fn: Optional[Callable[[Dict[str, Any]], Dict[str, float]]] = None,
                                                                               ^
[1m.\backtest\pareto.py[m[36m:[m400[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
            if quick_evaluate_fn and evaluated >= self.min_samples_before_prune:
                                                                               ^
[1m.\backtest\pareto.py[m[36m:[m501[36m:[m80[36m:[m [1m[31mE501[m line too long (94 > 79 characters)
# - Docstring de module normalis√©e (LLM-friendly) centr√©e sur multi-objectif/domination Pareto
                                                                               ^
[1m.\backtest\performance.py[m[36m:[m4[36m:[m80[36m:[m [1m[31mE501[m line too long (110 > 79 characters)
"""
Module-ID: backtest.performance

Purpose: Calculer les m√©triques de performance standard et avanc√©es (rendement, risque, Sharpe, trades, etc.).

Role in pipeline: metrics

Key components: PerformanceMetrics, calculate_metrics, drawdown_series, format_metrics_report

Inputs: PnL array, trades list, returns array, capital initial, dur√©e en jours

Outputs: PerformanceMetrics (dataclass compl√®te), rapports format√©s

Dependencies: numpy, pandas, backtest.metrics_tier_s, utils.log

Conventions: PnL en devise de base; rendements en fractions [0,1] ou pourcentages; dur√©es en jours; Sharpe annualis√© (252 jours).

Read-if: Calcul m√©triques, rapports perfo, ou modification formules.

Skip-if: Vous n'avez besoin que des r√©sultats bruts sans m√©triques.
"""
   
                               

                                          ^
[1m.\backtest\performance.py[m[36m:[m8[36m:[m80[36m:[m [1m[31mE501[m line too long (93 > 79 characters)
"""
Module-ID: backtest.performance

Purpose: Calculer les m√©triques de performance standard et avanc√©es (rendement, risque, Sharpe, trades, etc.).

Role in pipeline: metrics

Key components: PerformanceMetrics, calculate_metrics, drawdown_series, format_metrics_report

Inputs: PnL array, trades list, returns array, capital initial, dur√©e en jours

Outputs: PerformanceMetrics (dataclass compl√®te), rapports format√©s

Dependencies: numpy, pandas, backtest.metrics_tier_s, utils.log

Conventions: PnL en devise de base; rendements en fractions [0,1] ou pourcentages; dur√©es en jours; Sharpe annualis√© (252 jours).

Read-if: Calcul m√©triques, rapports perfo, ou modification formules.

Skip-if: Vous n'avez besoin que des r√©sultats bruts sans m√©triques.
"""
   
                               

                                          ^
[1m.\backtest\performance.py[m[36m:[m16[36m:[m80[36m:[m [1m[31mE501[m line too long (129 > 79 characters)
"""
Module-ID: backtest.performance

Purpose: Calculer les m√©triques de performance standard et avanc√©es (rendement, risque, Sharpe, trades, etc.).

Role in pipeline: metrics

Key components: PerformanceMetrics, calculate_metrics, drawdown_series, format_metrics_report

Inputs: PnL array, trades list, returns array, capital initial, dur√©e en jours

Outputs: PerformanceMetrics (dataclass compl√®te), rapports format√©s

Dependencies: numpy, pandas, backtest.metrics_tier_s, utils.log

Conventions: PnL en devise de base; rendements en fractions [0,1] ou pourcentages; dur√©es en jours; Sharpe annualis√© (252 jours).

Read-if: Calcul m√©triques, rapports perfo, ou modification formules.

Skip-if: Vous n'avez besoin que des r√©sultats bruts sans m√©triques.
"""
   
                               

                                          ^
[1m.\backtest\performance.py[m[36m:[m211[36m:[m80[36m:[m [1m[31mE501[m line too long (85 > 79 characters)
    method: str = "daily_resample",  # "standard", "trading_days" ou "daily_resample"
                                                                               ^
[1m.\backtest\performance.py[m[36m:[m218[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
    '''
    Calcule le ratio de Sharpe annualise.

    Pour limiter les biais des equity curves "sparse", la methode daily_resample
    peut resampler l'equity en quotidien avant de calculer les rendements.
    Des gardes supplmentaires evitent les valeurs aberrantes lorsque seules
    quelques trades non nuls sont disponibles.
    '''
       
                                         

                            ^
[1m.\backtest\performance.py[m[36m:[m223[36m:[m80[36m:[m [1m[31mE501[m line too long (93 > 79 characters)
    returns_series = returns.copy() if isinstance(returns, pd.Series) else pd.Series(returns)
                                                                               ^
[1m.\backtest\performance.py[m[36m:[m245[36m:[m80[36m:[m [1m[31mE501[m line too long (116 > 79 characters)
            # logger.warning("daily_resample necessite equity, fallback sur standard")  # D√©sactiv√© pour performance
                                                                               ^
[1m.\backtest\performance.py[m[36m:[m248[36m:[m80[36m:[m [1m[31mE501[m line too long (121 > 79 characters)
            # logger.warning("equity.index n'est pas DatetimeIndex, fallback sur standard")  # D√©sactiv√© pour performance
                                                                               ^
[1m.\backtest\performance.py[m[36m:[m254[36m:[m80[36m:[m [1m[31mE501[m line too long (93 > 79 characters)
                periods_per_year = 252  # Annualisation coherente avec des returns quotidiens
                                                                               ^
[1m.\backtest\performance.py[m[36m:[m258[36m:[m80[36m:[m [1m[31mE501[m line too long (88 > 79 characters)
                #         f"SHARPE_ZERO run_id={run_id} reason=insufficient_daily_data "
                                                                               ^
[1m.\backtest\performance.py[m[36m:[m259[36m:[m80[36m:[m [1m[31mE501[m line too long (98 > 79 characters)
                #         f"days={len(equity_daily)} min_required=2 fallback=use_provided_returns"
                                                                               ^
[1m.\backtest\performance.py[m[36m:[m263[36m:[m80[36m:[m [1m[31mE501[m line too long (103 > 79 characters)
                #         "sharpe_ratio_insufficient_daily_data days=%s, fallback to provided returns",
                                                                               ^
[1m.\backtest\performance.py[m[36m:[m279[36m:[m80[36m:[m [1m[31mE501[m line too long (92 > 79 characters)
    #     n_inf = np.isinf(returns_series.replace([np.inf, -np.inf], np.nan).dropna()).sum()
                                                                               ^
[1m.\backtest\performance.py[m[36m:[m294[36m:[m80[36m:[m [1m[31mE501[m line too long (93 > 79 characters)
    if equity is not None and isinstance(equity.index, pd.DatetimeIndex) and len(equity) > 0:
                                                                               ^
[1m.\backtest\performance.py[m[36m:[m295[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
        backtest_days = (equity.index[-1] - equity.index[0]).total_seconds() / 86400
                                                                               ^
[1m.\backtest\performance.py[m[36m:[m305[36m:[m80[36m:[m [1m[31mE501[m line too long (88 > 79 characters)
        #         f"samples={len(returns_clean)} min_required={min_samples_for_sharpe} "
                                                                               ^
[1m.\backtest\performance.py[m[36m:[m306[36m:[m80[36m:[m [1m[31mE501[m line too long (92 > 79 characters)
        #         f"adaptive=True backtest_days={backtest_days if backtest_days else 'N/A'}"
                                                                               ^
[1m.\backtest\performance.py[m[36m:[m310[36m:[m80[36m:[m [1m[31mE501[m line too long (89 > 79 characters)
        #         "sharpe_ratio_insufficient_samples samples=%s < min=%s, returning 0.0",
                                                                               ^
[1m.\backtest\performance.py[m[36m:[m321[36m:[m80[36m:[m [1m[31mE501[m line too long (98 > 79 characters)
            #         f"SHARPE_ZERO run_id={run_id} reason=min_samples_after_trading_days_filter "
                                                                               ^
[1m.\backtest\performance.py[m[36m:[m322[36m:[m80[36m:[m [1m[31mE501[m line too long (91 > 79 characters)
            #         f"samples={len(returns_clean)} min_required={min_samples_for_sharpe}"
                                                                               ^
[1m.\backtest\performance.py[m[36m:[m326[36m:[m80[36m:[m [1m[31mE501[m line too long (106 > 79 characters)
            #         "sharpe_ratio_insufficient_samples_after_filter samples=%s < min=%s, returning 0.0",
                                                                               ^
[1m.\backtest\performance.py[m[36m:[m336[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
        #         f"non_zero={non_zero_count} min_required={min_non_zero_returns} "
                                                                               ^
[1m.\backtest\performance.py[m[36m:[m337[36m:[m80[36m:[m [1m[31mE501[m line too long (127 > 79 characters)
        #         f"total_samples={len(returns_clean)} adaptive=True backtest_days={backtest_days if backtest_days else 'N/A'}"
                                                                               ^
[1m.\backtest\performance.py[m[36m:[m341[36m:[m80[36m:[m [1m[31mE501[m line too long (91 > 79 characters)
        #         "sharpe_ratio_insufficient_non_zero non_zero=%s < min=%s, returning 0.0",
                                                                               ^
[1m.\backtest\performance.py[m[36m:[m354[36m:[m80[36m:[m [1m[31mE501[m line too long (86 > 79 characters)
    # min_annual_vol adaptatif : assouplir pour backtests courts ou peu d'√©chantillons
                                                                               ^
[1m.\backtest\performance.py[m[36m:[m364[36m:[m80[36m:[m [1m[31mE501[m line too long (87 > 79 characters)
        #         f"samples={len(returns_clean)} is_finite={np.isfinite(std_returns)} "
                                                                               ^
[1m.\backtest\performance.py[m[36m:[m365[36m:[m80[36m:[m [1m[31mE501[m line too long (94 > 79 characters)
        #         f"adaptive=True min_annual_vol={min_annual_vol} relaxed={needs_relaxed_vol}"
                                                                               ^
[1m.\backtest\performance.py[m[36m:[m369[36m:[m80[36m:[m [1m[31mE501[m line too long (89 > 79 characters)
        #         "sharpe_ratio_zero_volatility std=%.6f < min=%.6f, returns=%s samples",
                                                                               ^
[1m.\backtest\performance.py[m[36m:[m380[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
    #         f"std_returns={std_returns:.6f} periods_per_year={periods_per_year}"
                                                                               ^
[1m.\backtest\performance.py[m[36m:[m383[36m:[m80[36m:[m [1m[31mE501[m line too long (97 > 79 characters)
    sharpe = (mean_excess * np.sqrt(periods_per_year)) / std_returns if periods_per_year else 0.0
                                                                               ^
[1m.\backtest\performance.py[m[36m:[m388[36m:[m80[36m:[m [1m[31mE501[m line too long (97 > 79 characters)
        #     "sharpe_ratio_clamped value=%.2f clamped_to=+/-%.1f std=%.6f mean=%.6f samples=%s",
                                                                               ^
[1m.\backtest\performance.py[m[36m:[m399[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
    #         f"SHARPE_OUTPUT run_id={run_id} sharpe_final={float(sharpe):.4f} "
                                                                               ^
[1m.\backtest\performance.py[m[36m:[m433[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
            logger.warning("daily_resample n√©cessite equity, fallback sur standard")
                                                                               ^
[1m.\backtest\performance.py[m[36m:[m437[36m:[m80[36m:[m [1m[31mE501[m line too long (93 > 79 characters)
                logger.warning("equity.index n'est pas DatetimeIndex, fallback sur standard")
                                                                               ^
[1m.\backtest\performance.py[m[36m:[m445[36m:[m80[36m:[m [1m[31mE501[m line too long (106 > 79 characters)
                # ‚ö†Ô∏è IMPORTANT: Apr√®s resample quotidien, forcer periods_per_year = 252 (jours de trading)
                                                                               ^
[1m.\backtest\performance.py[m[36m:[m500[36m:[m80[36m:[m [1m[31mE501[m line too long (92 > 79 characters)
    sharpe_method: str = "daily_resample",  # "standard", "trading_days" ou "daily_resample"
                                                                               ^
[1m.\backtest\performance.py[m[36m:[m515[36m:[m80[36m:[m [1m[31mE501[m line too long (103 > 79 characters)
    """
    Calcule toutes les m√©triques de performance.

    Args:
        equity: Courbe d'√©quit√©
        returns: S√©rie de rendements (par barre)
        trades_df: DataFrame des trades
        initial_capital: Capital initial
        periods_per_year: P√©riodes par an pour annualisation du Sharpe
                         (d√©faut: 252 jours de trading, standard industrie)
        include_tier_s: Inclure m√©triques Tier S avanc√©es
        sharpe_method: M√©thode de calcul du Sharpe/Sortino:
                      - "daily_resample": Resample equity en quotidien (RECOMMAND√â, standard industrie)
                      - "trading_days": Filtre les returns nuls (incomplet, non recommand√©)
                      - "standard": Utilise tous les returns (peut donner valeurs aberrantes)

    Returns:
        Dict de toutes les m√©triques

    Notes:
        - Le Sharpe/Sortino sont calcul√©s avec periods_per_year=252 par d√©faut
          (jours de trading), ind√©pendamment du timeframe des donn√©es
        - La m√©thode "daily_resample" √©vite les biais li√©s aux equity "sparse"
          (qui ne changent qu'aux trades, cr√©ant beaucoup de returns nuls)
    """
       
                                                

         
           ^
[1m.\backtest\performance.py[m[36m:[m516[36m:[m80[36m:[m [1m[31mE501[m line too long (91 > 79 characters)
    """
    Calcule toutes les m√©triques de performance.

    Args:
        equity: Courbe d'√©quit√©
        returns: S√©rie de rendements (par barre)
        trades_df: DataFrame des trades
        initial_capital: Capital initial
        periods_per_year: P√©riodes par an pour annualisation du Sharpe
                         (d√©faut: 252 jours de trading, standard industrie)
        include_tier_s: Inclure m√©triques Tier S avanc√©es
        sharpe_method: M√©thode de calcul du Sharpe/Sortino:
                      - "daily_resample": Resample equity en quotidien (RECOMMAND√â, standard industrie)
                      - "trading_days": Filtre les returns nuls (incomplet, non recommand√©)
                      - "standard": Utilise tous les returns (peut donner valeurs aberrantes)

    Returns:
        Dict de toutes les m√©triques

    Notes:
        - Le Sharpe/Sortino sont calcul√©s avec periods_per_year=252 par d√©faut
          (jours de trading), ind√©pendamment du timeframe des donn√©es
        - La m√©thode "daily_resample" √©vite les biais li√©s aux equity "sparse"
          (qui ne changent qu'aux trades, cr√©ant beaucoup de returns nuls)
    """
       
                                                

         
           ^
[1m.\backtest\performance.py[m[36m:[m517[36m:[m80[36m:[m [1m[31mE501[m line too long (93 > 79 characters)
    """
    Calcule toutes les m√©triques de performance.

    Args:
        equity: Courbe d'√©quit√©
        returns: S√©rie de rendements (par barre)
        trades_df: DataFrame des trades
        initial_capital: Capital initial
        periods_per_year: P√©riodes par an pour annualisation du Sharpe
                         (d√©faut: 252 jours de trading, standard industrie)
        include_tier_s: Inclure m√©triques Tier S avanc√©es
        sharpe_method: M√©thode de calcul du Sharpe/Sortino:
                      - "daily_resample": Resample equity en quotidien (RECOMMAND√â, standard industrie)
                      - "trading_days": Filtre les returns nuls (incomplet, non recommand√©)
                      - "standard": Utilise tous les returns (peut donner valeurs aberrantes)

    Returns:
        Dict de toutes les m√©triques

    Notes:
        - Le Sharpe/Sortino sont calcul√©s avec periods_per_year=252 par d√©faut
          (jours de trading), ind√©pendamment du timeframe des donn√©es
        - La m√©thode "daily_resample" √©vite les biais li√©s aux equity "sparse"
          (qui ne changent qu'aux trades, cr√©ant beaucoup de returns nuls)
    """
       
                                                

         
           ^
[1m.\backtest\performance.py[m[36m:[m540[36m:[m80[36m:[m [1m[31mE501[m line too long (87 > 79 characters)
            elapsed_days = (equity.index[-1] - equity.index[0]).total_seconds() / 86400
                                                                               ^
[1m.\backtest\performance.py[m[36m:[m546[36m:[m80[36m:[m [1m[31mE501[m line too long (91 > 79 characters)
            annualized_return = ((final_equity / initial_capital) ** (1 / years) - 1) * 100
                                                                               ^
[1m.\backtest\performance.py[m[36m:[m573[36m:[m80[36m:[m [1m[31mE501[m line too long (88 > 79 characters)
    metrics["account_ruined"] = bool((equity <= 0).any()) if not equity.empty else False
                                                                               ^
[1m.\backtest\performance.py[m[36m:[m586[36m:[m80[36m:[m [1m[31mE501[m line too long (88 > 79 characters)
    if sharpe_method == "daily_resample" and isinstance(equity.index, pd.DatetimeIndex):
                                                                               ^
[1m.\backtest\performance.py[m[36m:[m613[36m:[m80[36m:[m [1m[31mE501[m line too long (97 > 79 characters)
                        # Utiliser last_in_dd_ts au lieu de ts pour mesurer la dur√©e r√©elle du DD
                                                                               ^
[1m.\backtest\performance.py[m[36m:[m640[36m:[m80[36m:[m [1m[31mE501[m line too long (93 > 79 characters)
                metrics["max_drawdown_duration_days"] = max_dd_bars / (periods_per_year or 1)
                                                                               ^
[1m.\backtest\performance.py[m[36m:[m653[36m:[m80[36m:[m [1m[31mE501[m line too long (89 > 79 characters)
        metrics["win_rate"] = len(winning_trades) / n_trades * 100 if n_trades > 0 else 0
                                                                               ^
[1m.\backtest\performance.py[m[36m:[m656[36m:[m80[36m:[m [1m[31mE501[m line too long (91 > 79 characters)
        metrics["avg_win"] = winning_trades["pnl"].mean() if len(winning_trades) > 0 else 0
                                                                               ^
[1m.\backtest\performance.py[m[36m:[m657[36m:[m80[36m:[m [1m[31mE501[m line too long (90 > 79 characters)
        metrics["avg_loss"] = losing_trades["pnl"].mean() if len(losing_trades) > 0 else 0
                                                                               ^
[1m.\backtest\performance.py[m[36m:[m658[36m:[m80[36m:[m [1m[31mE501[m line too long (94 > 79 characters)
        metrics["largest_win"] = winning_trades["pnl"].max() if len(winning_trades) > 0 else 0
                                                                               ^
[1m.\backtest\performance.py[m[36m:[m659[36m:[m80[36m:[m [1m[31mE501[m line too long (93 > 79 characters)
        metrics["largest_loss"] = losing_trades["pnl"].min() if len(losing_trades) > 0 else 0
                                                                               ^
[1m.\backtest\performance.py[m[36m:[m670[36m:[m80[36m:[m [1m[31mE501[m line too long (110 > 79 characters)
            elif entry_ts.dt.tz is not None and exit_ts.dt.tz is not None and entry_ts.dt.tz != exit_ts.dt.tz:
                                                                               ^
[1m.\backtest\performance.py[m[36m:[m676[36m:[m80[36m:[m [1m[31mE501[m line too long (96 > 79 characters)
            metrics["avg_trade_duration_hours"] = durations.mean() if not durations.empty else 0
                                                                               ^
[1m.\backtest\performance.py[m[36m:[m685[36m:[m80[36m:[m [1m[31mE501[m line too long (88 > 79 characters)
            metrics["risk_reward_ratio"] = abs(metrics["avg_win"] / metrics["avg_loss"])
                                                                               ^
[1m.\backtest\performance.py[m[36m:[m703[36m:[m80[36m:[m [1m[31mE501[m line too long (93 > 79 characters)
        metrics["calmar_ratio"] = metrics["annualized_return"] / abs(metrics["max_drawdown"])
                                                                               ^
[1m.\backtest\performance.py[m[36m:[m709[36m:[m80[36m:[m [1m[31mE501[m line too long (110 > 79 characters)
        trades_pnl = trades_df["pnl"] if not trades_df.empty and "pnl" in trades_df.columns else pd.Series([])
                                                                               ^
[1m.\backtest\performance.py[m[36m:[m737[36m:[m80[36m:[m [1m[31mE501[m line too long (87 > 79 characters)
    def __init__(self, initial_capital: float = 10000.0, include_tier_s: bool = False):
                                                                               ^
[1m.\backtest\performance.py[m[36m:[m757[36m:[m80[36m:[m [1m[31mE501[m line too long (100 > 79 characters)
        """
        Calcule un r√©sum√© complet des performances.

        Args:
            returns: S√©rie de rendements
            trades_df: DataFrame des trades
            periods_per_year: P√©riodes par an (d√©faut: 252 jours de trading)
            sharpe_method: M√©thode de calcul Sharpe ("daily_resample", "trading_days" ou "standard")

        Returns:
            Dict des m√©triques calcul√©es
        """
           
                                                   

             
^
[1m.\backtest\performance.py[m[36m:[m780[36m:[m80[36m:[m [1m[31mE501[m line too long (114 > 79 characters)
            trades_pnl = trades_df["pnl"] if not trades_df.empty and "pnl" in trades_df.columns else pd.Series([])
                                                                               ^
[1m.\backtest\performance.py[m[36m:[m791[36m:[m80[36m:[m [1m[31mE501[m line too long (85 > 79 characters)
    def format_report(self, metrics: Optional[PerformanceMetricsDict] = None) -> str:
                                                                               ^
[1m.\backtest\performance.py[m[36m:[m832[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
# - Docstring de module normalis√©e (LLM-friendly) centr√©e sur calcul des m√©triques
                                                                               ^
[1m.\backtest\simulator.py[m[36m:[m4[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
"""
Module-ID: backtest.simulator

Purpose: Simuler l'ex√©cution des trades et le calcul des courbes d'√©quit√©/rendement.

Role in pipeline: execution

Key components: Trade, simulate_trades, calculate_equity_curve, calculate_returns

Inputs: Signaux (1/-1/0), DataFrame OHLCV, param√®tres d'ex√©cution (spread, slippage, levier)

Outputs: Trade list, equity curve array, returns array

Dependencies: numpy, pandas, utils.log

Conventions: Trade.side = 'LONG'|'SHORT'; pnl en devise de base; return_pct en fractions [0,1] ou pourcentages.

Read-if: Optimisation simulation ou modification de la m√©canique des trades.

Skip-if: Vous ne touchez qu'aux strat√©gies/indicateurs.
"""
   
                             

                                            ^
[1m.\backtest\simulator.py[m[36m:[m8[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
"""
Module-ID: backtest.simulator

Purpose: Simuler l'ex√©cution des trades et le calcul des courbes d'√©quit√©/rendement.

Role in pipeline: execution

Key components: Trade, simulate_trades, calculate_equity_curve, calculate_returns

Inputs: Signaux (1/-1/0), DataFrame OHLCV, param√®tres d'ex√©cution (spread, slippage, levier)

Outputs: Trade list, equity curve array, returns array

Dependencies: numpy, pandas, utils.log

Conventions: Trade.side = 'LONG'|'SHORT'; pnl en devise de base; return_pct en fractions [0,1] ou pourcentages.

Read-if: Optimisation simulation ou modification de la m√©canique des trades.

Skip-if: Vous ne touchez qu'aux strat√©gies/indicateurs.
"""
   
                             

                                            ^
[1m.\backtest\simulator.py[m[36m:[m10[36m:[m80[36m:[m [1m[31mE501[m line too long (92 > 79 characters)
"""
Module-ID: backtest.simulator

Purpose: Simuler l'ex√©cution des trades et le calcul des courbes d'√©quit√©/rendement.

Role in pipeline: execution

Key components: Trade, simulate_trades, calculate_equity_curve, calculate_returns

Inputs: Signaux (1/-1/0), DataFrame OHLCV, param√®tres d'ex√©cution (spread, slippage, levier)

Outputs: Trade list, equity curve array, returns array

Dependencies: numpy, pandas, utils.log

Conventions: Trade.side = 'LONG'|'SHORT'; pnl en devise de base; return_pct en fractions [0,1] ou pourcentages.

Read-if: Optimisation simulation ou modification de la m√©canique des trades.

Skip-if: Vous ne touchez qu'aux strat√©gies/indicateurs.
"""
   
                             

                                            ^
[1m.\backtest\simulator.py[m[36m:[m16[36m:[m80[36m:[m [1m[31mE501[m line too long (111 > 79 characters)
"""
Module-ID: backtest.simulator

Purpose: Simuler l'ex√©cution des trades et le calcul des courbes d'√©quit√©/rendement.

Role in pipeline: execution

Key components: Trade, simulate_trades, calculate_equity_curve, calculate_returns

Inputs: Signaux (1/-1/0), DataFrame OHLCV, param√®tres d'ex√©cution (spread, slippage, levier)

Outputs: Trade list, equity curve array, returns array

Dependencies: numpy, pandas, utils.log

Conventions: Trade.side = 'LONG'|'SHORT'; pnl en devise de base; return_pct en fractions [0,1] ou pourcentages.

Read-if: Optimisation simulation ou modification de la m√©canique des trades.

Skip-if: Vous ne touchez qu'aux strat√©gies/indicateurs.
"""
   
                             

                                            ^
[1m.\backtest\simulator.py[m[36m:[m103[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
    """
    Simule l'ex√©cution des trades bas√©e sur les signaux.

    Features:
    - Gestion des positions (une seule √† la fois)
    - Stop-loss configurable
    - Calcul des frais et slippage (fixe ou dynamique)
    - Ex√©cution r√©aliste optionnelle (spread/slippage dynamique)
    - Sortie en fin de donn√©es si position ouverte

    Args:
        df: DataFrame OHLCV avec index datetime
        signals: S√©rie de signaux (+1, -1, 0)
        params: Param√®tres de trading:
            - leverage: Levier (d√©faut: 3)
            - k_sl: Multiplicateur stop-loss % (d√©faut: 1.5)
            - initial_capital: Capital initial (d√©faut: 10000)
            - fees_bps: Frais en bps (d√©faut: 10)
            - slippage_bps: Slippage en bps (d√©faut: 5)
            - execution_model: Mod√®le d'ex√©cution ('fixed', 'dynamic', 'realistic')
        execution_engine: ExecutionEngine optionnel pour ex√©cution r√©aliste
        show_progress: Afficher une barre de progression (d√©faut: False)

    Returns:
        DataFrame des trades avec colonnes:
        entry_ts, exit_ts, pnl, size, price_entry, price_exit, side, exit_reason, etc.
    """
       
                                                        

             ^
[1m.\backtest\simulator.py[m[36m:[m109[36m:[m80[36m:[m [1m[31mE501[m line too long (86 > 79 characters)
    """
    Simule l'ex√©cution des trades bas√©e sur les signaux.

    Features:
    - Gestion des positions (une seule √† la fois)
    - Stop-loss configurable
    - Calcul des frais et slippage (fixe ou dynamique)
    - Ex√©cution r√©aliste optionnelle (spread/slippage dynamique)
    - Sortie en fin de donn√©es si position ouverte

    Args:
        df: DataFrame OHLCV avec index datetime
        signals: S√©rie de signaux (+1, -1, 0)
        params: Param√®tres de trading:
            - leverage: Levier (d√©faut: 3)
            - k_sl: Multiplicateur stop-loss % (d√©faut: 1.5)
            - initial_capital: Capital initial (d√©faut: 10000)
            - fees_bps: Frais en bps (d√©faut: 10)
            - slippage_bps: Slippage en bps (d√©faut: 5)
            - execution_model: Mod√®le d'ex√©cution ('fixed', 'dynamic', 'realistic')
        execution_engine: ExecutionEngine optionnel pour ex√©cution r√©aliste
        show_progress: Afficher une barre de progression (d√©faut: False)

    Returns:
        DataFrame des trades avec colonnes:
        entry_ts, exit_ts, pnl, size, price_entry, price_exit, side, exit_reason, etc.
    """
       
                                                        

             ^
[1m.\backtest\simulator.py[m[36m:[m176[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
                filled_size = getattr(exec_result, "filled_size", requested_size)
                                                                               ^
[1m.\backtest\simulator.py[m[36m:[m192[36m:[m80[36m:[m [1m[31mE501[m line too long (94 > 79 characters)
            logger.debug(f"Entr√©e {'LONG' if position == 1 else 'SHORT'} @ {entry_price:.2f}")
                                                                               ^
[1m.\backtest\simulator.py[m[36m:[m232[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
                    filled_size = getattr(exec_result, "filled_size", position_size)
                                                                               ^
[1m.\backtest\simulator.py[m[36m:[m283[36m:[m80[36m:[m [1m[31mE501[m line too long (88 > 79 characters)
                logger.debug(f"Sortie {trade.side} @ {exit_price:.2f}, PnL: ${pnl:.2f}")
                                                                               ^
[1m.\backtest\simulator.py[m[36m:[m296[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
                        requested_size = leverage * initial_capital / close_price
                                                                               ^
[1m.\backtest\simulator.py[m[36m:[m305[36m:[m80[36m:[m [1m[31mE501[m line too long (93 > 79 characters)
                            filled_size = getattr(exec_result, "filled_size", requested_size)
                                                                               ^
[1m.\backtest\simulator.py[m[36m:[m313[36m:[m80[36m:[m [1m[31mE501[m line too long (94 > 79 characters)
                            entry_price = close_price * (1 + slippage_bps * 0.0001 * position)
                                                                               ^
[1m.\backtest\simulator.py[m[36m:[m314[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
                            position_size = leverage * initial_capital / entry_price
                                                                               ^
[1m.\backtest\simulator.py[m[36m:[m406[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
            f"n_points={len(df)} initial_capital={initial_capital} currency=USD"
                                                                               ^
[1m.\backtest\simulator.py[m[36m:[m476[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
                    f"EQUITY_JUMPS run_id={run_id} n_jumps={len(abnormal_jumps)} "
                                                                               ^
[1m.\backtest\simulator.py[m[36m:[m506[36m:[m80[36m:[m [1m[31mE501[m line too long (93 > 79 characters)
                    f"equity_final={equity_final:.2f} equity_expected={equity_expected:.2f} "
                                                                               ^
[1m.\backtest\simulator.py[m[36m:[m515[36m:[m80[36m:[m [1m[31mE501[m line too long (86 > 79 characters)
            f"final={equity.iloc[-1]:.2f} pnl={equity.iloc[-1] - initial_capital:.2f}"
                                                                               ^
[1m.\backtest\simulator.py[m[36m:[m529[36m:[m80[36m:[m [1m[31mE501[m line too long (85 > 79 characters)
__all__ = ["simulate_trades", "Trade", "calculate_equity_curve", "calculate_returns"]
                                                                               ^
[1m.\backtest\simulator.py[m[36m:[m533[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
# - Docstring de module normalis√©e (LLM-friendly) centr√©e sur l'ex√©cution/simulation
                                                                               ^
[1m.\backtest\simulator_fast.py[m[36m:[m4[36m:[m80[36m:[m [1m[31mE501[m line too long (102 > 79 characters)
"""
Module-ID: backtest.simulator_fast

Purpose: Version haute performance de simulate_trades via Numba JIT (100x acc√©l√©ration vs Python pur).

Role in pipeline: execution / performance

Key components: _simulate_trades_numba, simulate_trades_fast, calculate_equity_fast, HAS_NUMBA flag

Inputs: OHLCV arrays (closes, highs, lows), signaux, param√®tres (leverage, slippage, fees)

Outputs: Trades arrays (entry_ts, exit_ts, pnl, etc.), equity curve, returns

Dependencies: numpy, pandas, optionnel: numba (JIT); fallback simulator.py si numba absent

Conventions: HAS_NUMBA = False si numba non dispo (fallback Python OK); donn√©es arrays numpy; signaux 1/-1/0.

Read-if: Optimisation simulation ou fallback √† simulator_fast.

Skip-if: simulator.py Python pur performant suffisamment.
"""
   
                                  

                                       ^
[1m.\backtest\simulator_fast.py[m[36m:[m8[36m:[m80[36m:[m [1m[31mE501[m line too long (99 > 79 characters)
"""
Module-ID: backtest.simulator_fast

Purpose: Version haute performance de simulate_trades via Numba JIT (100x acc√©l√©ration vs Python pur).

Role in pipeline: execution / performance

Key components: _simulate_trades_numba, simulate_trades_fast, calculate_equity_fast, HAS_NUMBA flag

Inputs: OHLCV arrays (closes, highs, lows), signaux, param√®tres (leverage, slippage, fees)

Outputs: Trades arrays (entry_ts, exit_ts, pnl, etc.), equity curve, returns

Dependencies: numpy, pandas, optionnel: numba (JIT); fallback simulator.py si numba absent

Conventions: HAS_NUMBA = False si numba non dispo (fallback Python OK); donn√©es arrays numpy; signaux 1/-1/0.

Read-if: Optimisation simulation ou fallback √† simulator_fast.

Skip-if: simulator.py Python pur performant suffisamment.
"""
   
                                  

                                       ^
[1m.\backtest\simulator_fast.py[m[36m:[m10[36m:[m80[36m:[m [1m[31mE501[m line too long (90 > 79 characters)
"""
Module-ID: backtest.simulator_fast

Purpose: Version haute performance de simulate_trades via Numba JIT (100x acc√©l√©ration vs Python pur).

Role in pipeline: execution / performance

Key components: _simulate_trades_numba, simulate_trades_fast, calculate_equity_fast, HAS_NUMBA flag

Inputs: OHLCV arrays (closes, highs, lows), signaux, param√®tres (leverage, slippage, fees)

Outputs: Trades arrays (entry_ts, exit_ts, pnl, etc.), equity curve, returns

Dependencies: numpy, pandas, optionnel: numba (JIT); fallback simulator.py si numba absent

Conventions: HAS_NUMBA = False si numba non dispo (fallback Python OK); donn√©es arrays numpy; signaux 1/-1/0.

Read-if: Optimisation simulation ou fallback √† simulator_fast.

Skip-if: simulator.py Python pur performant suffisamment.
"""
   
                                  

                                       ^
[1m.\backtest\simulator_fast.py[m[36m:[m14[36m:[m80[36m:[m [1m[31mE501[m line too long (90 > 79 characters)
"""
Module-ID: backtest.simulator_fast

Purpose: Version haute performance de simulate_trades via Numba JIT (100x acc√©l√©ration vs Python pur).

Role in pipeline: execution / performance

Key components: _simulate_trades_numba, simulate_trades_fast, calculate_equity_fast, HAS_NUMBA flag

Inputs: OHLCV arrays (closes, highs, lows), signaux, param√®tres (leverage, slippage, fees)

Outputs: Trades arrays (entry_ts, exit_ts, pnl, etc.), equity curve, returns

Dependencies: numpy, pandas, optionnel: numba (JIT); fallback simulator.py si numba absent

Conventions: HAS_NUMBA = False si numba non dispo (fallback Python OK); donn√©es arrays numpy; signaux 1/-1/0.

Read-if: Optimisation simulation ou fallback √† simulator_fast.

Skip-if: simulator.py Python pur performant suffisamment.
"""
   
                                  

                                       ^
[1m.\backtest\simulator_fast.py[m[36m:[m16[36m:[m80[36m:[m [1m[31mE501[m line too long (109 > 79 characters)
"""
Module-ID: backtest.simulator_fast

Purpose: Version haute performance de simulate_trades via Numba JIT (100x acc√©l√©ration vs Python pur).

Role in pipeline: execution / performance

Key components: _simulate_trades_numba, simulate_trades_fast, calculate_equity_fast, HAS_NUMBA flag

Inputs: OHLCV arrays (closes, highs, lows), signaux, param√®tres (leverage, slippage, fees)

Outputs: Trades arrays (entry_ts, exit_ts, pnl, etc.), equity curve, returns

Dependencies: numpy, pandas, optionnel: numba (JIT); fallback simulator.py si numba absent

Conventions: HAS_NUMBA = False si numba non dispo (fallback Python OK); donn√©es arrays numpy; signaux 1/-1/0.

Read-if: Optimisation simulation ou fallback √† simulator_fast.

Skip-if: simulator.py Python pur performant suffisamment.
"""
   
                                  

                                       ^
[1m.\backtest\simulator_fast.py[m[36m:[m74[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
        exit_reasons = np.zeros(max_trades, dtype=np.int64)  # 0=signal, 1=sl, 2=end
                                                                               ^
[1m.\backtest\simulator_fast.py[m[36m:[m122[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
                    exit_price = close_price * (1.0 - slippage_factor * position)
                                                                               ^
[1m.\backtest\simulator_fast.py[m[36m:[m153[36m:[m80[36m:[m [1m[31mE501[m line too long (86 > 79 characters)
                        entry_price = close_price * (1.0 + slippage_factor * position)
                                                                               ^
[1m.\backtest\simulator_fast.py[m[36m:[m308[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
                    entry_price = close_price * (1.0 + slippage_factor * position)
                                                                               ^
[1m.\backtest\simulator_fast.py[m[36m:[m424[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
        "exit_reason": [EXIT_REASON_MAP.get(r, "unknown") for r in exit_reasons],
                                                                               ^
[1m.\backtest\simulator_fast.py[m[36m:[m462[36m:[m80[36m:[m [1m[31mE501[m line too long (94 > 79 characters)
    exit_indices = np.array([ts_to_idx.get(ts, n_bars - 1) for ts in exit_ts], dtype=np.int64)
                                                                               ^
[1m.\backtest\simulator_fast.py[m[36m:[m465[36m:[m80[36m:[m [1m[31mE501[m line too long (89 > 79 characters)
        equity_arr = _calculate_equity_numba(n_bars, exit_indices, pnls, initial_capital)
                                                                               ^
[1m.\backtest\simulator_fast.py[m[36m:[m516[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
        trades = simulate_trades_fast(df, signals_batch[idx], params_batch[idx])
                                                                               ^
[1m.\backtest\simulator_fast.py[m[36m:[m520[36m:[m80[36m:[m [1m[31mE501[m line too long (85 > 79 characters)
        futures = [executor.submit(run_single, i) for i in range(len(signals_batch))]
                                                                               ^
[1m.\backtest\simulator_fast.py[m[36m:[m529[36m:[m80[36m:[m [1m[31mE501[m line too long (95 > 79 characters)
# - Docstring de module normalis√©e (LLM-friendly) centr√©e sur simulation haute perf (Numba JIT)
                                                                               ^
[1m.\backtest\storage.py[m[36m:[m4[36m:[m80[36m:[m [1m[31mE501[m line too long (92 > 79 characters)
"""
Module-ID: backtest.storage

Purpose: Persister et indexer les r√©sultats de backtests pour rechargement/recherche rapide.

Role in pipeline: persistence / reporting

Key components: ResultStorage, StoredResultMetadata, get_storage

Inputs: RunResult, run_id, auto_cleanup flag

Outputs: Fichiers JSON/Parquet dans backtest_results/{run_id}/, index.json

Dependencies: pandas, pathlib, json, optionnel: pyarrow (Parquet)

Conventions: Structure run_id/metadata.json + equity.parquet + trades.parquet; index.json catalogue; auto_cleanup garde N derniers runs.

Read-if: Persistance r√©sultats, recherche historique, ou gestion stockage.

Skip-if: Backtests ponctuels sans sauvegarde.
"""
   
                           

                                              ^
[1m.\backtest\storage.py[m[36m:[m16[36m:[m80[36m:[m [1m[31mE501[m line too long (136 > 79 characters)
"""
Module-ID: backtest.storage

Purpose: Persister et indexer les r√©sultats de backtests pour rechargement/recherche rapide.

Role in pipeline: persistence / reporting

Key components: ResultStorage, StoredResultMetadata, get_storage

Inputs: RunResult, run_id, auto_cleanup flag

Outputs: Fichiers JSON/Parquet dans backtest_results/{run_id}/, index.json

Dependencies: pandas, pathlib, json, optionnel: pyarrow (Parquet)

Conventions: Structure run_id/metadata.json + equity.parquet + trades.parquet; index.json catalogue; auto_cleanup garde N derniers runs.

Read-if: Persistance r√©sultats, recherche historique, ou gestion stockage.

Skip-if: Backtests ponctuels sans sauvegarde.
"""
   
                           

                                              ^
[1m.\backtest\storage.py[m[36m:[m140[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
        self.storage_dir = Path(storage_dir) if storage_dir else DEFAULT_STORAGE_DIR
                                                                               ^
[1m.\backtest\storage.py[m[36m:[m153[36m:[m80[36m:[m [1m[31mE501[m line too long (99 > 79 characters)
        logger.info(f"ResultStorage initialis√©: {self.storage_dir} ({len(self._index)} r√©sultats)")
                                                                               ^
[1m.\backtest\storage.py[m[36m:[m178[36m:[m80[36m:[m [1m[31mE501[m line too long (97 > 79 characters)
            run_id = result.meta.get("run_id", f"run_{datetime.now().strftime('%Y%m%d_%H%M%S')}")
                                                                               ^
[1m.\backtest\storage.py[m[36m:[m236[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
            logger.info(f"‚úÖ R√©sultat sauvegard√©: {run_id} ({metadata.strategy})")
                                                                               ^
[1m.\backtest\storage.py[m[36m:[m281[36m:[m80[36m:[m [1m[31mE501[m line too long (85 > 79 characters)
                "best_metrics": normalize_metrics(sweep_results.best_metrics, "pct"),
                                                                               ^
[1m.\backtest\storage.py[m[36m:[m298[36m:[m80[36m:[m [1m[31mE501[m line too long (98 > 79 characters)
            logger.info(f"‚úÖ Sweep sauvegard√©: {sweep_id} ({sweep_results.n_completed} r√©sultats)")
                                                                               ^
[1m.\backtest\storage.py[m[36m:[m416[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
            logger.error(f"‚ùå Erreur lors du chargement du sweep {sweep_id}: {e}")
                                                                               ^
[1m.\backtest\storage.py[m[36m:[m580[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
    def _cleanup_old_results(self, keep_last: int = MAX_RESULTS_TO_KEEP) -> int:
                                                                               ^
[1m.\backtest\storage.py[m[36m:[m601[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
            logger.info(f"üßπ Nettoyage: {deleted_count} anciens r√©sultats supprim√©s")
                                                                               ^
[1m.\backtest\storage.py[m[36m:[m646[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
                    logger.warning(f"‚ö†Ô∏è M√©tadonn√©e corrompue pour {run_id}: {e}")
                                                                               ^
[1m.\backtest\storage.py[m[36m:[m672[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
        """
        Reconstruit l'index en scannant tous les r√©pertoires.

        Utile en cas de corruption ou si des fichiers ont √©t√© ajout√©s manuellement.

        Returns:
            Nombre de r√©sultats index√©s
        """
           
                                                             

    ^
[1m.\backtest\storage.py[m[36m:[m748[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
# - Docstring de module normalis√©e (LLM-friendly) centr√©e sur persistance/indexation
                                                                               ^
[1m.\backtest\sweep.py[m[36m:[m4[36m:[m80[36m:[m [1m[31mE501[m line too long (112 > 79 characters)
"""
Module-ID: backtest.sweep

Purpose: Optimiser les param√®tres via grid search parall√©lis√© avec suivi temps r√©el et filtrage par contraintes.

Role in pipeline: optimization

Key components: SweepEngine, SweepResult, SweepResultItem, run_sweep

Inputs: param_grid (Dict ou liste), strat√©gie, DataFrame OHLCV, max_workers, constraints optionnelles

Outputs: SweepResult (best_result, all_results, stats, timing)

Dependencies: backtest.engine, performance.parallel, performance.monitor, utils.parameters

Conventions: Combinaisons g√©n√©r√©es via product(); contraintes appliqu√©es; r√©sultats tri√©s par m√©trique cible; nb combinaisons plafonn√©.

Read-if: Param√©tragedu sweep, parallelisation, monitoring ou ajout de contraintes.

Skip-if: Vous utilisez optuna/pareto au lieu de sweep classique.
"""
   
                         

                                                ^
[1m.\backtest\sweep.py[m[36m:[m10[36m:[m80[36m:[m [1m[31mE501[m line too long (101 > 79 characters)
"""
Module-ID: backtest.sweep

Purpose: Optimiser les param√®tres via grid search parall√©lis√© avec suivi temps r√©el et filtrage par contraintes.

Role in pipeline: optimization

Key components: SweepEngine, SweepResult, SweepResultItem, run_sweep

Inputs: param_grid (Dict ou liste), strat√©gie, DataFrame OHLCV, max_workers, constraints optionnelles

Outputs: SweepResult (best_result, all_results, stats, timing)

Dependencies: backtest.engine, performance.parallel, performance.monitor, utils.parameters

Conventions: Combinaisons g√©n√©r√©es via product(); contraintes appliqu√©es; r√©sultats tri√©s par m√©trique cible; nb combinaisons plafonn√©.

Read-if: Param√©tragedu sweep, parallelisation, monitoring ou ajout de contraintes.

Skip-if: Vous utilisez optuna/pareto au lieu de sweep classique.
"""
   
                         

                                                ^
[1m.\backtest\sweep.py[m[36m:[m14[36m:[m80[36m:[m [1m[31mE501[m line too long (90 > 79 characters)
"""
Module-ID: backtest.sweep

Purpose: Optimiser les param√®tres via grid search parall√©lis√© avec suivi temps r√©el et filtrage par contraintes.

Role in pipeline: optimization

Key components: SweepEngine, SweepResult, SweepResultItem, run_sweep

Inputs: param_grid (Dict ou liste), strat√©gie, DataFrame OHLCV, max_workers, constraints optionnelles

Outputs: SweepResult (best_result, all_results, stats, timing)

Dependencies: backtest.engine, performance.parallel, performance.monitor, utils.parameters

Conventions: Combinaisons g√©n√©r√©es via product(); contraintes appliqu√©es; r√©sultats tri√©s par m√©trique cible; nb combinaisons plafonn√©.

Read-if: Param√©tragedu sweep, parallelisation, monitoring ou ajout de contraintes.

Skip-if: Vous utilisez optuna/pareto au lieu de sweep classique.
"""
   
                         

                                                ^
[1m.\backtest\sweep.py[m[36m:[m16[36m:[m80[36m:[m [1m[31mE501[m line too long (135 > 79 characters)
"""
Module-ID: backtest.sweep

Purpose: Optimiser les param√®tres via grid search parall√©lis√© avec suivi temps r√©el et filtrage par contraintes.

Role in pipeline: optimization

Key components: SweepEngine, SweepResult, SweepResultItem, run_sweep

Inputs: param_grid (Dict ou liste), strat√©gie, DataFrame OHLCV, max_workers, constraints optionnelles

Outputs: SweepResult (best_result, all_results, stats, timing)

Dependencies: backtest.engine, performance.parallel, performance.monitor, utils.parameters

Conventions: Combinaisons g√©n√©r√©es via product(); contraintes appliqu√©es; r√©sultats tri√©s par m√©trique cible; nb combinaisons plafonn√©.

Read-if: Param√©tragedu sweep, parallelisation, monitoring ou ajout de contraintes.

Skip-if: Vous utilisez optuna/pareto au lieu de sweep classique.
"""
   
                         

                                                ^
[1m.\backtest\sweep.py[m[36m:[m18[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
"""
Module-ID: backtest.sweep

Purpose: Optimiser les param√®tres via grid search parall√©lis√© avec suivi temps r√©el et filtrage par contraintes.

Role in pipeline: optimization

Key components: SweepEngine, SweepResult, SweepResultItem, run_sweep

Inputs: param_grid (Dict ou liste), strat√©gie, DataFrame OHLCV, max_workers, constraints optionnelles

Outputs: SweepResult (best_result, all_results, stats, timing)

Dependencies: backtest.engine, performance.parallel, performance.monitor, utils.parameters

Conventions: Combinaisons g√©n√©r√©es via product(); contraintes appliqu√©es; r√©sultats tri√©s par m√©trique cible; nb combinaisons plafonn√©.

Read-if: Param√©tragedu sweep, parallelisation, monitoring ou ajout de contraintes.

Skip-if: Vous utilisez optuna/pareto au lieu de sweep classique.
"""
   
                         

                                                ^
[1m.\backtest\sweep.py[m[36m:[m92[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
    def get_top_n(self, n: int = 10, metric: str = "sharpe_ratio") -> pd.DataFrame:
                                                                               ^
[1m.\backtest\sweep.py[m[36m:[m106[36m:[m80[36m:[m [1m[31mE501[m line too long (89 > 79 characters)
        sharpe_str = f"{sharpe:.2f}" if isinstance(sharpe, (int, float)) else str(sharpe)
                                                                               ^
[1m.\backtest\sweep.py[m[36m:[m107[36m:[m80[36m:[m [1m[31mE501[m line too long (97 > 79 characters)
        pnl_str = f"${total_pnl:,.2f}" if isinstance(total_pnl, (int, float)) else str(total_pnl)
                                                                               ^
[1m.\backtest\sweep.py[m[36m:[m108[36m:[m80[36m:[m [1m[31mE501[m line too long (92 > 79 characters)
        wr_str = f"{win_rate:.1f}%" if isinstance(win_rate, (int, float)) else str(win_rate)
                                                                               ^
[1m.\backtest\sweep.py[m[36m:[m264[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
            stats = compute_search_space_stats(param_grid, max_combinations=100000)
                                                                               ^
[1m.\backtest\sweep.py[m[36m:[m310[36m:[m80[36m:[m [1m[31mE501[m line too long (92 > 79 characters)
                """Callback appel√© par ParallelRunner pour mettre √† jour la progress bar."""
                                                                               ^
[1m.\backtest\sweep.py[m[36m:[m319[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
                # Fixed kwargs pass√©s √† chaque appel de _run_single_backtest_wrapper
                                                                               ^
[1m.\backtest\sweep.py[m[36m:[m332[36m:[m80[36m:[m [1m[31mE501[m line too long (87 > 79 characters)
                    logger.warning("üõë Arr√™t d'urgence d√©tect√© - Interruption du sweep")
                                                                               ^
[1m.\backtest\sweep.py[m[36m:[m369[36m:[m80[36m:[m [1m[31mE501[m line too long (89 > 79 characters)
                            if (not minimize and best_value >= early_stop_threshold) or \
                               (minimize and best_value <= early_stop_threshold):
                                                                               ^
[1m.\backtest\sweep.py[m[36m:[m370[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
                            if (not minimize and best_value >= early_stop_threshold) or \
                               (minimize and best_value <= early_stop_threshold):
                                                                               ^
[1m.\backtest\sweep.py[m[36m:[m371[36m:[m80[36m:[m [1m[31mE501[m line too long (91 > 79 characters)
                                logger.info(f"Early stop: {optimize_for}={best_value:.4f}")
                                                                               ^
[1m.\backtest\sweep.py[m[36m:[m372[36m:[m80[36m:[m [1m[31mE501[m line too long (99 > 79 characters)
                                # Note: avec ParallelRunner, les t√¢ches restantes sont d√©j√† lanc√©es
                                                                               ^
[1m.\backtest\sweep.py[m[36m:[m389[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
        logger.info(f"Sweep termin√©: {n_completed}/{n_combos} en {total_time:.1f}s")
                                                                               ^
[1m.\backtest\sweep.py[m[36m:[m449[36m:[m80[36m:[m [1m[31mE501[m line too long (110 > 79 characters)
        logger.info(f"D√©marrage sweep parall√®le: {n_combos} combinaisons, {self._runner.max_workers} workers")
                                                                               ^
[1m.\backtest\sweep.py[m[36m:[m471[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
                metrics = _normalize_metrics_pct(item["result"].get("metrics", {}))
                                                                               ^
[1m.\backtest\sweep.py[m[36m:[m543[36m:[m80[36m:[m [1m[31mE501[m line too long (85 > 79 characters)
            raise ValueError(f"Strat√©gie inconnue: {name}. Disponibles: {available}")
                                                                               ^
[1m.\backtest\sweep.py[m[36m:[m588[36m:[m80[36m:[m [1m[31mE501[m line too long (85 > 79 characters)
# - Docstring de module normalis√©e (LLM-friendly) centr√©e sur grid search parall√©lis√©
                                                                               ^
[1m.\backtest\validation.py[m[36m:[m4[36m:[m80[36m:[m [1m[31mE501[m line too long (103 > 79 characters)
"""
Module-ID: backtest.validation

Purpose: Valider l'absence d'overfitting via walk-forward analysis avec fen√™tres glissantes train/test.

Role in pipeline: validation

Key components: ValidationFold, WalkForwardValidator, validate_combinatorial

Inputs: DataFrame OHLCV, n_folds (d√©faut 5), train_ratio (d√©faut 0.7)

Outputs: ValidationFold list, overfitting_ratio estim√©, m√©triques train vs test

Dependencies: numpy, pandas, utils.log

Conventions: Embargo temporel respect√©; fold_id 0-based; overfitting_ratio > 1.0 signale overfitting; fen√™tres non-chevauchantes.

Read-if: Int√©gration validation au pipeline, d√©tection overfitting, ou param√®tres de folds.

Skip-if: Vous n'utilisez pas la validation walk-forward.
"""
   
                              

                                           ^
[1m.\backtest\validation.py[m[36m:[m16[36m:[m80[36m:[m [1m[31mE501[m line too long (129 > 79 characters)
"""
Module-ID: backtest.validation

Purpose: Valider l'absence d'overfitting via walk-forward analysis avec fen√™tres glissantes train/test.

Role in pipeline: validation

Key components: ValidationFold, WalkForwardValidator, validate_combinatorial

Inputs: DataFrame OHLCV, n_folds (d√©faut 5), train_ratio (d√©faut 0.7)

Outputs: ValidationFold list, overfitting_ratio estim√©, m√©triques train vs test

Dependencies: numpy, pandas, utils.log

Conventions: Embargo temporel respect√©; fold_id 0-based; overfitting_ratio > 1.0 signale overfitting; fen√™tres non-chevauchantes.

Read-if: Int√©gration validation au pipeline, d√©tection overfitting, ou param√®tres de folds.

Skip-if: Vous n'utilisez pas la validation walk-forward.
"""
   
                              

                                           ^
[1m.\backtest\validation.py[m[36m:[m18[36m:[m80[36m:[m [1m[31mE501[m line too long (91 > 79 characters)
"""
Module-ID: backtest.validation

Purpose: Valider l'absence d'overfitting via walk-forward analysis avec fen√™tres glissantes train/test.

Role in pipeline: validation

Key components: ValidationFold, WalkForwardValidator, validate_combinatorial

Inputs: DataFrame OHLCV, n_folds (d√©faut 5), train_ratio (d√©faut 0.7)

Outputs: ValidationFold list, overfitting_ratio estim√©, m√©triques train vs test

Dependencies: numpy, pandas, utils.log

Conventions: Embargo temporel respect√©; fold_id 0-based; overfitting_ratio > 1.0 signale overfitting; fen√™tres non-chevauchantes.

Read-if: Int√©gration validation au pipeline, d√©tection overfitting, ou param√®tres de folds.

Skip-if: Vous n'utilisez pas la validation walk-forward.
"""
   
                              

                                           ^
[1m.\backtest\validation.py[m[36m:[m168[36m:[m80[36m:[m [1m[31mE501[m line too long (95 > 79 characters)
        """
        Args:
            n_folds: Nombre de fen√™tres de validation
            test_pct: Pourcentage de donn√©es pour le test (par fold)
            embargo_pct: Embargo entre train et test (% du total)
            purge_pct: Purge avant le test (donn√©es exclues)
            min_train_samples: Minimum de samples pour le train
            min_test_samples: Minimum de samples pour le test (√©vite les indicateurs invalides)
            expanding: Si True, fen√™tre d'entra√Ænement qui grandit
        """
           
             
                                                     ^
[1m.\backtest\validation.py[m[36m:[m226[36m:[m80[36m:[m [1m[31mE501[m line too long (122 > 79 characters)
                logger.warning(f"Fold {i}: train trop petit ({train_end - train_start} < {self.min_train_samples}), skip")
                                                                               ^
[1m.\backtest\validation.py[m[36m:[m230[36m:[m80[36m:[m [1m[31mE501[m line too long (118 > 79 characters)
                logger.warning(f"Fold {i}: test trop petit ({test_end - test_start} < {self.min_test_samples}), skip")
                                                                               ^
[1m.\backtest\validation.py[m[36m:[m313[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
                f"Ratio overfitting trop √©lev√©: {result.avg_overfitting_ratio:.2f} "
                                                                               ^
[1m.\backtest\validation.py[m[36m:[m328[36m:[m80[36m:[m [1m[31mE501[m line too long (104 > 79 characters)
                f"Performance instable: std={result.sharpe_std:.2f} > mean={result.avg_test_sharpe:.2f}"
                                                                               ^
[1m.\backtest\validation.py[m[36m:[m362[36m:[m80[36m:[m [1m[31mE501[m line too long (88 > 79 characters)
def compute_robust_overfitting_metrics(folds: List[ValidationFold]) -> Dict[str, float]:
                                                                               ^
[1m.\backtest\validation.py[m[36m:[m390[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
    train_sharpes = [f.train_metrics.get("sharpe_ratio", 0) for f in valid_folds]
                                                                               ^
[1m.\backtest\validation.py[m[36m:[m420[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
        "degradation_pct": max(0, degradation_pct),  # Pas de d√©gradation n√©gative
                                                                               ^
[1m.\backtest\validation.py[m[36m:[m426[36m:[m80[36m:[m [1m[31mE501[m line too long (85 > 79 characters)
def calculate_walk_forward_metrics(folds: List[ValidationFold]) -> WalkForwardResult:
                                                                               ^
[1m.\backtest\validation.py[m[36m:[m447[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
    train_sharpes = [f.train_metrics.get("sharpe_ratio", 0) for f in valid_folds]
                                                                               ^
[1m.\backtest\validation.py[m[36m:[m449[36m:[m80[36m:[m [1m[31mE501[m line too long (85 > 79 characters)
    train_returns = [f.train_metrics.get("total_return_pct", 0) for f in valid_folds]
                                                                               ^
[1m.\backtest\validation.py[m[36m:[m450[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
    test_returns = [f.test_metrics.get("total_return_pct", 0) for f in valid_folds]
                                                                               ^
[1m.\backtest\validation.py[m[36m:[m451[36m:[m80[36m:[m [1m[31mE501[m line too long (90 > 79 characters)
    overfitting_ratios = [f.overfitting_ratio for f in valid_folds if f.overfitting_ratio]
                                                                               ^
[1m.\backtest\validation.py[m[36m:[m458[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
    avg_overfitting = np.mean(overfitting_ratios) if overfitting_ratios else 1.0
                                                                               ^
[1m.\backtest\validation.py[m[36m:[m498[36m:[m80[36m:[m [1m[31mE501[m line too long (88 > 79 characters)
    embargo = valid_folds[0].test_start - valid_folds[0].train_end if valid_folds else 0
                                                                               ^
[1m.\backtest\validation.py[m[36m:[m571[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
    report = f"""
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë            VALIDATION WALK-FORWARD                        ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë VERDICT: {verdict_emoji} {"ROBUST" if result.is_robust else "OVERFITTING D√âTECT√â"}
‚ïë Confiance: {result.confidence_score:.1%}
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë CONFIGURATION                                             ‚ïë
‚ïë   Nombre de folds:     {len(result.folds):>10d}                      ‚ïë
‚ïë   Samples train:       {result.total_train_samples:>10d}                      ‚ïë
‚ïë   Samples test:        {result.total_test_samples:>10d}                      ‚ïë
‚ïë   Embargo:             {result.embargo_samples:>10d}                      ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë PERFORMANCES MOYENNES                                     ‚ïë
‚ïë   Sharpe Train:        {result.avg_train_sharpe:>10.3f}                      ‚ïë
‚ïë   Sharpe Test:         {result.avg_test_sharpe:>10.3f}                      ‚ïë
‚ïë   Return Train:        {result.avg_train_return:>10.2f}%                     ‚ïë
‚ïë   Return Test:         {result.avg_test_return:>10.2f}%                     ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë STABILIT√â & OVERFITTING                                   ‚ïë
‚ïë   Ratio Classique:     {result.avg_overfitting_ratio:>10.2f}x                     ‚ïë
‚ïë   Ratio Robuste:       {result.robust_overfitting_ratio:>10.2f}x (avec p√©nalit√©) ‚ïë
‚ïë   D√©gradation:         {result.degradation_pct:>10.1f}%                     ‚ïë
‚ïë   Std Test (stabilit√©):{result.test_stability_std:>10.3f}                      ‚ïë
‚ïë   Folds valides:       {result.n_valid_folds:>10d}                      ‚ïë
‚ïë   Std Sharpe:          {result.sharpe_std:>10.3f}                      ‚ïë
‚ïë   Std Return:          {result.return_std:>10.2f}%                     ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë CRIT√àRES RECOMMAND√âS                                      ‚ïë
‚ïë   ‚úì Ratio robuste < 1.8                                  ‚ïë
‚ïë   ‚úì D√©gradation < 40%                                    ‚ïë
‚ïë   ‚úì Std stabilit√© < 0.5                                  ‚ïë
‚ïë   ‚úì Folds valides >= 4                                   ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
"""
                 
                                                            
^
[1m.\backtest\validation.py[m[36m:[m576[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
    report = f"""
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë            VALIDATION WALK-FORWARD                        ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë VERDICT: {verdict_emoji} {"ROBUST" if result.is_robust else "OVERFITTING D√âTECT√â"}
‚ïë Confiance: {result.confidence_score:.1%}
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë CONFIGURATION                                             ‚ïë
‚ïë   Nombre de folds:     {len(result.folds):>10d}                      ‚ïë
‚ïë   Samples train:       {result.total_train_samples:>10d}                      ‚ïë
‚ïë   Samples test:        {result.total_test_samples:>10d}                      ‚ïë
‚ïë   Embargo:             {result.embargo_samples:>10d}                      ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë PERFORMANCES MOYENNES                                     ‚ïë
‚ïë   Sharpe Train:        {result.avg_train_sharpe:>10.3f}                      ‚ïë
‚ïë   Sharpe Test:         {result.avg_test_sharpe:>10.3f}                      ‚ïë
‚ïë   Return Train:        {result.avg_train_return:>10.2f}%                     ‚ïë
‚ïë   Return Test:         {result.avg_test_return:>10.2f}%                     ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë STABILIT√â & OVERFITTING                                   ‚ïë
‚ïë   Ratio Classique:     {result.avg_overfitting_ratio:>10.2f}x                     ‚ïë
‚ïë   Ratio Robuste:       {result.robust_overfitting_ratio:>10.2f}x (avec p√©nalit√©) ‚ïë
‚ïë   D√©gradation:         {result.degradation_pct:>10.1f}%                     ‚ïë
‚ïë   Std Test (stabilit√©):{result.test_stability_std:>10.3f}                      ‚ïë
‚ïë   Folds valides:       {result.n_valid_folds:>10d}                      ‚ïë
‚ïë   Std Sharpe:          {result.sharpe_std:>10.3f}                      ‚ïë
‚ïë   Std Return:          {result.return_std:>10.2f}%                     ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë CRIT√àRES RECOMMAND√âS                                      ‚ïë
‚ïë   ‚úì Ratio robuste < 1.8                                  ‚ïë
‚ïë   ‚úì D√©gradation < 40%                                    ‚ïë
‚ïë   ‚úì Std stabilit√© < 0.5                                  ‚ïë
‚ïë   ‚úì Folds valides >= 4                                   ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
"""
                 
                                                            
^
[1m.\backtest\validation.py[m[36m:[m577[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
    report = f"""
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë            VALIDATION WALK-FORWARD                        ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë VERDICT: {verdict_emoji} {"ROBUST" if result.is_robust else "OVERFITTING D√âTECT√â"}
‚ïë Confiance: {result.confidence_score:.1%}
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë CONFIGURATION                                             ‚ïë
‚ïë   Nombre de folds:     {len(result.folds):>10d}                      ‚ïë
‚ïë   Samples train:       {result.total_train_samples:>10d}                      ‚ïë
‚ïë   Samples test:        {result.total_test_samples:>10d}                      ‚ïë
‚ïë   Embargo:             {result.embargo_samples:>10d}                      ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë PERFORMANCES MOYENNES                                     ‚ïë
‚ïë   Sharpe Train:        {result.avg_train_sharpe:>10.3f}                      ‚ïë
‚ïë   Sharpe Test:         {result.avg_test_sharpe:>10.3f}                      ‚ïë
‚ïë   Return Train:        {result.avg_train_return:>10.2f}%                     ‚ïë
‚ïë   Return Test:         {result.avg_test_return:>10.2f}%                     ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë STABILIT√â & OVERFITTING                                   ‚ïë
‚ïë   Ratio Classique:     {result.avg_overfitting_ratio:>10.2f}x                     ‚ïë
‚ïë   Ratio Robuste:       {result.robust_overfitting_ratio:>10.2f}x (avec p√©nalit√©) ‚ïë
‚ïë   D√©gradation:         {result.degradation_pct:>10.1f}%                     ‚ïë
‚ïë   Std Test (stabilit√©):{result.test_stability_std:>10.3f}                      ‚ïë
‚ïë   Folds valides:       {result.n_valid_folds:>10d}                      ‚ïë
‚ïë   Std Sharpe:          {result.sharpe_std:>10.3f}                      ‚ïë
‚ïë   Std Return:          {result.return_std:>10.2f}%                     ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë CRIT√àRES RECOMMAND√âS                                      ‚ïë
‚ïë   ‚úì Ratio robuste < 1.8                                  ‚ïë
‚ïë   ‚úì D√©gradation < 40%                                    ‚ïë
‚ïë   ‚úì Std stabilit√© < 0.5                                  ‚ïë
‚ïë   ‚úì Folds valides >= 4                                   ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
"""
                 
                                                            
^
[1m.\backtest\validation.py[m[36m:[m581[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
    report = f"""
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë            VALIDATION WALK-FORWARD                        ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë VERDICT: {verdict_emoji} {"ROBUST" if result.is_robust else "OVERFITTING D√âTECT√â"}
‚ïë Confiance: {result.confidence_score:.1%}
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë CONFIGURATION                                             ‚ïë
‚ïë   Nombre de folds:     {len(result.folds):>10d}                      ‚ïë
‚ïë   Samples train:       {result.total_train_samples:>10d}                      ‚ïë
‚ïë   Samples test:        {result.total_test_samples:>10d}                      ‚ïë
‚ïë   Embargo:             {result.embargo_samples:>10d}                      ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë PERFORMANCES MOYENNES                                     ‚ïë
‚ïë   Sharpe Train:        {result.avg_train_sharpe:>10.3f}                      ‚ïë
‚ïë   Sharpe Test:         {result.avg_test_sharpe:>10.3f}                      ‚ïë
‚ïë   Return Train:        {result.avg_train_return:>10.2f}%                     ‚ïë
‚ïë   Return Test:         {result.avg_test_return:>10.2f}%                     ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë STABILIT√â & OVERFITTING                                   ‚ïë
‚ïë   Ratio Classique:     {result.avg_overfitting_ratio:>10.2f}x                     ‚ïë
‚ïë   Ratio Robuste:       {result.robust_overfitting_ratio:>10.2f}x (avec p√©nalit√©) ‚ïë
‚ïë   D√©gradation:         {result.degradation_pct:>10.1f}%                     ‚ïë
‚ïë   Std Test (stabilit√©):{result.test_stability_std:>10.3f}                      ‚ïë
‚ïë   Folds valides:       {result.n_valid_folds:>10d}                      ‚ïë
‚ïë   Std Sharpe:          {result.sharpe_std:>10.3f}                      ‚ïë
‚ïë   Std Return:          {result.return_std:>10.2f}%                     ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë CRIT√àRES RECOMMAND√âS                                      ‚ïë
‚ïë   ‚úì Ratio robuste < 1.8                                  ‚ïë
‚ïë   ‚úì D√©gradation < 40%                                    ‚ïë
‚ïë   ‚úì Std stabilit√© < 0.5                                  ‚ïë
‚ïë   ‚úì Folds valides >= 4                                   ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
"""
                 
                                                            
^
[1m.\backtest\validation.py[m[36m:[m583[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
    report = f"""
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë            VALIDATION WALK-FORWARD                        ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë VERDICT: {verdict_emoji} {"ROBUST" if result.is_robust else "OVERFITTING D√âTECT√â"}
‚ïë Confiance: {result.confidence_score:.1%}
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë CONFIGURATION                                             ‚ïë
‚ïë   Nombre de folds:     {len(result.folds):>10d}                      ‚ïë
‚ïë   Samples train:       {result.total_train_samples:>10d}                      ‚ïë
‚ïë   Samples test:        {result.total_test_samples:>10d}                      ‚ïë
‚ïë   Embargo:             {result.embargo_samples:>10d}                      ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë PERFORMANCES MOYENNES                                     ‚ïë
‚ïë   Sharpe Train:        {result.avg_train_sharpe:>10.3f}                      ‚ïë
‚ïë   Sharpe Test:         {result.avg_test_sharpe:>10.3f}                      ‚ïë
‚ïë   Return Train:        {result.avg_train_return:>10.2f}%                     ‚ïë
‚ïë   Return Test:         {result.avg_test_return:>10.2f}%                     ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë STABILIT√â & OVERFITTING                                   ‚ïë
‚ïë   Ratio Classique:     {result.avg_overfitting_ratio:>10.2f}x                     ‚ïë
‚ïë   Ratio Robuste:       {result.robust_overfitting_ratio:>10.2f}x (avec p√©nalit√©) ‚ïë
‚ïë   D√©gradation:         {result.degradation_pct:>10.1f}%                     ‚ïë
‚ïë   Std Test (stabilit√©):{result.test_stability_std:>10.3f}                      ‚ïë
‚ïë   Folds valides:       {result.n_valid_folds:>10d}                      ‚ïë
‚ïë   Std Sharpe:          {result.sharpe_std:>10.3f}                      ‚ïë
‚ïë   Std Return:          {result.return_std:>10.2f}%                     ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë CRIT√àRES RECOMMAND√âS                                      ‚ïë
‚ïë   ‚úì Ratio robuste < 1.8                                  ‚ïë
‚ïë   ‚úì D√©gradation < 40%                                    ‚ïë
‚ïë   ‚úì Std stabilit√© < 0.5                                  ‚ïë
‚ïë   ‚úì Folds valides >= 4                                   ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
"""
                 
                                                            
^
[1m.\backtest\validation.py[m[36m:[m587[36m:[m80[36m:[m [1m[31mE501[m line too long (85 > 79 characters)
    report = f"""
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë            VALIDATION WALK-FORWARD                        ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë VERDICT: {verdict_emoji} {"ROBUST" if result.is_robust else "OVERFITTING D√âTECT√â"}
‚ïë Confiance: {result.confidence_score:.1%}
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë CONFIGURATION                                             ‚ïë
‚ïë   Nombre de folds:     {len(result.folds):>10d}                      ‚ïë
‚ïë   Samples train:       {result.total_train_samples:>10d}                      ‚ïë
‚ïë   Samples test:        {result.total_test_samples:>10d}                      ‚ïë
‚ïë   Embargo:             {result.embargo_samples:>10d}                      ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë PERFORMANCES MOYENNES                                     ‚ïë
‚ïë   Sharpe Train:        {result.avg_train_sharpe:>10.3f}                      ‚ïë
‚ïë   Sharpe Test:         {result.avg_test_sharpe:>10.3f}                      ‚ïë
‚ïë   Return Train:        {result.avg_train_return:>10.2f}%                     ‚ïë
‚ïë   Return Test:         {result.avg_test_return:>10.2f}%                     ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë STABILIT√â & OVERFITTING                                   ‚ïë
‚ïë   Ratio Classique:     {result.avg_overfitting_ratio:>10.2f}x                     ‚ïë
‚ïë   Ratio Robuste:       {result.robust_overfitting_ratio:>10.2f}x (avec p√©nalit√©) ‚ïë
‚ïë   D√©gradation:         {result.degradation_pct:>10.1f}%                     ‚ïë
‚ïë   Std Test (stabilit√©):{result.test_stability_std:>10.3f}                      ‚ïë
‚ïë   Folds valides:       {result.n_valid_folds:>10d}                      ‚ïë
‚ïë   Std Sharpe:          {result.sharpe_std:>10.3f}                      ‚ïë
‚ïë   Std Return:          {result.return_std:>10.2f}%                     ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë CRIT√àRES RECOMMAND√âS                                      ‚ïë
‚ïë   ‚úì Ratio robuste < 1.8                                  ‚ïë
‚ïë   ‚úì D√©gradation < 40%                                    ‚ïë
‚ïë   ‚úì Std stabilit√© < 0.5                                  ‚ïë
‚ïë   ‚úì Folds valides >= 4                                   ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
"""
                 
                                                            
^
[1m.\backtest\validation.py[m[36m:[m588[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
    report = f"""
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë            VALIDATION WALK-FORWARD                        ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë VERDICT: {verdict_emoji} {"ROBUST" if result.is_robust else "OVERFITTING D√âTECT√â"}
‚ïë Confiance: {result.confidence_score:.1%}
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë CONFIGURATION                                             ‚ïë
‚ïë   Nombre de folds:     {len(result.folds):>10d}                      ‚ïë
‚ïë   Samples train:       {result.total_train_samples:>10d}                      ‚ïë
‚ïë   Samples test:        {result.total_test_samples:>10d}                      ‚ïë
‚ïë   Embargo:             {result.embargo_samples:>10d}                      ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë PERFORMANCES MOYENNES                                     ‚ïë
‚ïë   Sharpe Train:        {result.avg_train_sharpe:>10.3f}                      ‚ïë
‚ïë   Sharpe Test:         {result.avg_test_sharpe:>10.3f}                      ‚ïë
‚ïë   Return Train:        {result.avg_train_return:>10.2f}%                     ‚ïë
‚ïë   Return Test:         {result.avg_test_return:>10.2f}%                     ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë STABILIT√â & OVERFITTING                                   ‚ïë
‚ïë   Ratio Classique:     {result.avg_overfitting_ratio:>10.2f}x                     ‚ïë
‚ïë   Ratio Robuste:       {result.robust_overfitting_ratio:>10.2f}x (avec p√©nalit√©) ‚ïë
‚ïë   D√©gradation:         {result.degradation_pct:>10.1f}%                     ‚ïë
‚ïë   Std Test (stabilit√©):{result.test_stability_std:>10.3f}                      ‚ïë
‚ïë   Folds valides:       {result.n_valid_folds:>10d}                      ‚ïë
‚ïë   Std Sharpe:          {result.sharpe_std:>10.3f}                      ‚ïë
‚ïë   Std Return:          {result.return_std:>10.2f}%                     ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë CRIT√àRES RECOMMAND√âS                                      ‚ïë
‚ïë   ‚úì Ratio robuste < 1.8                                  ‚ïë
‚ïë   ‚úì D√©gradation < 40%                                    ‚ïë
‚ïë   ‚úì Std stabilit√© < 0.5                                  ‚ïë
‚ïë   ‚úì Folds valides >= 4                                   ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
"""
                 
                                                            
^
[1m.\backtest\validation.py[m[36m:[m590[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
    report = f"""
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë            VALIDATION WALK-FORWARD                        ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë VERDICT: {verdict_emoji} {"ROBUST" if result.is_robust else "OVERFITTING D√âTECT√â"}
‚ïë Confiance: {result.confidence_score:.1%}
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë CONFIGURATION                                             ‚ïë
‚ïë   Nombre de folds:     {len(result.folds):>10d}                      ‚ïë
‚ïë   Samples train:       {result.total_train_samples:>10d}                      ‚ïë
‚ïë   Samples test:        {result.total_test_samples:>10d}                      ‚ïë
‚ïë   Embargo:             {result.embargo_samples:>10d}                      ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë PERFORMANCES MOYENNES                                     ‚ïë
‚ïë   Sharpe Train:        {result.avg_train_sharpe:>10.3f}                      ‚ïë
‚ïë   Sharpe Test:         {result.avg_test_sharpe:>10.3f}                      ‚ïë
‚ïë   Return Train:        {result.avg_train_return:>10.2f}%                     ‚ïë
‚ïë   Return Test:         {result.avg_test_return:>10.2f}%                     ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë STABILIT√â & OVERFITTING                                   ‚ïë
‚ïë   Ratio Classique:     {result.avg_overfitting_ratio:>10.2f}x                     ‚ïë
‚ïë   Ratio Robuste:       {result.robust_overfitting_ratio:>10.2f}x (avec p√©nalit√©) ‚ïë
‚ïë   D√©gradation:         {result.degradation_pct:>10.1f}%                     ‚ïë
‚ïë   Std Test (stabilit√©):{result.test_stability_std:>10.3f}                      ‚ïë
‚ïë   Folds valides:       {result.n_valid_folds:>10d}                      ‚ïë
‚ïë   Std Sharpe:          {result.sharpe_std:>10.3f}                      ‚ïë
‚ïë   Std Return:          {result.return_std:>10.2f}%                     ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë CRIT√àRES RECOMMAND√âS                                      ‚ïë
‚ïë   ‚úì Ratio robuste < 1.8                                  ‚ïë
‚ïë   ‚úì D√©gradation < 40%                                    ‚ïë
‚ïë   ‚úì Std stabilit√© < 0.5                                  ‚ïë
‚ïë   ‚úì Folds valides >= 4                                   ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
"""
                 
                                                            
^
[1m.\backtest\validation.py[m[36m:[m633[36m:[m80[36m:[m [1m[31mE501[m line too long (85 > 79 characters)
# - Docstring de module normalis√©e (LLM-friendly) centr√©e sur validation/walk-forward
                                                                               ^
[1m.\cli\__init__.py[m[36m:[m16[36m:[m80[36m:[m [1m[31mE501[m line too long (87 > 79 characters)
"""
Module-ID: cli.__init__

Purpose: Package CLI - parser argparse, routing commands, entry point.

Role in pipeline: CLI interface

Key components: create_parser(), add_subcommands(), main()

Inputs: sys.argv command-line args

Outputs: Dispatched to cmd_* functions

Dependencies: argparse, .commands

Conventions: Sous-commandes via add_parser(); --verbose/-v global; help auto-generated.

Read-if: Ajout/modification sous-commande ou argument structure.

Skip-if: Vous appelez main() depuis __main__.py.
"""
   
                       

                                                  ^
[1m.\cli\__init__.py[m[36m:[m132[36m:[m80[36m:[m [1m[31mE501[m line too long (91 > 79 characters)
        description="Affiche les param√®tres et documentation d'une strat√©gie ou indicateur"
                                                                               ^
[1m.\cli\__init__.py[m[36m:[m278[36m:[m80[36m:[m [1m[31mE501[m line too long (132 > 79 characters)
        choices=["sharpe", "sharpe_ratio", "sortino", "sortino_ratio", "total_return", "max_drawdown", "win_rate", "profit_factor"],
                                                                               ^
[1m.\cli\__init__.py[m[36m:[m280[36m:[m80[36m:[m [1m[31mE501[m line too long (107 > 79 characters)
        help="M√©trique d'optimisation. Accepte sharpe/sharpe_ratio, sortino/sortino_ratio (d√©faut: sharpe)"
                                                                               ^
[1m.\cli\__init__.py[m[36m:[m323[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
        description="V√©rifie l'int√©grit√© des strat√©gies, indicateurs et donn√©es"
                                                                               ^
[1m.\cli\__init__.py[m[36m:[m375[36m:[m80[36m:[m [1m[31mE501[m line too long (104 > 79 characters)
        description="Lance une optimisation intelligente des param√®tres (10-100x plus rapide que sweep)"
                                                                               ^
[1m.\cli\__init__.py[m[36m:[m416[36m:[m80[36m:[m [1m[31mE501[m line too long (91 > 79 characters)
        help="M√©trique √† optimiser. Multi-objectif: 'sharpe,max_drawdown' (d√©faut: sharpe)"
                                                                               ^
[1m.\cli\__init__.py[m[36m:[m492[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
        help="Arr√™t anticip√© apr√®s N trials sans am√©lioration (None = d√©sactiv√©)"
                                                                               ^
[1m.\cli\__init__.py[m[36m:[m550[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
        description="V√©rifie CuPy, CUDA, GPUs disponibles et benchmark CPU vs GPU"
                                                                               ^
[1m.\cli\__init__.py[m[36m:[m563[36m:[m80[36m:[m [1m[31mE501[m line too long (126 > 79 characters)
        description="Lance l'orchestrateur multi-agents (Analyst/Strategist/Critic/Validator) pour optimisation intelligente",
                                                                               ^
[1m.\cli\__init__.py[m[36m:[m649[36m:[m80[36m:[m [1m[31mE501[m line too long (92 > 79 characters)
        description="Ex√©cute un backtest sur une grille de param√®tres (diff√©rent de sweep)",
                                                                               ^
[1m.\cli\__init__.py[m[36m:[m697[36m:[m80[36m:[m [1m[31mE501[m line too long (124 > 79 characters)
        help="Grille de param√®tres en JSON (ex: '{\"atr_period\": [10, 14, 20]}'). Si omis, grille auto depuis param_ranges"
                                                                               ^
[1m.\cli\__init__.py[m[36m:[m702[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
        help="Inclure les param√®tres optionnels (ex: leverage) dans la grille auto"
                                                                               ^
[1m.\cli\__init__.py[m[36m:[m712[36m:[m80[36m:[m [1m[31mE501[m line too long (115 > 79 characters)
        choices=["sharpe_ratio", "sortino_ratio", "total_return_pct", "max_drawdown", "win_rate", "profit_factor"],
                                                                               ^
[1m.\cli\__init__.py[m[36m:[m733[36m:[m80[36m:[m [1m[31mE501[m line too long (87 > 79 characters)
        description="Analyse les r√©sultats de backtests stock√©s dans backtest_results/"
                                                                               ^
[1m.\cli\commands.py[m[36m:[m4[36m:[m80[36m:[m [1m[31mE501[m line too long (92 > 79 characters)
"""
Module-ID: cli.commands

Purpose: Impl√©mentation CLI commands - backtest, sweep, optuna, validate, export, visualize.

Role in pipeline: CLI interface

Key components: cmd_backtest(), cmd_sweep(), cmd_optuna(), Colors, normalize_metric_name(), METRIC_ALIASES

Inputs: argparse parsed args (strategy, data, params, etc.)

Outputs: Console output, JSON results, HTML/CSV exports, visualization

Dependencies: argparse, json, pathlib, pandas, numpy

Conventions: Metric aliases (sharpe ‚Üí sharpe_ratio); couleurs ANSI (d√©sactivable --no-color); progress bars.

Read-if: Ajout commande CLI ou modification format output.

Skip-if: Vous appelez cmd_backtest(args) depuis main.
"""
   
                       

                                                  ^
[1m.\cli\commands.py[m[36m:[m8[36m:[m80[36m:[m [1m[31mE501[m line too long (106 > 79 characters)
"""
Module-ID: cli.commands

Purpose: Impl√©mentation CLI commands - backtest, sweep, optuna, validate, export, visualize.

Role in pipeline: CLI interface

Key components: cmd_backtest(), cmd_sweep(), cmd_optuna(), Colors, normalize_metric_name(), METRIC_ALIASES

Inputs: argparse parsed args (strategy, data, params, etc.)

Outputs: Console output, JSON results, HTML/CSV exports, visualization

Dependencies: argparse, json, pathlib, pandas, numpy

Conventions: Metric aliases (sharpe ‚Üí sharpe_ratio); couleurs ANSI (d√©sactivable --no-color); progress bars.

Read-if: Ajout commande CLI ou modification format output.

Skip-if: Vous appelez cmd_backtest(args) depuis main.
"""
   
                       

                                                  ^
[1m.\cli\commands.py[m[36m:[m16[36m:[m80[36m:[m [1m[31mE501[m line too long (108 > 79 characters)
"""
Module-ID: cli.commands

Purpose: Impl√©mentation CLI commands - backtest, sweep, optuna, validate, export, visualize.

Role in pipeline: CLI interface

Key components: cmd_backtest(), cmd_sweep(), cmd_optuna(), Colors, normalize_metric_name(), METRIC_ALIASES

Inputs: argparse parsed args (strategy, data, params, etc.)

Outputs: Console output, JSON results, HTML/CSV exports, visualization

Dependencies: argparse, json, pathlib, pandas, numpy

Conventions: Metric aliases (sharpe ‚Üí sharpe_ratio); couleurs ANSI (d√©sactivable --no-color); progress bars.

Read-if: Ajout commande CLI ou modification format output.

Skip-if: Vous appelez cmd_backtest(args) depuis main.
"""
   
                       

                                                  ^
[1m.\cli\commands.py[m[36m:[m95[36m:[m80[36m:[m [1m[31mE501[m line too long (85 > 79 characters)
def format_table(headers: List[str], rows: List[List[str]], padding: int = 2) -> str:
                                                                               ^
[1m.\cli\commands.py[m[36m:[m115[36m:[m80[36m:[m [1m[31mE501[m line too long (86 > 79 characters)
        row_line = "  ".join(str(cell).ljust(widths[i]) for i, cell in enumerate(row))
                                                                               ^
[1m.\cli\commands.py[m[36m:[m130[36m:[m80[36m:[m [1m[31mE501[m line too long (93 > 79 characters)
def _apply_date_filter(df: pd.DataFrame, start: str | None, end: str | None) -> pd.DataFrame:
                                                                               ^
[1m.\cli\commands.py[m[36m:[m256[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
    # Chercher les fichiers via variable d'environnement ou r√©pertoire par d√©faut
                                                                               ^
[1m.\cli\commands.py[m[36m:[m290[36m:[m80[36m:[m [1m[31mE501[m line too long (114 > 79 characters)
            print_info("D√©finissez $env:BACKTEST_DATA_DIR ou placez des fichiers .parquet dans data/sample_data/")
                                                                               ^
[1m.\cli\commands.py[m[36m:[m305[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
        print(f"{Colors.BOLD}Timeframes:{Colors.RESET} {', '.join(timeframes)}")
                                                                               ^
[1m.\cli\commands.py[m[36m:[m312[36m:[m80[36m:[m [1m[31mE501[m line too long (85 > 79 characters)
    from utils.parameters import EMA_CROSS_PRESET, MINIMAL_PRESET, SAFE_RANGES_PRESET
                                                                               ^
[1m.\cli\commands.py[m[36m:[m327[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
        rows.append([p.name, p.description[:40], str(n_params), f"~{combos:,}"])
                                                                               ^
[1m.\cli\commands.py[m[36m:[m375[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
    if optional_skipped and not getattr(strat, "_include_optional_params", False):
                                                                               ^
[1m.\cli\commands.py[m[36m:[m379[36m:[m80[36m:[m [1m[31mE501[m line too long (133 > 79 characters)
                f"Param√®tres optionnels ignor√©s: {skipped} (ajoutez --include-optional-params ou BACKTEST_INCLUDE_OPTIONAL_PARAMS=1)"
                                                                               ^
[1m.\cli\commands.py[m[36m:[m425[36m:[m80[36m:[m [1m[31mE501[m line too long (92 > 79 characters)
            "settings_class": info.settings_class.__name__ if info.settings_class else None,
                                                                               ^
[1m.\cli\commands.py[m[36m:[m440[36m:[m80[36m:[m [1m[31mE501[m line too long (97 > 79 characters)
                default = param.default if param.default != inspect.Parameter.empty else "requis"
                                                                               ^
[1m.\cli\commands.py[m[36m:[m479[36m:[m80[36m:[m [1m[31mE501[m line too long (89 > 79 characters)
            data_path = Path(__file__).parent.parent / "data" / "sample_data" / args.data
                                                                               ^
[1m.\cli\commands.py[m[36m:[m507[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
    # Utiliser les fonctions internes pour charger directement depuis le fichier
                                                                               ^
[1m.\cli\commands.py[m[36m:[m556[36m:[m80[36m:[m [1m[31mE501[m line too long (94 > 79 characters)
            print(f"    Period: {result.meta['period_start']} -> {result.meta['period_end']}")
                                                                               ^
[1m.\cli\commands.py[m[36m:[m643[36m:[m80[36m:[m [1m[31mE501[m line too long (95 > 79 characters)
    from utils.parameters import ParameterSpec, compute_search_space_stats, generate_param_grid
                                                                               ^
[1m.\cli\commands.py[m[36m:[m656[36m:[m24[36m:[m [1m[31mF821[m undefined name 'os'
        env_data_dir = os.environ.get("BACKTEST_DATA_DIR")
                       ^
[1m.\cli\commands.py[m[36m:[m660[36m:[m80[36m:[m [1m[31mE501[m line too long (89 > 79 characters)
            data_path = Path(__file__).parent.parent / "data" / "sample_data" / args.data
                                                                               ^
[1m.\cli\commands.py[m[36m:[m703[36m:[m80[36m:[m [1m[31mE501[m line too long (121 > 79 characters)
    stats = compute_search_space_stats(param_specs, max_combinations=args.max_combinations, granularity=args.granularity)
                                                                               ^
[1m.\cli\commands.py[m[36m:[m706[36m:[m80[36m:[m [1m[31mE501[m line too long (85 > 79 characters)
        print_info(f"Espace de recherche: {stats.total_combinations:,} combinaisons")
                                                                               ^
[1m.\cli\commands.py[m[36m:[m755[36m:[m80[36m:[m [1m[31mE501[m line too long (85 > 79 characters)
            # G√©rer les m√©triques qui peuvent √™tre un dict ou un objet avec to_dict()
                                                                               ^
[1m.\cli\commands.py[m[36m:[m775[36m:[m80[36m:[m [1m[31mE501[m line too long (102 > 79 characters)
            print(f"\r  Progress: {i+1}/{len(grid)} ({100*(i+1)/len(grid):.1f}%)", end="", flush=True)
                                                                               ^
[1m.\cli\commands.py[m[36m:[m794[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
            print(f"    Return: {r['metrics'].get('total_return_pct', 0):+.2f}%")
                                                                               ^
[1m.\cli\commands.py[m[36m:[m882[36m:[m80[36m:[m [1m[31mE501[m line too long (88 > 79 characters)
            data_files = list(data_dir.glob("*.parquet")) + list(data_dir.glob("*.csv"))
                                                                               ^
[1m.\cli\commands.py[m[36m:[m984[36m:[m80[36m:[m [1m[31mE501[m line too long (106 > 79 characters)
            html += f'        <p class="metric">{key}: <span class="{css_class}">{value:.4f}</span></p>\n'
                                                                               ^
[1m.\cli\commands.py[m[36m:[m1014[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
        raise ImportError("openpyxl requis pour export Excel: pip install openpyxl")
                                                                               ^
[1m.\cli\commands.py[m[36m:[m1086[36m:[m24[36m:[m [1m[31mF821[m undefined name 'os'
        env_data_dir = os.environ.get("BACKTEST_DATA_DIR")
                       ^
[1m.\cli\commands.py[m[36m:[m1090[36m:[m80[36m:[m [1m[31mE501[m line too long (89 > 79 characters)
            data_path = Path(__file__).parent.parent / "data" / "sample_data" / args.data
                                                                               ^
[1m.\cli\commands.py[m[36m:[m1189[36m:[m80[36m:[m [1m[31mE501[m line too long (85 > 79 characters)
            print_info(f"Early stopping activ√©: patience={args.early_stop_patience}")
                                                                               ^
[1m.\cli\commands.py[m[36m:[m1196[36m:[m80[36m:[m [1m[31mE501[m line too long (88 > 79 characters)
            metrics = [normalize_metric_name(m.strip()) for m in args.metric.split(",")]
                                                                               ^
[1m.\cli\commands.py[m[36m:[m1224[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
            direction = "minimize" if args.metric == "max_drawdown" else "maximize"
                                                                               ^
[1m.\cli\commands.py[m[36m:[m1238[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
                print(f"  Trials: {result.n_completed}/{args.n_trials} compl√©t√©s")
                                                                               ^
[1m.\cli\commands.py[m[36m:[m1247[36m:[m80[36m:[m [1m[31mE501[m line too long (94 > 79 characters)
                    print(f"    Sharpe: {result.best_metrics.get('sharpe_ratio', 'N/A'):.3f}")
                                                                               ^
[1m.\cli\commands.py[m[36m:[m1248[36m:[m80[36m:[m [1m[31mE501[m line too long (96 > 79 characters)
                    print(f"    Return: {result.best_metrics.get('total_return_pct', 0):+.2f}%")
                                                                               ^
[1m.\cli\commands.py[m[36m:[m1249[36m:[m80[36m:[m [1m[31mE501[m line too long (97 > 79 characters)
                    print(f"    Drawdown: {result.best_metrics.get('max_drawdown', 0)*100:.2f}%")
                                                                               ^
[1m.\cli\commands.py[m[36m:[m1255[36m:[m80[36m:[m [1m[31mE501[m line too long (107 > 79 characters)
                    print(f"  {Colors.BOLD}Top {min(args.top, len(top_df))} configurations:{Colors.RESET}")
                                                                               ^
[1m.\cli\commands.py[m[36m:[m1256[36m:[m80[36m:[m [1m[31mE501[m line too long (85 > 79 characters)
                    # R√©cup√©rer les noms des param√®tres (excluant 'trial' et 'value')
                                                                               ^
[1m.\cli\commands.py[m[36m:[m1257[36m:[m80[36m:[m [1m[31mE501[m line too long (91 > 79 characters)
                    param_cols = [c for c in top_df.columns if c not in ['trial', 'value']]
                                                                               ^
[1m.\cli\commands.py[m[36m:[m1258[36m:[m80[36m:[m [1m[31mE501[m line too long (85 > 79 characters)
                    for idx, (_, row) in enumerate(top_df.head(args.top).iterrows()):
                                                                               ^
[1m.\cli\commands.py[m[36m:[m1259[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
                        params = {col: row[col] for col in param_cols if col in row}
                                                                               ^
[1m.\cli\commands.py[m[36m:[m1385[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
                key=lambda x: x.get('metrics', {}).get(metric_key, float('-inf')),
                                                                               ^
[1m.\cli\commands.py[m[36m:[m1397[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
                print_info(f"Meilleur r√©sultat (sur {len(all_results)}): {params}")
                                                                               ^
[1m.\cli\commands.py[m[36m:[m1398[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
                print_info(f"{metric_key}: {metrics.get(metric_key, 'N/A'):.4f}")
                                                                               ^
[1m.\cli\commands.py[m[36m:[m1411[36m:[m80[36m:[m [1m[31mE501[m line too long (88 > 79 characters)
                print_info(f"Meilleure valeur: {results_data.get('best_value', 'N/A')}")
                                                                               ^
[1m.\cli\commands.py[m[36m:[m1413[36m:[m80[36m:[m [1m[31mE501[m line too long (86 > 79 characters)
                # Relancer un backtest avec les meilleurs params pour avoir les trades
                                                                               ^
[1m.\cli\commands.py[m[36m:[m1416[36m:[m80[36m:[m [1m[31mE501[m line too long (92 > 79 characters)
                        print_info("Ex√©cution du backtest avec les meilleurs param√®tres...")
                                                                               ^
[1m.\cli\commands.py[m[36m:[m1457[36m:[m80[36m:[m [1m[31mE501[m line too long (96 > 79 characters)
                    equity_curve = result.equity.tolist() if hasattr(result, "equity") else None
                                                                               ^
[1m.\cli\commands.py[m[36m:[m1469[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
            print_info("Assurez-vous que le fichier contient des donn√©es de trades")
                                                                               ^
[1m.\cli\commands.py[m[36m:[m1507[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
            params_str = ", ".join(f"{k}={v}" for k, v in list(params.items())[:4])
                                                                               ^
[1m.\cli\commands.py[m[36m:[m1638[36m:[m80[36m:[m [1m[31mE501[m line too long (103 > 79 characters)
            print(f"    VRAM Libre:          {format_bytes(free_mem)} ({100*free_mem/total_mem:.1f}%)")
                                                                               ^
[1m.\cli\commands.py[m[36m:[m1639[36m:[m80[36m:[m [1m[31mE501[m line too long (103 > 79 characters)
            print(f"    VRAM Utilis√©e:       {format_bytes(used_mem)} ({100*used_mem/total_mem:.1f}%)")
                                                                               ^
[1m.\cli\commands.py[m[36m:[m1642[36m:[m80[36m:[m [1m[31mE501[m line too long (92 > 79 characters)
                print(f"    Multiprocesseurs:    {props.get('multiProcessorCount', 'N/A')}")
                                                                               ^
[1m.\cli\commands.py[m[36m:[m1643[36m:[m80[36m:[m [1m[31mE501[m line too long (91 > 79 characters)
                print(f"    Max Threads/Block:   {props.get('maxThreadsPerBlock', 'N/A')}")
                                                                               ^
[1m.\cli\commands.py[m[36m:[m1644[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
                print(f"    Warp Size:           {props.get('warpSize', 'N/A')}")
                                                                               ^
[1m.\cli\commands.py[m[36m:[m1717[36m:[m80[36m:[m [1m[31mE501[m line too long (88 > 79 characters)
                print(f"    Speedup:        {Colors.GREEN}{speedup:.2f}x{Colors.RESET}")
                                                                               ^
[1m.\cli\commands.py[m[36m:[m1719[36m:[m80[36m:[m [1m[31mE501[m line too long (105 > 79 characters)
                print(f"    Speedup:        {Colors.YELLOW}{speedup:.2f}x{Colors.RESET} (GPU plus lent)")
                                                                               ^
[1m.\cli\commands.py[m[36m:[m1729[36m:[m80[36m:[m [1m[31mE501[m line too long (87 > 79 characters)
                print_warning("GPU significativement plus lent (dataset trop petit ?)")
                                                                               ^
[1m.\cli\commands.py[m[36m:[m1742[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
        print("  ‚Ä¢ Activer GPU dans indicateurs: voir RAPPORT_ANALYSE_GPU_CPU.md")
                                                                               ^
[1m.\cli\commands.py[m[36m:[m1744[36m:[m80[36m:[m [1m[31mE501[m line too long (87 > 79 characters)
        print("  ‚Ä¢ Variable d'environnement: CUDA_VISIBLE_DEVICES=0 (limiter √† GPU 0)")
                                                                               ^
[1m.\cli\commands.py[m[36m:[m1986[36m:[m80[36m:[m [1m[31mE501[m line too long (95 > 79 characters)
        if hasattr(strategy_instance, "parameter_specs") and strategy_instance.parameter_specs:
                                                                               ^
[1m.\cli\commands.py[m[36m:[m1993[36m:[m80[36m:[m [1m[31mE501[m line too long (98 > 79 characters)
        if optional_skipped and not getattr(strategy_instance, "_include_optional_params", False):
                                                                               ^
[1m.\cli\commands.py[m[36m:[m1997[36m:[m80[36m:[m [1m[31mE501[m line too long (137 > 79 characters)
                    f"Param√®tres optionnels ignor√©s: {skipped} (ajoutez --include-optional-params ou BACKTEST_INCLUDE_OPTIONAL_PARAMS=1)"
                                                                               ^
[1m.\cli\commands.py[m[36m:[m2002[36m:[m80[36m:[m [1m[31mE501[m line too long (85 > 79 characters)
        for param_name, (min_val, max_val) in strategy_instance.param_ranges.items():
                                                                               ^
[1m.\cli\commands.py[m[36m:[m2003[36m:[m80[36m:[m [1m[31mE501[m line too long (95 > 79 characters)
            default = strategy_instance.default_params.get(param_name, (min_val + max_val) / 2)
                                                                               ^
[1m.\cli\commands.py[m[36m:[m2024[36m:[m80[36m:[m [1m[31mE501[m line too long (106 > 79 characters)
        print_warning(f"Nombre de combinaisons ({len(all_combinations)}) > max ({args.max_combinations})")
                                                                               ^
[1m.\cli\commands.py[m[36m:[m2028[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
        all_combinations = random.sample(all_combinations, args.max_combinations)
                                                                               ^
[1m.\cli\commands.py[m[36m:[m2083[36m:[m80[36m:[m [1m[31mE501[m line too long (126 > 79 characters)
            print(f"\r  Progress: {i+1}/{len(all_combinations)} ({100*(i+1)/len(all_combinations):.1f}%)", end="", flush=True)
                                                                               ^
[1m.\cli\commands.py[m[36m:[m2094[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
    results.sort(key=lambda x: x["metrics"].get(metric_key, 0), reverse=reverse)
                                                                               ^
[1m.\cli\commands.py[m[36m:[m2104[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
            print(f"    Return: {r['metrics'].get('total_return_pct', 0):+.2f}%")
                                                                               ^
[1m.\cli\commands.py[m[36m:[m2177[36m:[m80[36m:[m [1m[31mE501[m line too long (105 > 79 characters)
    print_header(f"R√©sultats {'profitables' if args.profitable_only else 'tous'} ({len(filtered)})", "-")
                                                                               ^
[1m.\cli\commands.py[m[36m:[m2181[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
    reverse = args.sort_by != "max_drawdown_pct"  # Plus bas = mieux pour drawdown
                                                                               ^
[1m.\cli\commands.py[m[36m:[m2185[36m:[m80[36m:[m [1m[31mE501[m line too long (98 > 79 characters)
        key=lambda x: x[1]['metrics'].get(metric_key, float('-inf') if reverse else float('inf')),
                                                                               ^
[1m.\cli\commands.py[m[36m:[m2193[36m:[m80[36m:[m [1m[31mE501[m line too long (96 > 79 characters)
        print(f"  P√©riode: {data.get('period_start', 'N/A')} ‚Üí {data.get('period_end', 'N/A')}")
                                                                               ^
[1m.\cli\commands.py[m[36m:[m2194[36m:[m80[36m:[m [1m[31mE501[m line too long (100 > 79 characters)
        print(f"  Symbole: {data.get('symbol', 'N/A')} | Timeframe: {data.get('timeframe', 'N/A')}")
                                                                               ^
[1m.\cli\commands.py[m[36m:[m2202[36m:[m80[36m:[m [1m[31mE501[m line too long (101 > 79 characters)
        print(f"    PnL: ${m.get('total_pnl', 0):.2f} | Return: {m.get('total_return_pct', 0):.2f}%")
                                                                               ^
[1m.\cli\commands.py[m[36m:[m2203[36m:[m80[36m:[m [1m[31mE501[m line too long (103 > 79 characters)
        print(f"    Sharpe: {m.get('sharpe_ratio', 0):.2f} | Sortino: {m.get('sortino_ratio', 0):.2f}")
                                                                               ^
[1m.\cli\commands.py[m[36m:[m2204[36m:[m80[36m:[m [1m[31mE501[m line too long (112 > 79 characters)
        print(f"    Win Rate: {m.get('win_rate_pct', 0):.2f}% | Profit Factor: {m.get('profit_factor', 0):.2f}")
                                                                               ^
[1m.\cli\commands.py[m[36m:[m2205[36m:[m80[36m:[m [1m[31mE501[m line too long (102 > 79 characters)
        print(f"    Max DD: {m.get('max_drawdown_pct', 0):.2f}% | Trades: {m.get('total_trades', 0)}")
                                                                               ^
[1m.\cli\commands.py[m[36m:[m2214[36m:[m80[36m:[m [1m[31mE501[m line too long (88 > 79 characters)
        sharpe_values = [d['metrics'].get('sharpe_ratio', 0) for d in filtered.values()]
                                                                               ^
[1m.\cli\commands.py[m[36m:[m2215[36m:[m80[36m:[m [1m[31mE501[m line too long (92 > 79 characters)
        return_values = [d['metrics'].get('total_return_pct', 0) for d in filtered.values()]
                                                                               ^
[1m.\cli\commands.py[m[36m:[m2216[36m:[m80[36m:[m [1m[31mE501[m line too long (88 > 79 characters)
        dd_values = [d['metrics'].get('max_drawdown_pct', 0) for d in filtered.values()]
                                                                               ^
[1m.\cli\commands.py[m[36m:[m2221[36m:[m80[36m:[m [1m[31mE501[m line too long (89 > 79 characters)
        print(f"    Min: {np.min(sharpe_values):.2f} | Max: {np.max(sharpe_values):.2f}")
                                                                               ^
[1m.\cli\commands.py[m[36m:[m2226[36m:[m80[36m:[m [1m[31mE501[m line too long (91 > 79 characters)
        print(f"    Min: {np.min(return_values):.2f}% | Max: {np.max(return_values):.2f}%")
                                                                               ^
[1m.\cli\commands.py[m[36m:[m2231[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
        print(f"    Min: {np.min(dd_values):.2f}% | Max: {np.max(dd_values):.2f}%")
                                                                               ^
[1m.\data\__init__.py[m[36m:[m4[36m:[m80[36m:[m [1m[31mE501[m line too long (87 > 79 characters)
"""
Module-ID: data.__init__

Purpose: Package data - exports loader functions (load_ohlcv, discover_available_data).

Role in pipeline: data input

Key components: Re-exports load_ohlcv, discover_available_data

Inputs: None (module imports only)

Outputs: Public API via __all__

Dependencies: .loader

Conventions: __all__ d√©finit API publique.

Read-if: Modification exports ou structure package.

Skip-if: Vous importez directement depuis data.loader.
"""
   
                        

                                                 ^
[1m.\data\indicator_bank.py[m[36m:[m4[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
"""
Module-ID: data.indicator_bank

Purpose: Cache disque intelligent indicateurs - √©vite recalc via hash param+donn√©es.

Role in pipeline: performance

Key components: IndicatorBank, CacheEntry, CacheStats, hash_indicator_config()

Inputs: Indicator name, params, OHLCV data

Outputs: Cached array ou recalc si stale (TTL), CacheStats {hits, misses, hit_rate}

Dependencies: pandas, hashlib, pickle, pathlib, dataclasses, time

Conventions: TTL 7j d√©faut; cl√© hash (nom, params, donn√©es); √©viction LRU.

Read-if: Modification cache policy ou TTL.

Skip-if: Vous appelez bank.get(indicator_name, params, df).
"""
   
                              

                                           ^
[1m.\data\indicator_bank.py[m[36m:[m12[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
"""
Module-ID: data.indicator_bank

Purpose: Cache disque intelligent indicateurs - √©vite recalc via hash param+donn√©es.

Role in pipeline: performance

Key components: IndicatorBank, CacheEntry, CacheStats, hash_indicator_config()

Inputs: Indicator name, params, OHLCV data

Outputs: Cached array ou recalc si stale (TTL), CacheStats {hits, misses, hit_rate}

Dependencies: pandas, hashlib, pickle, pathlib, dataclasses, time

Conventions: TTL 7j d√©faut; cl√© hash (nom, params, donn√©es); √©viction LRU.

Read-if: Modification cache policy ou TTL.

Skip-if: Vous appelez bank.get(indicator_name, params, df).
"""
   
                              

                                           ^
[1m.\data\indicator_bank.py[m[36m:[m138[36m:[m80[36m:[m [1m[31mE501[m line too long (92 > 79 characters)
        logger.info("Reconstruction de l'index du cache √† partir des fichiers existants...")
                                                                               ^
[1m.\data\indicator_bank.py[m[36m:[m153[36m:[m80[36m:[m [1m[31mE501[m line too long (90 > 79 characters)
                        logger.debug(f"Fichier ignor√© (format invalide): {pkl_file.name}")
                                                                               ^
[1m.\data\indicator_bank.py[m[36m:[m179[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
                        logger.debug(f"Fichier expir√© supprim√©: {pkl_file.name}")
                                                                               ^
[1m.\data\indicator_bank.py[m[36m:[m183[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
                    logger.debug(f"Erreur indexation fichier {pkl_file.name}: {e}")
                                                                               ^
[1m.\data\indicator_bank.py[m[36m:[m186[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
            logger.info(f"Index reconstruit: {len(self._index)} entr√©es valides")
                                                                               ^
[1m.\data\indicator_bank.py[m[36m:[m225[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
                logger.info("Tentative de reconstruction automatique de l'index...")
                                                                               ^
[1m.\data\indicator_bank.py[m[36m:[m229[36m:[m80[36m:[m [1m[31mE501[m line too long (90 > 79 characters)
            logger.info("Index absent, reconstruction √† partir des fichiers existants...")
                                                                               ^
[1m.\data\indicator_bank.py[m[36m:[m265[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
            "checksum": float(df["close"].sum()) if "close" in df.columns else 0.0
                                                                               ^
[1m.\data\indicator_bank.py[m[36m:[m286[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
        # Inclure le backend dans la cl√© de cache pour √©viter collisions CPU/GPU
                                                                               ^
[1m.\data\indicator_bank.py[m[36m:[m295[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
        params_hash = hashlib.sha256(params_str.encode("utf-8")).hexdigest()[:12]
                                                                               ^
[1m.\data\indicator_bank.py[m[36m:[m297[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
        # Hash des donn√©es (bas√© sur shape, premier/dernier timestamp, checksum)
                                                                               ^
[1m.\data\indicator_bank.py[m[36m:[m345[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
        """
        R√©cup√®re un indicateur depuis le cache.

        Args:
            indicator_name: Nom de l'indicateur
            params: Param√®tres utilis√©s
            df: DataFrame source
            backend: Backend utilis√© ("cpu" ou "gpu") pour diff√©rencier le cache

        Returns:
            R√©sultat cach√© ou None si non trouv√©/expir√©
        """
           
                                               

             
    ^
[1m.\data\indicator_bank.py[m[36m:[m355[36m:[m80[36m:[m [1m[31mE501[m line too long (100 > 79 characters)
        key, _, _ = self._generate_key(indicator_name, params_with_backend, df, data_hash=data_hash)
                                                                               ^
[1m.\data\indicator_bank.py[m[36m:[m409[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
        """
        Stocke un indicateur dans le cache.

        Args:
            indicator_name: Nom de l'indicateur
            params: Param√®tres utilis√©s
            df: DataFrame source
            result: R√©sultat √† cacher
            ttl: TTL personnalis√© (optionnel)
            backend: Backend utilis√© ("cpu" ou "gpu") pour diff√©rencier le cache

        Returns:
            True si mis en cache avec succ√®s
        """
           
                                           

             
        ^
[1m.\data\indicator_bank.py[m[36m:[m462[36m:[m80[36m:[m [1m[31mE501[m line too long (91 > 79 characters)
        logger.debug(f"Cache PUT: {indicator_name} [{key[:16]}] ({size_bytes/1024:.1f}KB)")
                                                                               ^
[1m.\data\indicator_bank.py[m[36m:[m465[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
    def _remove_entry(self, entry: CacheEntry, update_index: bool = True) -> None:
                                                                               ^
[1m.\data\indicator_bank.py[m[36m:[m501[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
            logger.debug(f"Eviction: {entry.indicator_name} [{entry.key[:16]}]")
                                                                               ^
[1m.\data\indicator_bank.py[m[36m:[m530[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
            keys_to_drop = [k for k in self._memory_cache if k.startswith(prefix)]
                                                                               ^
[1m.\data\indicator_bank.py[m[36m:[m538[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
            if indicator_name is None or entry.indicator_name == indicator_name:
                                                                               ^
[1m.\data\loader.py[m[36m:[m4[36m:[m80[36m:[m [1m[31mE501[m line too long (88 > 79 characters)
"""
Module-ID: data.loader

Purpose: Chargement OHLCV multi-formats (CSV, Parquet, JSON, Feather) + d√©couverte auto.

Role in pipeline: data input

Key components: load_ohlcv(), discover_available_data(), _get_data_dir()

Inputs: CSV/Parquet/JSON/Feather files, env vars BACKTEST_DATA_DIR/TRADX_DATA_ROOT

Outputs: Normalized pandas DataFrame {timestamp, open, high, low, close, volume}

Dependencies: pandas, pathlib, numpy, functools

Conventions: DatetimeIndex; OHLCV colonnes lowercase; env var priority; @lru_cache.

Read-if: Modification formats supports ou paths par d√©faut.

Skip-if: Vous appelez load_ohlcv(filename).
"""
   
                      

                                                   ^
[1m.\data\loader.py[m[36m:[m10[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
"""
Module-ID: data.loader

Purpose: Chargement OHLCV multi-formats (CSV, Parquet, JSON, Feather) + d√©couverte auto.

Role in pipeline: data input

Key components: load_ohlcv(), discover_available_data(), _get_data_dir()

Inputs: CSV/Parquet/JSON/Feather files, env vars BACKTEST_DATA_DIR/TRADX_DATA_ROOT

Outputs: Normalized pandas DataFrame {timestamp, open, high, low, close, volume}

Dependencies: pandas, pathlib, numpy, functools

Conventions: DatetimeIndex; OHLCV colonnes lowercase; env var priority; @lru_cache.

Read-if: Modification formats supports ou paths par d√©faut.

Skip-if: Vous appelez load_ohlcv(filename).
"""
   
                      

                                                   ^
[1m.\data\loader.py[m[36m:[m12[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
"""
Module-ID: data.loader

Purpose: Chargement OHLCV multi-formats (CSV, Parquet, JSON, Feather) + d√©couverte auto.

Role in pipeline: data input

Key components: load_ohlcv(), discover_available_data(), _get_data_dir()

Inputs: CSV/Parquet/JSON/Feather files, env vars BACKTEST_DATA_DIR/TRADX_DATA_ROOT

Outputs: Normalized pandas DataFrame {timestamp, open, high, low, close, volume}

Dependencies: pandas, pathlib, numpy, functools

Conventions: DatetimeIndex; OHLCV colonnes lowercase; env var priority; @lru_cache.

Read-if: Modification formats supports ou paths par d√©faut.

Skip-if: Vous appelez load_ohlcv(filename).
"""
   
                      

                                                   ^
[1m.\data\loader.py[m[36m:[m16[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
"""
Module-ID: data.loader

Purpose: Chargement OHLCV multi-formats (CSV, Parquet, JSON, Feather) + d√©couverte auto.

Role in pipeline: data input

Key components: load_ohlcv(), discover_available_data(), _get_data_dir()

Inputs: CSV/Parquet/JSON/Feather files, env vars BACKTEST_DATA_DIR/TRADX_DATA_ROOT

Outputs: Normalized pandas DataFrame {timestamp, open, high, low, close, volume}

Dependencies: pandas, pathlib, numpy, functools

Conventions: DatetimeIndex; OHLCV colonnes lowercase; env var priority; @lru_cache.

Read-if: Modification formats supports ou paths par d√©faut.

Skip-if: Vous appelez load_ohlcv(filename).
"""
   
                      

                                                   ^
[1m.\data\loader.py[m[36m:[m177[36m:[m80[36m:[m [1m[31mE501[m line too long (91 > 79 characters)
        "Open": "open", "High": "high", "Low": "low", "Close": "close", "Volume": "volume",
                                                                               ^
[1m.\data\loader.py[m[36m:[m200[36m:[m80[36m:[m [1m[31mE501[m line too long (85 > 79 characters)
            # D√©tecter le format du timestamp (millisecondes vs secondes vs datetime)
                                                                               ^
[1m.\data\loader.py[m[36m:[m274[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
            f"Fichier OHLCV introuvable pour {symbol}/{timeframe} dans {data_dir}"
                                                                               ^
[1m.\data\loader.py[m[36m:[m281[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
    logger.info(f"  P√©riode: {df.index[0]} ‚Üí {df.index[-1]} ({len(df)} barres)")
                                                                               ^
[1m.\data\sample_data\generate_sample.py[m[36m:[m8[36m:[m80[36m:[m [1m[31mE501[m line too long (88 > 79 characters)
"""
Module-ID: data.sample_data.generate_sample

Purpose: G√©n√©rateur donn√©es d'exemple synth√©tiques pour tests unitaires.

Role in pipeline: test data

Key components: generate_sample_btcusdt(), generate_sample_multi_token(), export parquet

Inputs: Output path, nombre barres

Outputs: Fichier parquet OHLCV avec donn√©es r√©alistes

Dependencies: numpy, pandas, pathlib

Conventions: Seed=42 pour reproductibilit√©; colonnes [open, high, low, close, volume]

Read-if: G√©n√©rer donn√©es test ou d√©mo.

Skip-if: Vous utiliser vos donn√©es r√©elles.
"""
   
                                           

                              ^
[1m.\data\sample_data\generate_sample.py[m[36m:[m16[36m:[m80[36m:[m [1m[31mE501[m line too long (85 > 79 characters)
"""
Module-ID: data.sample_data.generate_sample

Purpose: G√©n√©rateur donn√©es d'exemple synth√©tiques pour tests unitaires.

Role in pipeline: test data

Key components: generate_sample_btcusdt(), generate_sample_multi_token(), export parquet

Inputs: Output path, nombre barres

Outputs: Fichier parquet OHLCV avec donn√©es r√©alistes

Dependencies: numpy, pandas, pathlib

Conventions: Seed=42 pour reproductibilit√©; colonnes [open, high, low, close, volume]

Read-if: G√©n√©rer donn√©es test ou d√©mo.

Skip-if: Vous utiliser vos donn√©es r√©elles.
"""
   
                                           

                              ^
[1m.\data\sample_data\generate_sample.py[m[36m:[m66[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
    volatility_volume = np.abs(returns) * 5000  # Plus de volume sur gros mouvements
                                                                               ^
[1m.\indicators\__init__.py[m[36m:[m59[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
from .scoring import calculate_bear_score, calculate_bull_score, directional_bias
                                                                               ^
[1m.\indicators\__init__.py[m[36m:[m60[36m:[m80[36m:[m [1m[31mE501[m line too long (94 > 79 characters)
from .smart_legs import calculate_smart_legs_bearish, calculate_smart_legs_bullish, smart_legs
                                                                               ^
[1m.\indicators\adx.py[m[36m:[m16[36m:[m80[36m:[m [1m[31mE501[m line too long (86 > 79 characters)
"""
Module-ID: indicators.adx

Purpose: Indicateur ADX (force tendance) + DI+ (haussier) + DI- (baissier).

Role in pipeline: data

Key components: adx, calculate_adx, ADXSettings, plus_di, minus_di

Inputs: DataFrame avec high, low, close; period (14 standard)

Outputs: Dict{adx, plus_di, minus_di} ou Tuple

Dependencies: pandas, numpy, dataclasses

Conventions: ADX liss√© 14 p√©riodes; +DI/DI- direction; <20 faible, >40 forte tendance.

Read-if: Modification p√©riode, lissage ADX.

Skip-if: Vous utilisez juste calculate_indicator('adx').
"""
   
                         

                                                ^
[1m.\indicators\adx.py[m[36m:[m127[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
    """
    Calcule l'ADX (Average Directional Index) et les DI.

    Args:
        high: S√©rie des plus hauts
        low: S√©rie des plus bas
        close: S√©rie des cl√¥tures
        period: P√©riode de calcul (d√©faut: 14)

    Returns:
        Tuple (adx, plus_di, minus_di)

    Example:
        >>> adx_val, plus_di, minus_di = adx(df["high"], df["low"], df["close"])
        >>> # Tendance forte si adx_val > 25
        >>> # Tendance haussi√®re si plus_di > minus_di
    """
       
                                                        

         
   ^
[1m.\indicators\amplitude_hunter.py[m[36m:[m4[36m:[m80[36m:[m [1m[31mE501[m line too long (86 > 79 characters)
"""
Module-ID: indicators.amplitude_hunter

Purpose: Score l'extr√©mit√© plage intrabar vs baseline roulante - d√©tecte amp volatil√©.

Role in pipeline: technical indicator

Key components: AmplitudeHunterSettings, amplitude_hunter()

Inputs: [high, low], period, threshold

Outputs: numpy array scores [0, 1]

Dependencies: numpy, pandas, indicators.registry

Conventions: Score normalize [0, 1]; settings dataclass

Read-if: Utiliser amplitude hunter pour signaux volatilt√©.

Skip-if: Indicateur non utilis√©.
"""
   
                                      

                                   ^
[1m.\indicators\amplitude_hunter.py[m[36m:[m78[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
    score = np.where(std_values != 0, (range_pct - mean_values) / std_values, 0.0)
                                                                               ^
[1m.\indicators\amplitude_hunter.py[m[36m:[m86[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
def calculate_amplitude_hunter(df: pd.DataFrame, **params) -> dict[str, np.ndarray]:
                                                                               ^
[1m.\indicators\aroon.py[m[36m:[m16[36m:[m80[36m:[m [1m[31mE501[m line too long (92 > 79 characters)
"""
Module-ID: indicators.aroon

Purpose: Indicateur Aroon (Aroon Up/Down) - temps depuis haut/bas.

Role in pipeline: data

Key components: aroon, AroonSettings, calculate_aroon, aroon_up, aroon_down

Inputs: DataFrame avec high, low; period

Outputs: Dict{aroon_up, aroon_down} ou Tuple

Dependencies: pandas, numpy, dataclasses

Conventions: Aroon Up = (period - bars_since_high) / period * 100; >70 tendance, <30 faible.

Read-if: Modification p√©riode, formule bars_since.

Skip-if: Vous utilisez juste calculate_indicator('aroon').
"""
   
                           

                                              ^
[1m.\indicators\atr.py[m[36m:[m41[36m:[m80[36m:[m [1m[31mE501[m line too long (85 > 79 characters)
            raise ValueError(f"method doit √™tre 'ema' ou 'sma', re√ßu: {self.method}")
                                                                               ^
[1m.\indicators\atr.py[m[36m:[m132[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
        atr_values = tr_series.rolling(window=period, min_periods=period).mean()
                                                                               ^
[1m.\indicators\atr.py[m[36m:[m202[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
__all__ = ["atr", "ATRSettings", "true_range", "atr_percent", "calculate_stop_loss"]
                                                                               ^
[1m.\indicators\bollinger.py[m[36m:[m60[36m:[m80[36m:[m [1m[31mE501[m line too long (91 > 79 characters)
    """
    Calcule les Bandes de Bollinger.

    Args:
        close: Prix de cl√¥ture
        period: P√©riode de la SMA (d√©faut: 20)
        std_dev: Multiplicateur d'√©cart-type (d√©faut: 2.0)
        settings: Configuration alternative (surcharge period/std_dev)

    Returns:
        Tuple (upper_band, middle_band, lower_band) - np.ndarray de m√™me longueur que close
        Les premi√®res (period-1) valeurs seront NaN.
    """
       
                                    

         
                       ^
[1m.\indicators\bollinger.py[m[36m:[m150[36m:[m80[36m:[m [1m[31mE501[m line too long (96 > 79 characters)
__all__ = ["bollinger_bands", "BollingerSettings", "bollinger_bandwidth", "bollinger_percent_b"]
                                                                               ^
[1m.\indicators\cci.py[m[36m:[m16[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
"""
Module-ID: indicators.cci

Purpose: Indicateur CCI (Commodity Channel Index) - √©cart normalis√© du prix.

Role in pipeline: data

Key components: cci, CCISettings, calculate_cci

Inputs: DataFrame avec high, low, close; period, constant (0.015)

Outputs: np.ndarray (oscillateur)

Dependencies: pandas, numpy, dataclasses

Conventions: CCI = (prix - SMA) / (constante * mad); >100 surachat, <-100 survente.

Read-if: Modification p√©riode, constante normalisation.

Skip-if: Vous utilisez juste calculate_indicator('cci').
"""
   
                         

                                                ^
[1m.\indicators\donchian.py[m[36m:[m16[36m:[m80[36m:[m [1m[31mE501[m line too long (92 > 79 characters)
"""
Module-ID: indicators.donchian

Purpose: Indicateur Donchian Channel (breakout) - hauts/bas sur p√©riode.

Role in pipeline: data

Key components: donchian_channel, DonchianSettings, calculate_donchian

Inputs: DataFrame avec high, low; period

Outputs: Dict{upper, lower, middle} ou Tuple

Dependencies: pandas, numpy, dataclasses

Conventions: upper = max(high); lower = min(low); middle = (upper+lower)/2; breakout signal.

Read-if: Modification p√©riode, output format.

Skip-if: Vous utilisez juste calculate_indicator('donchian').
"""
   
                              

                                           ^
[1m.\indicators\ema.py[m[36m:[m53[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
    """
    Calcule la Simple Moving Average.

    Args:
        data: S√©rie de donn√©es (typiquement close)
        period: P√©riode de la moyenne

    Returns:
        Array SMA de m√™me longueur. Les premi√®res (period-1) valeurs seront NaN.
    """
       
                                     

         
                      ^
[1m.\indicators\ema.py[m[36m:[m61[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
        raise ValueError(f"Donn√©es insuffisantes: {len(data)} < period={period}")
                                                                               ^
[1m.\indicators\ema.py[m[36m:[m97[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
        raise ValueError(f"Donn√©es insuffisantes: {len(data)} < period={period}")
                                                                               ^
[1m.\indicators\ema.py[m[36m:[m101[36m:[m80[36m:[m [1m[31mE501[m line too long (87 > 79 characters)
    ema_values = data_series.ewm(span=period, adjust=adjust, min_periods=period).mean()
                                                                               ^
[1m.\indicators\ema.py[m[36m:[m121[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
    """
    Calcule les EMAs rapide et lente avec d√©tection de croisement.

    Args:
        data: Prix de cl√¥ture
        fast_period: P√©riode de l'EMA rapide
        slow_period: P√©riode de l'EMA lente

    Returns:
        Tuple (ema_fast, ema_slow, crossover_signal)
        crossover_signal: 1 = golden cross, -1 = death cross, 0 = pas de croisement
    """
       
                                                                  

   ^
[1m.\indicators\fear_greed.py[m[36m:[m4[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
"""
Module-ID: indicators.fear_greed

Purpose: Index crypto Peur & Avidite - utilise s√©rie fournie + lissage optionnel.

Role in pipeline: technical indicator

Key components: FearGreedSettings, fear_greed()

Inputs: fear_greed_series, smoothing_window, smoothing_type

Outputs: numpy array fear/greed score

Dependencies: numpy, pandas, indicators.ema, indicators.registry

Conventions: EMA ou SMA lissage; normalisation 0-100

Read-if: Utiliser Fear/Greed index pour contexte march√©.

Skip-if: Indicateur non utilis√©.
"""
   
                                

                                         ^
[1m.\indicators\fibonacci.py[m[36m:[m81[36m:[m80[36m:[m [1m[31mE501[m line too long (86 > 79 characters)
    rolling_high = high_series.rolling(window=period, min_periods=period).max().values
                                                                               ^
[1m.\indicators\fibonacci.py[m[36m:[m82[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
    rolling_low = low_series.rolling(window=period, min_periods=period).min().values
                                                                               ^
[1m.\indicators\fibonacci.py[m[36m:[m98[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
def calculate_fibonacci_levels(df: pd.DataFrame, **params) -> dict[str, np.ndarray]:
                                                                               ^
[1m.\indicators\ichimoku.py[m[36m:[m16[36m:[m80[36m:[m [1m[31mE501[m line too long (87 > 79 characters)
"""
Module-ID: indicators.ichimoku

Purpose: Indicateur Ichimoku Cloud - syst√®me complet japonais (5 lignes).

Role in pipeline: data

Key components: ichimoku, calculate_ichimoku, Tenkan, Kijun, Senkou A/B, Chikou

Inputs: DataFrame avec high, low, close; p√©riodes standards (9, 26, 52, 26)

Outputs: Dict{tenkan, kijun, senkou_a, senkou_b, chikou, cloud_position}

Dependencies: pandas, numpy

Conventions: Cloud = Senkou A/B; Tenkan croise Kijun = signal; Chikou retard√© 26 jours.

Read-if: Modification p√©riodes, output format.

Skip-if: Vous utilisez juste calculate_indicator('ichimoku').
"""
   
                              

                                           ^
[1m.\indicators\macd.py[m[36m:[m16[36m:[m80[36m:[m [1m[31mE501[m line too long (87 > 79 characters)
"""
Module-ID: indicators.macd

Purpose: Indicateur MACD (momentum) - ligne signal + histogram.

Role in pipeline: data

Key components: macd, calculate_macd, MACD line, Signal line, Histogram

Inputs: DataFrame avec close; fast_period, slow_period, signal_period

Outputs: Dict{macd, signal, histogram} ou Tuple

Dependencies: pandas, numpy, ema

Conventions: macd = ema_fast - ema_slow; signal = ema(macd); histogram = macd - signal.

Read-if: Modification p√©riodes, output structure.

Skip-if: Vous utilisez juste calculate_indicator('macd').
"""
   
                          

                                               ^
[1m.\indicators\macd.py[m[36m:[m93[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
    macd_line, signal_line, _ = macd(data, fast_period, slow_period, signal_period)
                                                                               ^
[1m.\indicators\macd.py[m[36m:[m100[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
        if macd_line[i] > signal_line[i] and macd_line[i-1] <= signal_line[i-1]:
                                                                               ^
[1m.\indicators\macd.py[m[36m:[m103[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
        elif macd_line[i] < signal_line[i] and macd_line[i-1] >= signal_line[i-1]:
                                                                               ^
[1m.\indicators\macd.py[m[36m:[m117[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
    """
    D√©tecte les divergences entre prix et histogram MACD.

    Une divergence haussi√®re: prix fait un plus bas, histogram fait un plus haut
    Une divergence baissi√®re: prix fait un plus haut, histogram fait un plus bas

    Args:
        prices: S√©rie de prix
        histogram: Histogram MACD
        lookback: P√©riode de lookback pour trouver les extrema

    Returns:
        Array: +1 (divergence haussi√®re), -1 (divergence baissi√®re), 0 (rien)
    """
       
                                                         

            ^
[1m.\indicators\macd.py[m[36m:[m118[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
    """
    D√©tecte les divergences entre prix et histogram MACD.

    Une divergence haussi√®re: prix fait un plus bas, histogram fait un plus haut
    Une divergence baissi√®re: prix fait un plus haut, histogram fait un plus bas

    Args:
        prices: S√©rie de prix
        histogram: Histogram MACD
        lookback: P√©riode de lookback pour trouver les extrema

    Returns:
        Array: +1 (divergence haussi√®re), -1 (divergence baissi√®re), 0 (rien)
    """
       
                                                         

            ^
[1m.\indicators\macd.py[m[36m:[m146[36m:[m80[36m:[m [1m[31mE501[m line too long (89 > 79 characters)
            if window_prices[-1] < window_prices[0] and window_hist[-1] > window_hist[0]:
                                                                               ^
[1m.\indicators\macd.py[m[36m:[m151[36m:[m80[36m:[m [1m[31mE501[m line too long (89 > 79 characters)
            if window_prices[-1] > window_prices[0] and window_hist[-1] < window_hist[0]:
                                                                               ^
[1m.\indicators\macd.py[m[36m:[m182[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
__all__ = ["macd", "macd_signal", "macd_histogram_divergence", "calculate_macd"]
                                                                               ^
[1m.\indicators\momentum.py[m[36m:[m16[36m:[m80[36m:[m [1m[31mE501[m line too long (89 > 79 characters)
"""
Module-ID: indicators.momentum

Purpose: Indicateur Momentum - taux changement prix simple.

Role in pipeline: data

Key components: momentum, MomentumSettings, calculate_momentum

Inputs: DataFrame avec close; period

Outputs: np.ndarray (diff√©rence close actuel - close n periodes avant)

Dependencies: pandas, numpy, dataclasses

Conventions: Momentum = Close - Close[n]; simple mais efficace acc√©l√©ration/d√©c√©l√©ration.

Read-if: Modification p√©riode.

Skip-if: Vous utilisez juste calculate_indicator('momentum').
"""
   
                              

                                           ^
[1m.\indicators\pivot_points.py[m[36m:[m121[36m:[m80[36m:[m [1m[31mE501[m line too long (86 > 79 characters)
    """Normalize method values coming from CLI/UI/sweep/optuna into a valid string."""
                                                                               ^
[1m.\indicators\psar.py[m[36m:[m145[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
    sar, trend = parabolic_sar(high, low, close, af_start, af_increment, af_max)
                                                                               ^
[1m.\indicators\psar.py[m[36m:[m186[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
    sar, trend = parabolic_sar(high, low, close, af_start, af_increment, af_max)
                                                                               ^
[1m.\indicators\registry.py[m[36m:[m8[36m:[m80[36m:[m [1m[31mE501[m line too long (89 > 79 characters)
"""
Module-ID: indicators.registry

Purpose: Registre centralis√© des indicateurs pour calcul + mapping unifi√©.

Role in pipeline: core

Key components: IndicatorRegistry, register_indicator, calculate_indicator, get_indicator

Inputs: Nom indicateur, DataFrame OHLCV, param√®tres

Outputs: R√©sultats indicateur (np.ndarray ou Dict)

Dependencies: Tous les modules indicators, pandas, numpy

Conventions: Registry singleton; API uniforme calculate_indicator(name, df, **params); fallback type checking.

Read-if: Ajout indicateur, modification API registre.

Skip-if: Vous appelez juste calculate_indicator().
"""
   
                              

                                           ^
[1m.\indicators\registry.py[m[36m:[m16[36m:[m80[36m:[m [1m[31mE501[m line too long (110 > 79 characters)
"""
Module-ID: indicators.registry

Purpose: Registre centralis√© des indicateurs pour calcul + mapping unifi√©.

Role in pipeline: core

Key components: IndicatorRegistry, register_indicator, calculate_indicator, get_indicator

Inputs: Nom indicateur, DataFrame OHLCV, param√®tres

Outputs: R√©sultats indicateur (np.ndarray ou Dict)

Dependencies: Tous les modules indicators, pandas, numpy

Conventions: Registry singleton; API uniforme calculate_indicator(name, df, **params); fallback type checking.

Read-if: Ajout indicateur, modification API registre.

Skip-if: Vous appelez juste calculate_indicator().
"""
   
                              

                                           ^
[1m.\indicators\registry.py[m[36m:[m118[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
        raise ValueError(f"Indicateur inconnu: '{name}'. Disponibles: {available}")
                                                                               ^
[1m.\indicators\registry.py[m[36m:[m170[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
        return {"macd": macd_line, "signal": signal_line, "histogram": histogram}
                                                                               ^
[1m.\indicators\registry.py[m[36m:[m329[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
    description="Stochastic Oscillator - Momentum indicator for overbought/oversold"
                                                                               ^
[1m.\indicators\registry.py[m[36m:[m423[36m:[m1[36m:[m [1m[31mF401[m '.amplitude_hunter' imported but unused
from . import (
^
[1m.\indicators\registry.py[m[36m:[m423[36m:[m1[36m:[m [1m[31mF401[m '.fear_greed' imported but unused
from . import (
^
[1m.\indicators\registry.py[m[36m:[m423[36m:[m1[36m:[m [1m[31mF401[m '.fibonacci' imported but unused
from . import (
^
[1m.\indicators\registry.py[m[36m:[m423[36m:[m1[36m:[m [1m[31mF401[m '.ichimoku' imported but unused
from . import (
^
[1m.\indicators\registry.py[m[36m:[m423[36m:[m1[36m:[m [1m[31mF401[m '.onchain_smoothing' imported but unused
from . import (
^
[1m.\indicators\registry.py[m[36m:[m423[36m:[m1[36m:[m [1m[31mF401[m '.pi_cycle' imported but unused
from . import (
^
[1m.\indicators\registry.py[m[36m:[m423[36m:[m1[36m:[m [1m[31mF401[m '.pivot_points' imported but unused
from . import (
^
[1m.\indicators\registry.py[m[36m:[m423[36m:[m1[36m:[m [1m[31mF401[m '.psar' imported but unused
from . import (
^
[1m.\indicators\registry.py[m[36m:[m423[36m:[m1[36m:[m [1m[31mF401[m '.standard_deviation' imported but unused
from . import (
^
[1m.\indicators\registry.py[m[36m:[m423[36m:[m1[36m:[m [1m[31mF401[m '.volume_oscillator' imported but unused
from . import (
^
[1m.\indicators\registry.py[m[36m:[m423[36m:[m1[36m:[m [1m[31mF401[m '.vortex' imported but unused
from . import (
^
[1m.\indicators\registry.py[m[36m:[m423[36m:[m1[36m:[m [1m[31mE402[m module level import not at top of file
from . import (
^
[1m.\indicators\registry.py[m[36m:[m472[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
        cache_key = f"{name}_{hash(df.index[0])}_{hash(df.index[-1])}_{str(params)}"
                                                                               ^
[1m.\indicators\rsi.py[m[36m:[m43[36m:[m80[36m:[m [1m[31mE501[m line too long (92 > 79 characters)
                f"Niveaux invalides: oversold={self.oversold}, overbought={self.overbought}"
                                                                               ^
[1m.\indicators\smart_legs.py[m[36m:[m136[36m:[m80[36m:[m [1m[31mE501[m line too long (88 > 79 characters)
__all__ = ['calculate_smart_legs_bullish', 'calculate_smart_legs_bearish', 'smart_legs']
                                                                               ^
[1m.\indicators\standard_deviation.py[m[36m:[m65[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
    std_values = close_series.rolling(window=period, min_periods=period).std(ddof=0)
                                                                               ^
[1m.\indicators\stoch_rsi.py[m[36m:[m16[36m:[m80[36m:[m [1m[31mE501[m line too long (93 > 79 characters)
"""
Module-ID: indicators.stoch_rsi

Purpose: Indicateur Stochastic RSI - stochastique appliqu√© √† RSI.

Role in pipeline: data

Key components: stochastic_rsi, calculate_stoch_rsi, %K, %D, signal

Inputs: DataFrame avec close; rsi_period, stoch_period, k_smooth, d_smooth

Outputs: Dict{k, d, signal} ou Tuple

Dependencies: pandas, numpy, rsi

Conventions: RSI liss√©, puis stochastique appliqu√©e; sensibilit√© augment√©e surachat/survente.

Read-if: Modification p√©riodes RSI/Stoch, lissages K/D.

Skip-if: Vous utilisez juste calculate_indicator('stoch_rsi').
"""
   
                               

                                          ^
[1m.\indicators\stoch_rsi.py[m[36m:[m76[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
            stoch_rsi[i] = (rsi_values[i] - rsi_min) / (rsi_max - rsi_min) * 100
                                                                               ^
[1m.\indicators\stoch_rsi.py[m[36m:[m128[36m:[m80[36m:[m [1m[31mE501[m line too long (88 > 79 characters)
    k_line, d_line = stochastic_rsi(close, rsi_period, stoch_period, k_smooth, d_smooth)
                                                                               ^
[1m.\indicators\stoch_rsi.py[m[36m:[m166[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
    """
    D√©tecte les divergences entre le prix et le Stochastic RSI.

    Args:
        close: S√©rie des prix de cl√¥ture
        k_line: Valeurs %K du Stochastic RSI
        lookback: P√©riode de recherche (d√©faut: 14)

    Returns:
        1 = divergence haussi√®re, -1 = divergence baissi√®re, 0 = pas de divergence
    """
       
                                                               

      ^
[1m.\indicators\stoch_rsi.py[m[36m:[m187[36m:[m80[36m:[m [1m[31mE501[m line too long (86 > 79 characters)
        # Divergence haussi√®re: prix fait un plus bas, mais StochRSI fait un plus haut
                                                                               ^
[1m.\indicators\stoch_rsi.py[m[36m:[m192[36m:[m80[36m:[m [1m[31mE501[m line too long (86 > 79 characters)
        # Divergence baissi√®re: prix fait un plus haut, mais StochRSI fait un plus bas
                                                                               ^
[1m.\indicators\stochastic.py[m[36m:[m16[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
"""
Module-ID: indicators.stochastic

Purpose: Indicateur Stochastic (%K + %D signal) - timing survente/surachat.

Role in pipeline: data

Key components: stochastic, StochasticSettings, calculate_stochastic, %K, %D

Inputs: DataFrame avec high, low, close; k_period, d_period

Outputs: Dict{stoch_k, stoch_d} ou Tuple

Dependencies: pandas, numpy, dataclasses

Conventions: %K position prix dans range; %D = SMA(%K); <20 survente, >80 surachat.

Read-if: Modification p√©riodes K/D, formule %K.

Skip-if: Vous utilisez juste calculate_indicator('stochastic').
"""
   
                                

                                         ^
[1m.\indicators\stochastic.py[m[36m:[m89[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
    range_hl = np.where(range_hl == 0, np.nan, range_hl)  # √âviter division par z√©ro
                                                                               ^
[1m.\indicators\stochastic.py[m[36m:[m148[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
    stoch_k, stoch_d = stochastic(high, low, close, k_period, d_period, smooth_k)
                                                                               ^
[1m.\indicators\supertrend.py[m[36m:[m16[36m:[m80[36m:[m [1m[31mE501[m line too long (88 > 79 characters)
"""
Module-ID: indicators.supertrend

Purpose: Indicateur SuperTrend - suivi tendance bas√© ATR (tr√®s populaire).

Role in pipeline: data

Key components: supertrend, SuperTrendSettings, calculate_supertrend

Inputs: DataFrame avec high, low, close; atr_period, atr_mult

Outputs: Dict{supertrend, direction} ou Tuple

Dependencies: pandas, numpy, atr, dataclasses

Conventions: bandes = hl_avg +/- ATR*mult; direction 1/-1; support/r√©sistance dynamique.

Read-if: Modification ATR params, output format.

Skip-if: Vous utilisez juste calculate_indicator('supertrend').
"""
   
                                

                                         ^
[1m.\indicators\supertrend.py[m[36m:[m83[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
        if basic_upper[i] < final_upper[i - 1] or close[i - 1] > final_upper[i - 1]:
                                                                               ^
[1m.\indicators\supertrend.py[m[36m:[m89[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
        if basic_lower[i] > final_lower[i - 1] or close[i - 1] < final_lower[i - 1]:
                                                                               ^
[1m.\indicators\swing.py[m[36m:[m4[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
"""
Module-ID: indicators.swing

Purpose: Detection swing highs/lows (fractals) - COMPARAISON ADJACENTE UNIQUEMENT.

Role in pipeline: data / pattern detection

Key components: calculate_swing_high, calculate_swing_low, swing (wrapper)

Inputs: DataFrame avec high/low; pas de parametre lookback

Outputs: np.ndarray boolean (True = swing detected)

Dependencies: pandas, numpy

Conventions: SwingHigh[i] = (high[i] > high[i-1] AND high[i] > high[i+1])
             SwingLow[i] = (low[i] < low[i-1] AND low[i] < low[i+1])

CRITICAL: NE PAS utiliser de lookback variable - c'est une erreur conceptuelle.
"""
   
                           

                                              ^
[1m.\indicators\volume_oscillator.py[m[36m:[m42[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
            raise ValueError(f"short_period must be >= 1, got: {self.short_period}")
                                                                               ^
[1m.\indicators\volume_oscillator.py[m[36m:[m44[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
            raise ValueError(f"long_period must be >= 1, got: {self.long_period}")
                                                                               ^
[1m.\indicators\volume_oscillator.py[m[36m:[m86[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
    oscillator = np.where(long_ma != 0, (short_ma - long_ma) / long_ma * 100.0, 0.0)
                                                                               ^
[1m.\indicators\vortex.py[m[36m:[m228[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
    signal = vortex_signal(df["high"], df["low"], df["close"], period, threshold)
                                                                               ^
[1m.\indicators\vwap.py[m[36m:[m16[36m:[m80[36m:[m [1m[31mE501[m line too long (96 > 79 characters)
"""
Module-ID: indicators.vwap

Purpose: Indicateur VWAP (prix moyen pond√©r√© par volume) institutionnel.

Role in pipeline: data

Key components: vwap, VWAPSettings, calculate_vwap

Inputs: DataFrame avec high, low, close, volume; anchored, period flags

Outputs: np.ndarray (VWAP cumulatif ou glissant)

Dependencies: pandas, numpy, dataclasses

Conventions: VWAP = somme(prix*vol) / somme(vol); ancr√© ou glissant; prix institutionnel de ref.

Read-if: Modification ancrage, p√©riode glissante.

Skip-if: Vous utilisez juste calculate_indicator('vwap').
"""
   
                          

                                               ^
[1m.\indicators\vwap.py[m[36m:[m85[36m:[m80[36m:[m [1m[31mE501[m line too long (89 > 79 characters)
        vwap_values = np.where(rolling_vol != 0, rolling_tp / rolling_vol, typical_price)
                                                                               ^
[1m.\metrics_types.py[m[36m:[m3[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
from typing import Any, Dict, Literal, Mapping, TypedDict, Union, cast, overload
                                                                               ^
[1m.\metrics_types.py[m[36m:[m63[36m:[m80[36m:[m [1m[31mE501[m line too long (88 > 79 characters)
def _validate_range(payload: Mapping[str, Any], key: str, lo: float, hi: float) -> None:
                                                                               ^
[1m.\metrics_types.py[m[36m:[m86[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
        if canonical in normalized and normalized[canonical] != normalized[alias]:
                                                                               ^
[1m.\metrics_types.py[m[36m:[m109[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
def normalize_metrics(payload: Mapping[str, Any], unit: Unit) -> Dict[str, Any]:
                                                                               ^
[1m.\performance\__init__.py[m[36m:[m4[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
"""
Module-ID: performance.__init__

Purpose: Package performance - exports profiler, parallel, monitor, GPU, benchmarks.

Role in pipeline: performance optimization & observability

Key components: Re-exports ParallelRunner, Profiler, PerformanceMonitor, GPUIndicatorCalculator

Inputs: None (module imports only)

Outputs: Public API via __all__

Dependencies: .profiler, .parallel, .monitor, .memory, .gpu, .device_backend, .benchmark

Conventions: __all__ d√©finit API publique; imports conditionnels pour optional deps.

Read-if: Modification exports ou module structure.

Skip-if: Vous importez directement depuis performance.profiler.
"""
   
                               

                                          ^
[1m.\performance\__init__.py[m[36m:[m8[36m:[m80[36m:[m [1m[31mE501[m line too long (95 > 79 characters)
"""
Module-ID: performance.__init__

Purpose: Package performance - exports profiler, parallel, monitor, GPU, benchmarks.

Role in pipeline: performance optimization & observability

Key components: Re-exports ParallelRunner, Profiler, PerformanceMonitor, GPUIndicatorCalculator

Inputs: None (module imports only)

Outputs: Public API via __all__

Dependencies: .profiler, .parallel, .monitor, .memory, .gpu, .device_backend, .benchmark

Conventions: __all__ d√©finit API publique; imports conditionnels pour optional deps.

Read-if: Modification exports ou module structure.

Skip-if: Vous importez directement depuis performance.profiler.
"""
   
                               

                                          ^
[1m.\performance\__init__.py[m[36m:[m14[36m:[m80[36m:[m [1m[31mE501[m line too long (88 > 79 characters)
"""
Module-ID: performance.__init__

Purpose: Package performance - exports profiler, parallel, monitor, GPU, benchmarks.

Role in pipeline: performance optimization & observability

Key components: Re-exports ParallelRunner, Profiler, PerformanceMonitor, GPUIndicatorCalculator

Inputs: None (module imports only)

Outputs: Public API via __all__

Dependencies: .profiler, .parallel, .monitor, .memory, .gpu, .device_backend, .benchmark

Conventions: __all__ d√©finit API publique; imports conditionnels pour optional deps.

Read-if: Modification exports ou module structure.

Skip-if: Vous importez directement depuis performance.profiler.
"""
   
                               

                                          ^
[1m.\performance\__init__.py[m[36m:[m16[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
"""
Module-ID: performance.__init__

Purpose: Package performance - exports profiler, parallel, monitor, GPU, benchmarks.

Role in pipeline: performance optimization & observability

Key components: Re-exports ParallelRunner, Profiler, PerformanceMonitor, GPUIndicatorCalculator

Inputs: None (module imports only)

Outputs: Public API via __all__

Dependencies: .profiler, .parallel, .monitor, .memory, .gpu, .device_backend, .benchmark

Conventions: __all__ d√©finit API publique; imports conditionnels pour optional deps.

Read-if: Modification exports ou module structure.

Skip-if: Vous importez directement depuis performance.profiler.
"""
   
                               

                                          ^
[1m.\performance\benchmark.py[m[36m:[m76[36m:[m80[36m:[m [1m[31mE501[m line too long (100 > 79 characters)
            f"{'Name':<30} | {'Time (ms)':>8} | {'Memory':>7} | {'Throughput':>10} | {'Speedup':>8}"
                                                                               ^
[1m.\performance\benchmark.py[m[36m:[m81[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
            speedup = baseline.duration_ms / result.duration_ms if baseline else 1.0
                                                                               ^
[1m.\performance\benchmark.py[m[36m:[m90[36m:[m80[36m:[m [1m[31mE501[m line too long (98 > 79 characters)
            improvement = (baseline.duration_ms - winner.duration_ms) / baseline.duration_ms * 100
                                                                               ^
[1m.\performance\benchmark.py[m[36m:[m286[36m:[m80[36m:[m [1m[31mE501[m line too long (106 > 79 characters)
    signals = pd.Series(np.random.choice([0, 1, -1], size=n_bars, p=[0.95, 0.025, 0.025]), index=df.index)
                                                                               ^
[1m.\performance\benchmark.py[m[36m:[m430[36m:[m80[36m:[m [1m[31mE501[m line too long (90 > 79 characters)
    parser = argparse.ArgumentParser(description="Ex√©cuter les benchmarks de performance")
                                                                               ^
[1m.\performance\device_backend.py[m[36m:[m93[36m:[m80[36m:[m [1m[31mE501[m line too long (86 > 79 characters)
        if os.environ.get("BACKTEST_DISABLE_GPU", "").lower() in ("1", "true", "yes"):
                                                                               ^
[1m.\performance\device_backend.py[m[36m:[m112[36m:[m80[36m:[m [1m[31mE501[m line too long (104 > 79 characters)
                name=props["name"].decode() if isinstance(props["name"], bytes) else str(props["name"]),
                                                                               ^
[1m.\performance\gpu.py[m[36m:[m4[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
"""
Module-ID: performance.gpu

Purpose: Acc√©l√©ration GPU optionnelle - CuPy arrays, Numba CUDA kernels, d√©tection.

Role in pipeline: performance optimization

Key components: gpu_available(), GPUIndicatorCalculator, CuPy/Numba wrappers, fallback CPU

Inputs: NumPy arrays, GPU device ID

Outputs: CuPy GPU arrays (si disponible) sinon NumPy CPU arrays

Dependencies: cupy (optionnel), numba (optionnel), numpy

Conventions: GPU optional; transparent CPU fallback; device management.

Read-if: Modification GPU kernel ou device selection.

Skip-if: Vous appelez gpu_available() ou GPUIndicatorCalculator.sma().
"""
   
                          

                                               ^
[1m.\performance\gpu.py[m[36m:[m8[36m:[m80[36m:[m [1m[31mE501[m line too long (90 > 79 characters)
"""
Module-ID: performance.gpu

Purpose: Acc√©l√©ration GPU optionnelle - CuPy arrays, Numba CUDA kernels, d√©tection.

Role in pipeline: performance optimization

Key components: gpu_available(), GPUIndicatorCalculator, CuPy/Numba wrappers, fallback CPU

Inputs: NumPy arrays, GPU device ID

Outputs: CuPy GPU arrays (si disponible) sinon NumPy CPU arrays

Dependencies: cupy (optionnel), numba (optionnel), numpy

Conventions: GPU optional; transparent CPU fallback; device management.

Read-if: Modification GPU kernel ou device selection.

Skip-if: Vous appelez gpu_available() ou GPUIndicatorCalculator.sma().
"""
   
                          

                                               ^
[1m.\performance\gpu.py[m[36m:[m113[36m:[m80[36m:[m [1m[31mE501[m line too long (104 > 79 characters)
                    name = props["name"].decode() if isinstance(props["name"], bytes) else props["name"]
                                                                               ^
[1m.\performance\gpu.py[m[36m:[m129[36m:[m80[36m:[m [1m[31mE501[m line too long (85 > 79 characters)
                    logger.info(f"  GPU {device_id}: {name} ({total_mem_gb:.1f} GB)")
                                                                               ^
[1m.\performance\gpu.py[m[36m:[m132[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
                    logger.warning(f"  GPU {device_id}: Erreur d√©tection - {e}")
                                                                               ^
[1m.\performance\gpu.py[m[36m:[m138[36m:[m80[36m:[m [1m[31mE501[m line too long (89 > 79 characters)
        """S√©lectionne le meilleur GPU (plus de m√©moire = plus puissant g√©n√©ralement)."""
                                                                               ^
[1m.\performance\gpu.py[m[36m:[m148[36m:[m80[36m:[m [1m[31mE501[m line too long (87 > 79 characters)
                matching = [d for d in self._available_devices if d["id"] == forced_id]
                                                                               ^
[1m.\performance\gpu.py[m[36m:[m151[36m:[m80[36m:[m [1m[31mE501[m line too long (95 > 79 characters)
                    logger.info(f"GPUDeviceManager: GPU {forced_id} forc√© via BACKTEST_GPU_ID")
                                                                               ^
[1m.\performance\gpu.py[m[36m:[m154[36m:[m80[36m:[m [1m[31mE501[m line too long (99 > 79 characters)
                    logger.warning(f"GPUDeviceManager: GPU {forced_id} non trouv√©, s√©lection auto")
                                                                               ^
[1m.\performance\gpu.py[m[36m:[m156[36m:[m80[36m:[m [1m[31mE501[m line too long (91 > 79 characters)
                logger.warning(f"GPUDeviceManager: BACKTEST_GPU_ID invalide: {forced_gpu}")
                                                                               ^
[1m.\performance\gpu.py[m[36m:[m159[36m:[m80[36m:[m [1m[31mE501[m line too long (86 > 79 characters)
        best_device = max(self._available_devices, key=lambda d: d["total_memory_gb"])
                                                                               ^
[1m.\performance\gpu.py[m[36m:[m164[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
                f"GPUDeviceManager: S√©lection automatique du GPU le plus puissant: "
                                                                               ^
[1m.\performance\gpu.py[m[36m:[m208[36m:[m80[36m:[m [1m[31mE501[m line too long (88 > 79 characters)
                    f"Attendu {self._device_id}, actuel {current_device}. Correction..."
                                                                               ^
[1m.\performance\gpu.py[m[36m:[m325[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
    """
    Calculateur d'indicateurs avec acc√©l√©ration GPU.

    Utilise CuPy pour les op√©rations vectorielles sur GPU.
    Fallback automatique sur CPU si GPU non disponible.

    Le GPUDeviceManager garantit l'utilisation d'un seul GPU
    (le plus puissant par d√©faut) pour √©viter les probl√®mes
    de switch entre GPUs.

    Example:
        >>> calc = GPUIndicatorCalculator(use_gpu=True)
        >>>
        >>> # SMA sur GPU
        >>> sma = calc.sma(prices, period=20)
        >>>
        >>> # EMA sur GPU
        >>> ema = calc.ema(prices, period=12)
        >>>
        >>> # Bollinger Bands sur GPU
        >>> upper, middle, lower = calc.bollinger_bands(prices, period=20, std=2.0)
    """
       
                                                    

                 ^
[1m.\performance\gpu.py[m[36m:[m358[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
        """D√©termine si le GPU doit √™tre utilis√© pour cette taille de donn√©es."""
                                                                               ^
[1m.\performance\gpu.py[m[36m:[m361[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
    def _to_array(self, data: Union[np.ndarray, pd.Series], use_gpu: bool) -> Any:
                                                                               ^
[1m.\performance\gpu.py[m[36m:[m379[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
    def sma(self, prices: Union[np.ndarray, pd.Series], period: int) -> np.ndarray:
                                                                               ^
[1m.\performance\gpu.py[m[36m:[m399[36m:[m80[36m:[m [1m[31mE501[m line too long (98 > 79 characters)
        result[period-1:] = (cumsum[period-1:] - xp.concatenate([[0], cumsum[:-period]])) / period
                                                                               ^
[1m.\performance\gpu.py[m[36m:[m403[36m:[m80[36m:[m [1m[31mE501[m line too long (83 > 79 characters)
    def ema(self, prices: Union[np.ndarray, pd.Series], period: int) -> np.ndarray:
                                                                               ^
[1m.\performance\gpu.py[m[36m:[m445[36m:[m80[36m:[m [1m[31mE501[m line too long (88 > 79 characters)
    def rsi(self, prices: Union[np.ndarray, pd.Series], period: int = 14) -> np.ndarray:
                                                                               ^
[1m.\performance\gpu.py[m[36m:[m567[36m:[m80[36m:[m [1m[31mE501[m line too long (81 > 79 characters)
        tr2 = xp.abs(high_arr - xp.concatenate([[close_arr[0]], close_arr[:-1]]))
                                                                               ^
[1m.\performance\gpu.py[m[36m:[m568[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
        tr3 = xp.abs(low_arr - xp.concatenate([[close_arr[0]], close_arr[:-1]]))
                                                                               ^
[1m.\performance\memory.py[m[36m:[m16[36m:[m80[36m:[m [1m[31mE501[m line too long (86 > 79 characters)
"""
Module-ID: performance.memory

Purpose: Gestion intelligente m√©moire - chunking, pr√©chargement, auto-cleanup.

Role in pipeline: performance optimization

Key components: ChunkedProcessor, MemoryManager, @chunked, auto_gc()

Inputs: Large DataFrame/Array, chunk_size, memory_limit_gb

Outputs: Processed chunks, memory usage stats, freed memory

Dependencies: numpy, pandas, gc, weakref, tempfile, psutil (optionnel)

Conventions: Chunks power-of-2; GC auto apr√®s threshold; spill disk si limit exceeded.

Read-if: Modification chunking strategy ou memory limits.

Skip-if: Vous appelez processor.process(df) iterator.
"""
   
                             

                                            ^
[1m.\performance\memory.py[m[36m:[m97[36m:[m80[36m:[m [1m[31mE501[m line too long (93 > 79 characters)
        return sum(get_object_size_mb(item) for item in obj) + sys.getsizeof(obj) / (1024**2)
                                                                               ^
[1m.\performance\memory.py[m[36m:[m145[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
        """Ajuste dynamiquement la taille des chunks selon la m√©moire disponible."""
                                                                               ^
[1m.\performance\memory.py[m[36m:[m154[36m:[m80[36m:[m [1m[31mE501[m line too long (88 > 79 characters)
            logger.warning(f"M√©moire faible! Chunk size r√©duit √† {self._adaptive_size}")
                                                                               ^
[1m.\performance\memory.py[m[36m:[m305[36m:[m80[36m:[m [1m[31mE501[m line too long (102 > 79 characters)
            logger.warning(f"Limite m√©moire d√©pass√©e: {mem.process_rss_gb:.2f}GB > {self.limit_gb}GB")
                                                                               ^
[1m.\performance\memory.py[m[36m:[m309[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
            logger.warning(f"Seuil m√©moire syst√®me atteint: {mem.percent:.1f}%")
                                                                               ^
[1m.\performance\memory.py[m[36m:[m361[36m:[m80[36m:[m [1m[31mE501[m line too long (105 > 79 characters)
        self.cache_dir = Path(cache_dir) if cache_dir else Path(tempfile.gettempdir()) / "backtest_cache"
                                                                               ^
[1m.\performance\memory.py[m[36m:[m378[36m:[m80[36m:[m [1m[31mE501[m line too long (103 > 79 characters)
        while self._memory_cache and self._current_memory_mb() + needed_mb > self.max_memory_gb * 1024:
                                                                               ^
[1m.\performance\memory.py[m[36m:[m380[36m:[m80[36m:[m [1m[31mE501[m line too long (96 > 79 characters)
            lru_key = min(self._memory_cache.keys(), key=lambda k: self._access_times.get(k, 0))
                                                                               ^
[1m.\performance\memory.py[m[36m:[m388[36m:[m80[36m:[m [1m[31mE501[m line too long (89 > 79 characters)
                logger.debug(f"Spilled {lru_key} to disk ({self._sizes[lru_key]:.1f}MB)")
                                                                               ^
[1m.\performance\memory.py[m[36m:[m441[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
                if self._current_memory_mb() + size_mb <= self.max_memory_gb * 1024:
                                                                               ^
[1m.\performance\memory.py[m[36m:[m474[36m:[m80[36m:[m [1m[31mE501[m line too long (84 > 79 characters)
            "keys": list(self._memory_cache.keys()) + list(self._disk_cache.keys()),
                                                                               ^
[1m.\performance\memory.py[m[36m:[m505[36m:[m80[36m:[m [1m[31mE501[m line too long (80 > 79 characters)
def optimize_dataframe(df: pd.DataFrame, inplace: bool = False) -> pd.DataFrame:
                                                                               ^
[1m.\performance\monitor.py[m[36m:[m4[36m:[m80[36m:[m [1m[31mE501[m line too long (82 > 79 characters)
"""
Module-ID: performance.monitor

Purpose: Monitoring temps r√©el syst√®me (CPU, m√©moire, I/O, GPU) pendant ex√©cution.

Role in pipeline: observability

Key components: PerformanceMonitor, ResourceTracker, psutil wrapper, Rich display

Inputs: None (reads system metrics)

Outputs: Stats {cpu_pct, mem_mb, io_r_mb, gpu_mem_mb}, timeline

Dependencies: psutil, threading, time, rich (optionnel)

Conventions: Background thread safe; thread-safe stats dict; 1s interval.

Read-if: Modification metrics collection ou refresh interval.

Skip-if: Vous appelez monitor.get_stats().
"""